#+TITLE: Wurfkreuz's GNU Emacs Config
#+AUTHOR: Alex Gud
#+DESCRIPTION: Empty.
#+STARTUP: showeverything ; Wont apply folding
#+OPTIONS: toc:3 ; Table of contents include 3 header levels down

* TABLE OF CONTENTS :toc:
- [[#general-emacs-setting][GENERAL EMACS SETTING]]
  - [[#visuals][Visuals]]
  - [[#system][System]]
  - [[#custom-commands][Custom Commands]]
  - [[#cursor][Cursor]]
  - [[#find-file][Find-file]]
- [[#packages][PACKAGES]]
  - [[#elpaca-package-manager][Elpaca Package Manager]]
  - [[#theme-and-font][Theme and Font]]
  - [[#general][General]]
  - [[#async][Async]]
  - [[#search][Search]]
  - [[#consult][Consult]]
  - [[#jinx][Jinx]]
  - [[#completion][Completion]]
  - [[#acess-to-env-variables][Acess to ENV variables]]
  - [[#treesitter][Treesitter]]
  - [[#sudo-edit][Sudo Edit]]
  - [[#cider][Cider]]
  - [[#projectile][Projectile]]
  - [[#ivy][Ivy]]
  - [[#hydra][Hydra]]
- [[#dired][Dired]]
  - [[#dired-keybindings][Dired keybindings]]
- [[#tramp][Tramp]]
- [[#shells-and-terminals][Shells and Terminals]]
  - [[#eshell][Eshell]]
  - [[#async-shell][Async shell]]
  - [[#eat][Eat]]
  - [[#cmd][Cmd]]
  - [[#cursor-changer][Cursor changer]]
- [[#database][Database]]
- [[#sessions][Sessions]]
- [[#buffers][Buffers]]
  - [[#windmove][Windmove]]
  - [[#messages-buffer][Messages buffer]]
  - [[#dired-buffer][Dired buffer]]
  - [[#cmd-shell-buffer][Cmd shell buffer]]
  - [[#shell-buffer][Shell buffer]]
  - [[#eshell-buffer][Eshell buffer]]
  - [[#transpose-frame][Transpose frame]]
  - [[#posframe][Posframe]]
  - [[#shackle][Shackle]]
  - [[#popper][Popper]]
- [[#language-support][LANGUAGE SUPPORT]]
  - [[#lsp-bridge][Lsp-bridge]]
  - [[#flycheck][Flycheck]]
  - [[#lsp-mode][Lsp Mode]]
  - [[#eglot][Eglot]]
- [[#org-mode][Org Mode]]
  - [[#general-1][General]]
  - [[#org-download][Org download]]
  - [[#org-modern][Org modern]]
  - [[#drill][Drill]]
  - [[#agenda][Agenda]]
  - [[#org-roam][Org-roam]]
  - [[#templates][Templates]]
  - [[#visuals-1][Visuals]]
  - [[#source-block-tag-expansion-cheat-sheet][Source block tag expansion cheat sheet]]
  - [[#enabling-table-of-contents][Enabling Table of Contents]]
  - [[#custom-key-bindings][Custom key bindings]]
- [[#keybindings][Keybindings]]
- [[#custom-functions][Custom functions]]

* GENERAL EMACS SETTING
** Visuals

#+begin_src emacs-lisp

  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (setq inhibit-startup-screen t)
  (setq display-line-numbers 'visual
        display-line-numbers-type 'relative)
  (add-hook 'conf-mode-hook 'display-line-numbers-mode)
  (add-hook 'conf-space-mode-hook 'display-line-numbers-mode)
  (global-display-line-numbers-mode 1)

  (defun my-mode-line-major-mode ()
    "Returns a clean name of the current major mode."
    (let ((mode (format "%s" major-mode)))
      (replace-regexp-in-string "-mode$" "" mode)))

  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  (:eval (if (buffer-file-name)
                            (abbreviate-file-name (buffer-file-name))  ; Show abbreviated file path
                          "%b"))  ; Show buffer name if not a file buffer
                  " "
                  (:eval (my-mode-line-major-mode))  ; Custom major mode display
                  (:eval (propertize " " 'display '(space :align-to (- right 12))))
                  (vc-mode vc-mode)))  ; Git branch information

#+end_src

*** Tabs

#+begin_src emacs-lisp

  (setq tab-bar-close-button-show nil
        tab-bar-new-button-show nil)

  (defun my-tab-name-format-function (tab i)
    (defface my-active-tab-face
      '((t :background "#2e2c3d" :foreground "#e0def4"))  ;; #373c42 - previous background color
      ;; '((t :background "#3c3836" :foreground "#fbf1c7"))  ;; gruvbox-dark hard
      ;; '((t :background "#282c34" :foreground "#bbc2cf"))
      "Face for the active tab.")
    (defface my-inactive-tab-face
        '((t :background "#1d1f21" :foreground "#6e6a86")) ;; #21242b - previous background color
      ;; '((t :background "#1d2021" :foreground "#a89984"))
      ;; '((t :background "#21242b" :foreground "#83898d"))
      "Face for the inactive tab.")
    (let ((current-p (eq (car tab) 'current-tab)))
      (if current-p
          (propertize (format "%d %s" i (alist-get 'name (cdr tab))) 'face 'my-active-tab-face)
        (propertize (format "%d %s" i (alist-get 'name (cdr tab))) 'face 'my-inactive-tab-face))))

  (setq tab-bar-tab-name-format-function #'my-tab-name-format-function)

  (dotimes (i 9)
    (let ((n (1+ i)))  ; Tab numbers start from 1
      (global-set-key (kbd (format "M-%d" n))
                      `(lambda () (interactive) (tab-bar-select-tab ,n)))))

    #+end_src

** System

#+begin_src emacs-lisp

  ;; (server-start)
  (global-set-key (kbd "C-x u") 'windmove-up)
  (setq evil-want-keybinding nil)

  (setq vc-follow-symlinks t)

  (setq dired-recursive-deletes 'always)

  (setq desktop-load-locked-desktop t)
  (setq backup-inhibited t)

  (auto-fill-mode 1)
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'auto-fill-mode)

  (setq python-shell-interpreter "/usr/bin/python3")

  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; Autoinsertion on the search buffer
  (setq ivy-initial-inputs-alist nil)
  ;; (setq ivy-initial-inputs-alist ;; If you want there are situations where you would like to have it enabled, try this code.
  ;;     '((counsel-M-x . "")
  ;;       (t . "^")))

  ;; (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (setq-default indent-tabs-mode nil)
  (savehist-mode 1)

  ;; Executable on save if starts with '#!'
  (add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

  (setq undo-tree-auto-save-history t)
  (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo-tree-history"))))
  (make-directory (concat user-emacs-directory "auto-saves") t)
  (setq auto-save-file-name-transforms
        `((".*" ,(concat user-emacs-directory "auto-saves/") t)))
  (make-directory (concat user-emacs-directory "lock-files") t)
  (setq lock-file-name-transforms
        `((".*" ,(concat user-emacs-directory "lock-files/") t)))
  (setq desktop-dirname (concat user-emacs-directory "desktop/"))
  (make-directory (concat user-emacs-directory "backups") t)
  (setq backup-directory-alist
        `((".*" . ,(concat user-emacs-directory "backups/"))))

  ;; Save sessions
  (unless (file-exists-p desktop-dirname)
    (make-directory desktop-dirname))
  (desktop-save-mode 1)
  (setq desktop-save 't)
  (setq desktop-path (list desktop-dirname))
  (setq desktop-auto-save-timeout 30)
  (setq desktop-auto-save-timeout nil)

  (setq auto-save-interval 1)  ; Auto-save every 1 second
  (setq auto-save-timeout 10)  ; Auto-save after 10 seconds of idle time
  (setq auto-save-no-message t)
  
  ;;   ;; Function to enable auto-save when entering normal state
  ;; (defun enable-auto-save-on-normal-state ()
  ;; (when (and (boundp 'evil-state) (eq evil-state 'normal))
  ;; (auto-save-mode 1)))

  ;; ;; Function to disable auto-save when entering insert state
  ;; (defun disable-auto-save-on-insert-state ()
  ;; (when (and (boundp 'evil-state) (eq evil-state 'insert))
  ;; (auto-save-mode -1)))

  ;; ;; Enable auto-save when entering normal state
  ;; (add-hook 'evil-normal-state-entry-hook 'enable-auto-save-on-normal-state)
  ;; ;; Disable auto-save when entering insert state
  ;; (add-hook 'evil-insert-state-entry-hook 'disable-auto-save-on-insert-state)

  ;; (defun my-save-buffers-on-exit ()
  ;; "Save all file-visiting buffers before exiting Emacs or killing a buffer."
  ;; (save-some-buffers t))
  ;; (add-hook 'kill-emacs-hook 'my-save-buffers-on-exit)
  ;; (add-hook 'kill-buffer-hook 'my-save-buffers-on-exit)

  (setq save-place-file (concat user-emacs-directory "saveplace/places"))

  ;; Save cursor position
  (unless (file-exists-p (concat user-emacs-directory "saveplace/"))
    (make-directory (concat user-emacs-directory "saveplace/")))
  (save-place-mode 1)

  (scroll-bar-mode -1)
  (pixel-scroll-mode 1)
  (setq-default display-line-numbers-width 3)
  (setq-default scroll-margin 8)
  (setq use-dialog-box nil)
  (set-fringe-mode 0)
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (setq global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode 1)

  (setq-default truncate-lines t)

  (setenv "PATH" (concat "/home/wurfkreuz/.ghcup/bin:" (getenv "PATH")))

  (setq scroll-conservatively 101)
  (setq scroll-margin 5)
  (setq scroll-step 1)

#+end_src

** Custom Commands

#+begin_src emacs-lisp

  (defun emc ()
    "Open a specific file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defun alc ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/zellij/config.kdl"))

  (defun zsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/zsh/.zshrc"))

  (defun bsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/bash/.bashrc"))

  (defun scr ()
    "Open a specific file."
    (interactive)
    (find-file "~/.secret_dotfiles"))

  (defun szsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.secret_dotfiles/zsh/.zshrc"))

  (defun scripts ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/scripts/"))

  (defun so ()
    "Reload the Emacs configuration."
    (interactive)
    (load-file "~/.emacs.d/init.el")
    (load-file "~/.emacs.d/init.el"))

  (with-eval-after-load 'evil
    (evil-ex-define-cmd "so" 'so))

  (defun z (q)
    "Query zoxide and launch dired or change directory in Eshell."
    (interactive "sZoxide: ")
    (if-let
        ((zoxide (executable-find "zoxide"))
        (target
          (with-temp-buffer
            (if (= 0 (call-process zoxide nil t nil "query" q))
                (string-trim (buffer-string))))))
        (if (derived-mode-p 'eshell-mode)
            (eshell/cd target)
          (funcall-interactively #'dired target))
      (unless zoxide (error "Install zoxide"))
      (unless target (error "No Match"))))

  (defun git-push ()
    "Execute git add, commit, and push in sequence."
    (interactive)
    (let ((output-buffer (get-buffer-create "*Git Push Output*")))
      (with-current-buffer output-buffer
        (erase-buffer))
      (call-process-shell-command "git add . && git commit -m 'n' && git push" nil output-buffer)
      (display-buffer output-buffer)))

  (defun s ()
    "Reload the ~/.zshrc file in the current shell."
    (interactive)
    (call-process-shell-command "source ~/.zshrc" nil 0))

#+end_src

** Cursor

#+begin_src emacs-lisp

  (blink-cursor-mode 0)
  (setq show-paren-delay 0)
  (show-paren-mode 1)

#+end_src

** Find-file

#+begin_src emacs-lisp

  (defun find-file-check-dir (filename &optional wildcards)
    "Edit file FILENAME.
     Switch to a buffer visiting file FILENAME,
     creating one if none already exists.
     If the directory path does not exist, create it."
     (interactive
      (find-file-read-args "Find file: " nil))
     (let ((dir (file-name-directory filename)))
       (when (not (file-exists-p dir))
        (make-directory dir t)))
     (find-file filename wildcards))
     #+end_src

* Packages
** Straight

#+begin_src emacs-lisp
    (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
          "straight/repos/straight.el/bootstrap.el"
          (or (bound-and-true-p straight-base-dir)
              user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src

;;* PACKAGES
;;** Elpaca Package Manager
;;
;;#+begin_src emacs-lisp
;;
;;  (setq elpaca-core-date '(20231228))
;;  (defvar elpaca-installer-version 0.7)
;;  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
;;  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
;;  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
;;  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
;;                          :ref nil
;;                          :files (:defaults (:exclude "extensions"))
;;                          :build (:not elpaca--activate-package)))
;;  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
;;   (build (expand-file-name "elpaca/" elpaca-builds-directory))
;;   (order (cdr elpaca-order))
;;   (default-directory repo))
;;    (add-to-list 'load-path (if (file-exists-p build) build repo))
;;    (unless (file-exists-p repo)
;;      (make-directory repo t)
;;      (when (< emacs-major-version 28) (require 'subr-x))
;;      (condition-case-unless-debug err
;;    (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
;;             ((zerop (call-process "git" nil buffer t "clone"
;;                                   (plist-get order :repo) repo)))
;;             ((zerop (call-process "git" nil buffer t "checkout"
;;                                   (or (plist-get order :ref) "--"))))
;;             (emacs (concat invocation-directory invocation-name))
;;             ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
;;                                   "--eval" "(byte-recompile-directory \".\" 0 'force)")))
;;             ((require 'elpaca))
;;             ((elpaca-generate-autoloads "elpaca" repo)))
;;        (kill-buffer buffer)
;;      (error "%s" (with-current-buffer buffer (buffer-string))))
;;  ((error) (warn "%s" err) (delete-directory repo 'recursive))))
;;    (unless (require 'elpaca-autoloads nil t)
;;      (require 'elpaca)
;;      (elpaca-generate-autoloads "elpaca" repo)
;;      (load "./elpaca-autoloads")))
;;  (add-hook 'after-init-hook #'elpaca-process-queues)
;;  (elpaca `(,@elpaca-order))
;;     ;; Install use-package support
;;  (elpaca elpaca-use-package
;;    ;; Enable :elpaca use-package keyword.
;;    (elpaca-use-package-mode)
;;    ;; Assume :elpaca t unless otherwise specified.
;;    (setq elpaca-use-package-by-default t))
;;
;;  ;; Block until current queue processed.
;;  (elpaca-wait)
;;
;;  ;; Example of using recipe
;;  ;; (use-package blimpy
;;  ;;    :elpaca (blimpy :host github :repo "username/reponame"))
;;
;;#+end_src

 ** Evil Mode

#+begin_src emacs-lisp

  (use-package undo-tree
    :config
    (global-undo-tree-mode))

  ;; (use-package evil
  ;;   :init
  ;;   (setq evil-want-C-u-scroll t
  ;;         evil-want-C-i-jump nil
  ;;         evil-want-integration t)
  ;;   :config
  ;;   (evil-mode 1)
  ;;   (evil-set-initial-state 'custom-theme-choose-mode 'normal)
  ;;   (setq evil-shift-width 2)
  ;;   (add-hook 'evil-mode-hook 'undo-tree-mode))

  ;; (add-hook 'after-init-hook
  ;;         (lambda ()
  ;;           (add-hook 'evil-local-mode-hook 'turn-on-undo-tree-mode)))

  (use-package evil
  :init
  (setq evil-want-C-u-scroll t
        evil-want-C-i-jump nil
        evil-want-integration t
        evil-undo-system 'undo-tree) ;; Move this line here
  :config
  (evil-mode 1)
  (evil-set-initial-state 'custom-theme-choose-mode 'normal)
  (setq evil-shift-width 2))

  (add-hook 'term-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'eat-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'eshell-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'wdired-mode-hook (lambda () (undo-tree-mode 1)))


  (setq evil-undo-system 'undo-tree)

  (use-package evil-surround
    :config
    (global-evil-surround-mode 1)
    ;; Add custom surround pairs
    (setq-default evil-surround-pairs-alist
                  (append evil-surround-pairs-alist
                          '((?/ . ("/" . "/"))
                            (?~ . ("~" . "~"))
                            (?* . ("*" . "*"))
                            (?= . ("=" . "="))
                            (?+ . ("+" . "+"))))))

  (use-package evil-commentary
    :config
    (evil-commentary-mode))

  (use-package evil-org
    :after org
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme)))
    )
  ;; :ensure nil)

  (use-package evil-collection
    :after evil
    :init ;;    (setq evil-want-keybinding nil)
    :config
    (setq evil-collection-mode-list '(dashboard eshell dired wdired ibuffer org emacs-eat term ansi lsp-ui-imenu elpaca))
    (evil-collection-init))


  (add-hook 'text-mode-hook 'display-line-numbers-mode)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  (defun my-evil-yank-to-end-of-line ()
    "Yank text from the current point to the end of the line."
    (interactive)
    (evil-yank (point) (line-end-position)))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "Y") 'my-evil-yank-to-end-of-line))

#+end_src

*** Custom keybindings

#+begin_src emacs-lisp

  (with-eval-after-load 'evil
    (define-key evil-insert-state-map (kbd "C-S-v") 'yank)
    (define-key evil-visual-state-map (kbd "{") 'evil-backward-paragraph)
    (define-key evil-visual-state-map (kbd "}") 'evil-forward-paragraph)
    (define-key evil-insert-state-map (kbd "M-w") 'evil-forward-word-begin)
    (define-key evil-insert-state-map (kbd "M-b") 'evil-backward-word-begin)
    (define-key evil-insert-state-map (kbd "M-W") 'evil-forward-WORD-begin)
    (define-key evil-insert-state-map (kbd "M-B") 'evil-backward-WORD-begin)

    (define-key evil-normal-state-map (kbd "gq") 'FormatToThreshold)
    (define-key evil-visual-state-map (kbd "gq") 'FormatToThreshold))


#+end_src

** Theme and Font

#+begin_src emacs-lisp

  ;; (require 'color)
  ;;  (hl-line-mode 1)

  (add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))(put 'eval 'safe-local-variable #'identity)
  (load-theme 'rose-pine t)

  ;; (use-package gruvbox-theme
  ;;   :config
  ;;   (load-theme 'gruvbox-dark-hard t))

  ;; (use-package doom-themes
  ;;   :ensure t
  ;;   :config
  ;;   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
  ;;         doom-themes-enable-italic nil) ; if nil, italics is universally disabled
  ;;   (load-theme 'doom-one t)
  ;;   ;Corrects (and improves) org-mode's native fontifcation.
  ;;   (doom-themes-org-config))


  (when (member "NotoSansM Nerd Font Mono" (font-family-list))
    (set-face-attribute 'default nil :font "NotoSansM Nerd Font Mono-12:weight=medium")

    ;; Set a different font for italics
    (set-face-attribute 'italic nil
                        :family "NotoSans Nerd Font"
                        :slant 'italic
                        :weight 'normal
                        :height 130)

    (add-hook 'org-mode-hook
              (lambda ()
                (set-face-attribute 'org-verbatim nil
                                    ;; :family "NotoSerifNerdFontPropo-CondensedExtraLight"
                                    :family "NotoSerifNerdFont"
                                    :height 130
                                    ;; :foreground "#8bc34a"  ; Adjust the color as desired
                                    :weight 'normal))))

#+end_src

*** Icons

#+begin_src emacs-lisp

  (use-package all-the-icons
    :ensure t
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))

#+end_src

** General

#+begin_src emacs-lisp

  (use-package general
    :config
    (general-evil-setup)

  ;; "C-M-j" 'counsel-switch-buffer

  ;; set up 'SPC' as the global leader key
  (general-create-definer w/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "M-SPC") ;; access leader in insert mode

  (w/leader-keys

    ;; Fuzzy finder
    "fb" '(counsel-switch-buffer :wk "Choose and switch to an active buffer")
    "fe" '(OpenDiredBufferInCurrentWindow :wk "Open a full screen dired buffer in a current window")
    "ff" '(projectile-find-file :wk "Find file fuzzy finder with a git directory as an anchor")
    "fd" '(projectile-find-dir :wk "Find file modified")
    ;; "fh" '(fzf-from-home-no-prompt :wk "Fzf with fd and hidden files from a home directory")
    ;; "fr" '(fzf-from-root-with-fd-no-prompt :wk "Fzf with fd and hidden files form root")
    ;; "fc" '(fzf-from-current-with-fd :wk "Fzf with fd and hidden files with a prompt from a current directory")
    "fh" '(fzf-from-home-with-fd :wk "Fzf with fd and hidden files with an ability to change the searching point")
    "fr" '(fzf-from-root-with-fd :wk "Fzf with fd and hidden files form root")
    "fn" '(fzf-notes :wk "Start fzf in the notes directory.")

    ;; Session management
    "ss" '(save-current-desktop-session :wk "Save the current desktop session into its corresponding directory")
    "sd" '(delete-desktop-session :wk "Delete selected session")
    "sl" '(load-desktop-with-name :wk "Load a desktop session by name, chosen from available sessions")
    "sr" '(rename-desktop-session :wk "Rename a desktop session")

    ;; Org
    "ot" '(todo :wk "Opens the org todo file")

    ;; Tab management
    "tn" '(tab-bar-new-tab :wk "Create a new tab")
    "tx" '(tab-bar-close-tab :wk "Close a tab")
    "tr" '(tab-bar-rename-tab :wk "Rename a tab")

    "w"  'hydra-window-size/body

    ;; Window swapping
    "bk" '(buf-move-up :wk "Swap with buffer above")
    "bj" '(buf-move-down :wk "Swap with buffer below")
    "bh" '(buf-move-left :wk "Swap with buffer left")
    "bl" '(buf-move-right :wk "Swap with buffer right")

    "bc" '(kill-buffer :wk "Close selecetd buffer")

    ;; "mm" '(popper-message :wk "Open the *Messages buffer")

    "xx" '(kill-buffer-and-window :wk "Close buffer with its window")

    ;; "pp" '(git-push :wk "Activate an elisp copy of the git push alias")

    ;; Popper
    ;; "pm" '(popper-messages :wk "Open a pop window with the messages buffer")
    ;; "pa" '(popper-async-shell-command :wk "Perform async shell command in a pop window")

    "cc" '(RunCmdShellCommand :wk "Run CMD command")
    "ch" '(my-hoogle-search :wk "Hoogle search prompt in the shell cmd")

    ;; "ts" '(SpawnShellSplitBelow :wk "Spawn shell below")

    "zz" '(z :wk "Call zoxide prompt")

    "vv" '(OpenVtermBelow :wk "Toggle vterm")

    "dd" '(OpenDiredBufferInSplit :wk "Open Dired buffer in split")
    "de" '(wdired-change-to-wdired-mode :wk "Switch to wdired mode")

    "ld" '(lsp-find-definition :wk "Open diagnostic list in a separate split")
    ;; "lk" '(lsp-describe-thing-at-point :wk "Open a hover window")
    "lk" '(lsp-ui-doc-show :wk "Show hover documentation")
    ;; "ld" '(lsp-bridge-diagnostic-list :wk "Open diagnostic list in a separate split")
    ;; "lk" '(lsp-bridge-popup-documentation :wk "Open a hover window")

    "ee" '(eshell :wk "Eshell")
    "en" '(eshell-new :wk "Spawn a new eshell buffer")

    ;; Evaluation
    "e" '(:ignore t :wk "Evaluate/Eshell")
    "eb" '(eval-buffer :wk "Evaluate elisp in buffer")
    "ed" '(eval-defun :wk "Evaluate defun containing or after point")
    "ex" '(eval-expression :wk "Evaluate and elisp expression")
    "el" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "er" '(eval-region :wk "Evaluate elisp in region")

    ;; Eshell
    "es" '(counsel-esh-history :wk "Eshell history")
    ;; "ef" '(vertico-buffers/eshell :wk "test")

        )
    (dotimes (i 9)
        (let ((n (1+ i))) ; Tab numbers start from 1
          (general-def
            :states '(normal emacs)
            :keymaps 'override
            :prefix "SPC"
            (format "%d" n) `(lambda () (interactive) (tab-bar-select-tab ,n)))))
  )

#+end_src

** Async

#+begin_src emacs-lisp

  (use-package async
    :config
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1))

#+end_src

** Search

#+begin_src emacs-lisp

      ;; (use-package rg
      ;; :config
      ;; (rg-enable-default-bindings))

#+end_src

** Consult

#+begin_src emacs-lisp

  ;; (use-package consult)

  ;; (defun consult-fd-from-home ()
  ;;   "Starts a consult-find search from the user's home directory using fd,
  ;; including hidden files and excluding certain directories."
  ;;   (interactive)
  ;;   (let ((consult-find-command "fd --hidden --exclude .git --color=never --full-path"))
  ;;     (consult-find "~/")))

#+end_src

** Jinx

#+begin_src emacs-lisp

  (use-package jinx
    ;; :hook
    ;; (dolist (hook '(text-mode-hook prog-mode-hook conf-mode-hook))
    ;; (add-hook hook #'jinx-mode))
    :bind (("M-$" . jinx-correct)
           ("C-M-$" . jinx-languages)))

#+end_src

** Completion

*** Snippets

#+begin_src emacs-lisp

  (use-package yasnippet
    :config
    (yas-global-mode 1)
    ;; Add your snippets directory to `yas-snippet-dirs`
    ;; (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets/org-mode/")
    ;; (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets/org-mode/")
    ;; Load the snippets
    (yas-reload-all))

#+end_src

*** Orderless

#+begin_src emacs-lisp

  (use-package orderless
    :custom
    (completion-styles '(orderless basic))
    (completion-category-overrides '((file (styles basic partial-completion)))))

#+end_src

*** Company

#+begin_src emacs-lisp

  (use-package company
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    :config
    (add-to-list 'company-backends 'company-files)
    (setq company-require-match nil)
    (setq company-minimum-prefix-length 1)
    (setq company-idle-delay nil))

  ;; (use-package company
  ;;   :init
  ;;   (add-hook 'after-init-hook 'global-company-mode)
  ;;   :config
  ;;   ;; Add company-files to the list of backends
  ;;   (add-to-list 'company-backends 'company-files)
  ;;   (setq company-minimum-prefix-length 1)
  ;;   (setq company-idle-delay 0.1))

  (defun my/company-manual-complete ()
    "Enable company-mode and call company-complete."
    (interactive)
    (unless company-mode
      (company-mode 1))  ; Enable company-mode in the current buffer if it's not already enabled
    (company-complete))

  (with-eval-after-load 'evil
    (define-key evil-insert-state-map (kbd "C-n") 'my/company-manual-complete))

#+end_src

** Acess to ENV variables

#+begin_src emacs-lisp

  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))

#+end_src

** Treesitter

#+begin_src emacs-lisp

  ;; (use-package treesit-auto
  ;;   :config
  ;;   (treesit-auto-add-to-auto-mode-alist
  ;;   '(("\\.py$" . python-ts-mode)
  ;;     ("\\.rb$" . ruby-ts-mode)
  ;;     ("\\.go$" . go-ts-mode)
  ;;     ("\\.bashrc\\'" . shell-mode)
  ;;     ("\\.zshrc\\'" . shell-mode))) ; Removed the extra parentheses here
  ;;   (global-treesit-auto-mode))

  (use-package clojure-ts-mode)

  (setq treesit-language-source-alist
        '((templ "https://github.com/vrischmann/tree-sitter-templ")
          (bash "https://github.com/tree-sitter/tree-sitter-bash")
          (cmake "https://github.com/uyha/tree-sitter-cmake")
          (css "https://github.com/tree-sitter/tree-sitter-css")
          ;; (elisp "https://github.com/Wilfred/tree-sitter-elisp")
          (go "https://github.com/tree-sitter/tree-sitter-go")
          (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
          (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (make "https://github.com/alemuller/tree-sitter-make")
          (markdown "https://github.com/ikatyang/tree-sitter-markdown")
          (python "https://github.com/tree-sitter/tree-sitter-python")
          (toml "https://github.com/tree-sitter/tree-sitter-toml")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript"
                      "master" "typescript/src")
          (yaml "https://github.com/ikatyang/tree-sitter-yaml")
          (clojure "https://github.com/sogaiu/tree-sitter-clojure")
          (haskell "https://github.com/tree-sitter/tree-sitter-haskell")
          (typst "https://github.com/uben0/tree-sitter-typst")
          (java "https://github.com/tree-sitter/tree-sitter-java")
          (ruby "https://github.com/tree-sitter/tree-sitter-ruby")
          (rust "https://github.com/tree-sitter/tree-sitter-rust")))

  (add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.clj\\'" . clojure-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.sh\\'" . bash-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.toml\\'" . toml-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.py\\'" . python-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-ts-mode))
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-ts-mode))

#+end_src

** Sudo Edit

#+begin_src emacs-lisp

  (use-package sudo-edit
    :config
      (w/leader-keys
         "sf" '(sudo-edit-find-file :wk "Sudo find file")
         "se" '(sudo-edit :wk "Sudo edit file")))

#+end_src

** Cider

#+begin_src emacs-lisp

  (use-package cider)
  ;; (let ((lisp-dir "~/.emacs.d/lisp")
  ;;       (cider-dir "~/.emacs.d/lisp/cider")
  ;;       (cider-repo "git@github.com:clojure-emacs/cider.git"))
  ;;   ;; Check if the lisp directory exists, if not, create it
  ;;   (unless (file-directory-p lisp-dir)
  ;;     (make-directory lisp-dir t))

  ;;   ;; Check if the cider directory exists
  ;;   (unless (file-directory-p cider-dir)
  ;;     ;; If cider directory does not exist, check if git is available
  ;;     (if (executable-find "git")
  ;;         (progn
  ;;           (message "Cloning cider...")
  ;;           (shell-command (concat "git clone " cider-repo " " cider-dir))
  ;;           (message "cider cloned successfully."))
  ;;       (error "Git is not installed, cannot clone cider"))))

  ;;   ;; Add cider to the load-path
  ;; (add-to-list 'load-path "~/.emacs.d/lisp/cider")
  ;; (require 'cider)

#+end_src

** Projectile

#+begin_src emacs-lisp

  (defun my/projectile-project-root-advice (original-projectile-root &rest args)
    "Advice to make Projectile recognize custom project roots."
    (or (cl-some (lambda (path)
                  (when (string-prefix-p (expand-file-name path)
                                          (expand-file-name default-directory))
                    path))
                my-org-project-paths)
        (apply original-projectile-root args)))

  (use-package projectile
    :config
    (projectile-mode 1)
    (advice-add 'projectile-project-root :around #'my/projectile-project-root-advice))

  (defvar my-org-project-paths
  '("/home/wurfkreuz/.secret_dotfiles/org/"
    "/some/other/org/path/"))

  (defun my-projectile-project-root ()
    (let ((default-directory (or (buffer-file-name) default-directory)))
      (cl-some (lambda (path)
                (when (string-match-p path default-directory) path))
              my-org-project-paths)
      (projectile-project-root)))

  (add-hook 'projectile-find-file-hook #'my-projectile-project-root)

#+end_src

** Ivy

#+begin_src emacs-lisp

  (use-package counsel
    :after ivy
    :config
    (counsel-mode))
  (global-set-key (kbd "C-c C-y") 'cousel-yank-pop)

    ;; (push '(counsel-esh-history . ivy-display-function-fallback) ivy-display-functions-alist))

  (use-package ivy
    :bind
    ;; ivy-resume resumes the last Ivy-based completion.
    (("C-c C-r" . ivy-resume)
     ("C-x B" . ivy-switch-buffer-other-window))
    :custom
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq enable-recursive-minibuffers t)
    :config
    (ivy-mode))

  (use-package ivy-posframe
    :ensure t
    :after ivy
    :config
    (ivy-posframe-mode 1))
    (setq ivy-posframe-width 50)
    (setq ivy-posframe-display-functions-alist
        '((counsel-esh-history . ivy-posframe-display-at-window-center)))

  ;; To display icons correctly, you should run M-x all-the-icons-install-fonts to install the necessary fonts.
  (use-package all-the-icons-ivy-rich
    :init
    (all-the-icons-ivy-rich-mode 1))

  (use-package ivy-rich
    :after ivy
    :ensure t
    :init (ivy-rich-mode 1) ;; this gets us descriptions in M-x.
    :custom
    (ivy-virtual-abbreviate 'full
                            ivy-rich-switch-buffer-align-virtual-buffer t
                            ivy-rich-path-style 'abbrev))

  (defun counsel-find-file-check-dir ()
    "Like `counsel-find-file', but use `find-file-check-dir' instead of `find-file'."
    (interactive)
    (let* ((current-dir (if (eq major-mode 'dired-mode)
                            "."
                            (buffer-file-name))))
      (ivy-read "Find file: " #'read-file-name-internal
                :matcher #'counsel--find-file-matcher
                :action #'find-file-check-dir
                :preselect current-dir
                :require-match 'confirm-after-completion
                :history 'file-name-history
                :keymap counsel-find-file-map
                :caller 'counsel-find-file)))

  (global-set-key (kbd "C-x f") 'counsel-find-file-check-dir)

#+end_src

*** Fzf

#+begin_src emacs-lisp

  (use-package fzf)

  (defun fzf-from-home-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
        and exclude certain directories but with an ability to interactively change
        the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    (let ((default-directory "~/"))
      (fzf-directory)))

  (defun fzf-from-root-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
        and exclude certain directories but with an ability to interactively change
        the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")
    (let ((default-directory "/"))
      (fzf-directory)))

  (defun fzf-notes ()
    "Start fzf in the notes directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    (let ((default-directory "~/.secret_dotfiles/org"))
      (fzf-directory)))

  ;; (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")

  (defun fzf-from-root-no-prompt ()
    "Starts fzf from the user's root directory using fd to include hidden files
    and exclude certain directories without prompting for a directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")
    (fzf))
  
  (defun fzf-from-home-no-prompt ()
    "Starts fzf from the user's home directory using fd to include hidden files
      and exclude certain directories without prompting for a directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git . /home/wurfkreuz")
    (fzf))

  (defun fzf-from-current-with-fd ()
    "Starts fzf from the current directory using fd to include hidden files
     and exclude certain directories. Works both locally and on remote servers."
    (interactive)
    ;; Set the FZF_DEFAULT_COMMAND environment variable
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    ;; Check if the current directory is a TRAMP directory
    (let ((tramp-address (file-remote-p default-directory)))
      (if tramp-address
          ;; If we're in a TRAMP directory, use the extracted address
          (fzf-directory tramp-address)
        ;; If not in a TRAMP directory, use the local home directory
        (fzf-directory "~/"))))

  (setq fzf/args "-x --color bw --print-query --margin=1,0 --no-hscroll --inline-info --bind ctrl-n:down,ctrl-p:up")

#+end_src

** Hydra

#+begin_src emacs-lisp

  (defun my-enlarge-window-horizontally ()
    "Enlarge the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (shrink-window-horizontally 5)
      (enlarge-window-horizontally 5)))

  (defun my-shrink-window-horizontally ()
    "Shrink the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (enlarge-window-horizontally 5)
      (shrink-window-horizontally 5)))

  (use-package hydra
    :config
    (defhydra hydra-window-size (:color red)
      "window size"
      ("h" my-shrink-window-horizontally "shrink horizontally")
      ("l" my-enlarge-window-horizontally "enlarge horizontally")
      ("k" (lambda () (interactive) (shrink-window 3)) "shrink vertically")
      ("j" (lambda () (interactive) (enlarge-window 3)) "enlarge vertically")
      ("t" transpose-frame "transpose windows")
      ("q" nil "quit")))

#+end_src

* Dired

#+begin_src emacs-lisp

  ;; (add-hook 'dired-mode-hook
  ;;         (lambda ()
  ;;           (wdired-change-to-wdired-mode)))

  (setq delete-by-moving-to-trash t
        trash-directory "~/.local/share/trash")

  (setq wdired-allow-to-create-files t)
  (setq wdired-allow-to-change-permissions t)

  (setq evil-move-cursor-back nil)
  (add-hook 'wdired-mode-hook #'evil-normal-state)

#+end_src


** Dired keybindings

#+begin_src emacs-lisp

  ;; (evil-define-key 'normal dired-mode-map
  ;;   (kbd "+") 'dired-create-directory))

#+end_src

* Tramp

#+begin_src emacs-lisp

  (require 'tramp)

  (setq tramp-ssh-controlmaster-options (format "-i %s" "~/.ssh/git"))
  (add-to-list 'tramp-connection-properties
               (list (regexp-quote "/ssh:")
                     "direct-async-process" t))

  ;; cache file-name forever
  (setq remote-file-name-inhibit-cache nil)

  ;; make sure vc stuff is not making tramp slower
  (setq vc-ignore-dir-regexp
        (format "%s\\|%s"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))

  ;; not sure why we have this? just cargo-culting from an answer I saw
  ;; online.
  (setq tramp-verbose 1)

  ;; projectile has the fun side-effect of wanting to calculate the
  ;; project name, which makes tramp oh-so-much-slower.
  (setq projectile-mode-line "Projectile")

#+end_src

* Shells and Terminals
** Eshell

#+begin_src emacs-lisp

    (setq eshell-destroy-buffer-when-process-dies t)

    (use-package eshell-syntax-highlighting
      :after esh-mode
      :config
      (eshell-syntax-highlighting-global-mode +1))

    (add-hook 'eshell-mode-hook 'eshell-hist-mode)  ; Enable Eshell history mode
    (add-hook 'eshell-mode-hook 'eshell-toggle-direct-send)

  (setq eshell-rc-script (concat user-emacs-directory "eshell/eshelrc")
        eshell-aliases-file (concat user-emacs-directory "eshell/aliases")
        eshell-history-size 100000
        eshell-buffer-maximum-lines 5000
        ;; eshell-save-history-on-exit t
          eshell-history-file-name "~/.emacs.d/eshell_history"
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t
          eshell-destroy-buffer-when-process-dies t
          eshell-banner-message ""
          eshell-visual-commands'("bash" "htop" "ssh" "top" "gpg"))

    (add-hook 'eshell-mode-hook
              (lambda ()
                (setq-local scroll-margin 0)))

    (with-eval-after-load 'eshell
      ;; Set eshell-save-history-on-exit to nil
      (setq eshell-save-history-on-exit nil)

      ;; Define eshell-append-history function
      (defun eshell-append-history ()
        "Call `eshell-write-history' with the `append' parameter set to `t'."
        (when eshell-history-ring
          (let ((newest-cmd-ring (make-ring 1)))
            (ring-insert newest-cmd-ring (car (ring-elements eshell-history-ring)))
            (let ((eshell-history-ring newest-cmd-ring))
              (eshell-write-history eshell-history-file-name t)))))

    ;; Add eshell-append-history to eshell-pre-command-hook
    (add-hook 'eshell-pre-command-hook #'eshell-append-history))

    (defun eshell-insert-last-argument ()
      "Insert the last argument of the previous command."
      (interactive)
      (let* ((last-command (eshell-previous-input-string 0))
             (args (split-string-and-unquote last-command))
             (last-arg (car (last args))))
        (when last-arg
          (insert last-arg))))

    (defun setup-eshell-keys ()
      (define-key eshell-mode-map (kbd "M-.") 'eshell-insert-last-argument))
    ;; (define-key eshell-mode-map (kbd "M-r") 'counsel-esh-history))

    (add-hook 'eshell-mode-hook 'setup-eshell-keys)

    (with-eval-after-load 'evil
      (evil-define-key 'insert eshell-mode-map (kbd "M-r") 'counsel-esh-history)
      (evil-define-key 'normal eshell-mode-map (kbd "M-r") 'counsel-esh-history))

    (defun eshell/edit (filename)
      "Open FILENAME in the current buffer, using the current TRAMP address."
      (interactive "sEnter the filename to edit: ")
      ;; Extract the current TRAMP address from the Eshell buffer's default directory
      (let ((tramp-address (file-remote-p default-directory)))
        (if tramp-address
            ;; If we're in a TRAMP directory, use the extracted address
            (find-file (concat tramp-address filename))
          ;; If not in a TRAMP directory, fall back to a default address or prompt the user
          (message "Not in a TRAMP directory. Please specify the TRAMP address manually.")
          ;; Optionally, you can add a fallback mechanism here, e.g., prompting the user for a TRAMP address
          )))

    (defalias 'e 'eshell/edit)

    ;; (require 'em-tramp) ; to load eshell’s sudo
    ;; (setq eshell-prefer-lisp-functions t)
    ;; (setq eshell-prefer-lisp-variables t)
    (setq password-cache t) ; enable password caching
    ;; (setq password-cache-expiry 10)
    ;; (add-hook 'eshell-load-hook (lambda () (add-to-list 'eshell-modules-list 'eshell-tramp)))

    (defun eshell-clear-buffer ()
      "Clear the current Eshell buffer."
      (interactive)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (eshell-send-input)))

    (defun eshell-new ()
      "Create a new Eshell buffer with a unique name."
      (interactive)
      (let ((eshell-buffer-name (generate-new-buffer-name "*eshell*")))
        (eshell)))

#+end_src

** Async shell

#+begin_src emacs-lisp

  ;; (defun my-async-shell-command (command)
  ;;   "Run async-shell-command with the specified COMMAND and set the output buffer height."
  ;;   (interactive
  ;;    (list (read-shell-command "Async shell command: ")))
  ;;   (let ((buffer (generate-new-buffer-name "*Async Shell Command*"))
  ;;         (height 35)) ; Set the desired height in number of lines
  ;;     (async-shell-command command buffer)
  ;;     (pop-to-buffer buffer)
  ;;     (fit-window-to-buffer nil height)))

  ;; (global-set-key (kbd "M-&") 'my-async-shell-command)

  ;; Execute async shell command on a current file
  (defun async-shell-command-on-file (command)
    "Execute COMMAND asynchronously on the current file."
    (interactive (list (read-shell-command
                        (concat "Async shell command on " (buffer-name) ": "))))
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (async-shell-command (concat command " " filename))))

#+end_src

** Eat

#+begin_src emacs-lisp

  ;; (let ((lisp-dir "~/.emacs.d/lisp")
  ;;       (emacs-eat-dir "~/.emacs.d/lisp/emacs-eat")
  ;;       (emacs-eat-repo "git@github.com:kephale/emacs-eat.git"))
  ;;   ;; Check if the lisp directory exists, if not, create it
  ;;   (unless (file-directory-p lisp-dir)
  ;;     (make-directory lisp-dir t))

  ;;   ;; Check if the emacs-eat directory exists
  ;;   (unless (file-directory-p emacs-eat-dir)
  ;;     ;; If emacs-eat directory does not exist, check if git is available
  ;;     (if (executable-find "git")
  ;;         (progn
  ;;           (message "Cloning emacs-eat...")
  ;;           (shell-command (concat "git clone " emacs-eat-repo " " emacs-eat-dir))
  ;;           (message "emacs-eat cloned successfully."))
  ;;       (error "Git is not installed, cannot clone emacs-eat"))))

  ;;   ;; Add emacs-eat to the load-path
  ;; (add-to-list 'load-path "~/.emacs.d/lisp/emacs-eat")
  ;; (require 'eat)
  ;; (eat-eshell-mode 1)
  ;; ;; (setq eshell-visual-commands nil)

  ;; (add-hook 'eshell-first-time-mode-hook
  ;;           #'eat-eshell-visual-command-mode)
  ;; (add-hook 'eshell-first-time-mode-hook #'eat-eshell-mode)

#+end_src

** Cmd

#+begin_src emacs-lisp

  (defun my-hoogle-search (query)
    "Search Hoogle for QUERY."
    (interactive "sHoogle search: ") ; Prompt for the search term
    (shell-command (concat "hoogle search " (shell-quote-argument query))))

#+end_src

** Cursor changer

#+begin_src emacs-lisp

  (use-package evil-terminal-cursor-changer
    :config
    (unless (display-graphic-p)
      (require 'evil-terminal-cursor-changer)
      (evil-terminal-cursor-changer-activate) ; or (etcc-on)
      )
    )

#+end_src

* Database

#+begin_src emacs-lisp

      ;; Define the connection details for PostgreSQL, including two databases
      (setq sql-connection-alist
            '((postgres-wurfkreuz
              (sql-product 'postgres)
              (sql-user "wurfkreuz")
              (sql-server "localhost")
              (sql-port 5432)
              (sql-database "wurfkreuz"))
              (postgres-shelf
              (sql-product 'postgres)
              (sql-user "wurfkreuz") ; Assuming the same user for simplicity
              (sql-server "localhost")
              (sql-port 5432)
              (sql-database "shelf"))))

  (defun my-sql-connect-with-buffer (connection)
  "Connect to a SQL database using `sql-connect' and open a new SQL mode buffer."
  (interactive (list (completing-read "Select database: "
                                      (mapcar #'car sql-connection-alist)
                                      nil t)))
  (let ((sql-buffer (sql-connect connection)))
    (when (and (boundp 'sql-buffer) sql-buffer)
      (delete-other-windows)
      (switch-to-buffer (get-buffer-create "*SQL Buffer*"))
      (sql-mode)
      (split-window-below)
      (other-window 1)
      (switch-to-buffer sql-buffer)
      (balance-windows))))

  (defun show-table (table-name)
    "Describe the specified table by selecting a few rows."
    (interactive "sTable name: ")
    (let ((query (format "SELECT * FROM %s LIMIT 5;" table-name)))
      (with-current-buffer sql-buffer
        (goto-char (point-max))
        (insert query)
        (sql-send-paragraph))))

#+end_src

* Sessions

#+begin_src emacs-lisp

  (defvar current-desktop-session-name nil
    "The name of the currently loaded desktop session.")

  (defvar desktop-autosave-timer nil
    "Timer object for desktop autosave, to avoid multiple timers running.")

  (defun save-eshell-buffer (desktop-dirname)
    ;; Save the current working directory.
    default-directory)

  (defun restore-eshell-buffer (_file-name buffer-name misc)
    "MISC is the value returned by `save-eshell-buffer'.
        _FILE-NAME is nil."
    (let ((default-directory misc))
      ;; Create an eshell buffer named BUFFER-NAME in directory MISC.
      (eshell buffer-name)))

  ;; Save all eshell-mode buffers.
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local desktop-save-buffer #'save-eshell-buffer)))

  ;; Restore all eshell-mode buffers.
  (add-to-list 'desktop-buffer-mode-handlers '(eshell-mode . restore-eshell-buffer))

  (defun save-current-desktop-session (&optional manual-save)
    "Save the current desktop session using the current session name.
      If no session is loaded, prompt to create a new one. If MANUAL-SAVE is non-nil, show a message for existing sessions."
    (interactive "p") ; "p" passes a prefix argument, which is non-nil when called interactively
    (if current-desktop-session-name
        (let ((desktop-dir (concat user-emacs-directory "desktop/" current-desktop-session-name "/")))
          (unless (file-exists-p desktop-dir)
            (make-directory desktop-dir))
          (desktop-save desktop-dir)
          (when (or manual-save (not (called-interactively-p 'any)))
            (message "Session '%s' saved." current-desktop-session-name)))
      ;; No session is loaded, prompt to create a new one (only when called interactively)
      (when (called-interactively-p 'any)
        (let ((new-session-name (read-string "Enter new session name: ")))
          (unless (string-empty-p new-session-name)
            (let ((new-desktop-dir (concat user-emacs-directory "desktop/" new-session-name "/")))
              (make-directory new-desktop-dir t)
              (setq current-desktop-session-name new-session-name)
              (desktop-save new-desktop-dir)))))))

  (defun load-desktop-session (session-name)
    "Load a desktop session by name."
    (let ((desktop-dir (concat user-emacs-directory "desktop/")))
      (setq current-desktop-session-name session-name)
      (desktop-change-dir (concat desktop-dir session-name "/"))))
      ;; Set up the autosave timer when a new session is loaded
      ;; (when desktop-autosave-timer
      ;;   (cancel-timer desktop-autosave-timer))
      ;; (setq desktop-autosave-timer (run-with-timer 0 30 'save-current-desktop-session))))

  (defun load-desktop-with-name ()
    "Load a desktop session by name, chosen from available sessions."
    (interactive)
    (when current-desktop-session-name
      ;; Save the current session before loading a new one, but only if a session is already loaded.
      (save-current-desktop-session))
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
           (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
           (session-name (completing-read "Choose desktop session: " session-dirs nil t)))
      (setq current-desktop-session-name session-name)  ; Save the session name globally
      (desktop-change-dir (concat desktop-dir session-name "/"))))
      ;; Set up the autosave timer when a new session is loaded
      ;; (when desktop-autosave-timer
      ;;   (cancel-timer desktop-autosave-timer))
      ;; (setq desktop-autosave-timer (run-with-timer 0 30 'save-current-desktop-session))))

  ;; Disable the default desktop save mode
  (desktop-save-mode 0)

  (defun delete-desktop-session ()
    "Delete a desktop session by name, chosen from available sessions."
    (interactive)
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
           (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
           (session-name (completing-read "Choose desktop session to delete: " session-dirs nil t)))
      (when (yes-or-no-p (format "Are you sure you want to delete the '%s' session? " session-name))
        (let ((session-path (concat desktop-dir session-name)))
          (if (file-directory-p session-path)
              (progn
                (delete-directory session-path t)  ; 't' for recursive delete
                (message "Deleted desktop session '%s'." session-name))
            (message "No such desktop session '%s'." session-name))))))

  (defun rename-desktop-session ()
    "Renames the currently loaded desktop session."
    (interactive)
    ;; Check if there's a session loaded.
    (if (not current-desktop-session-name)
        (message "No desktop session is currently loaded.")
      (let* ((new-name (read-string "New session name: "))
             (old-dir (concat user-emacs-directory "desktop/" current-desktop-session-name))
             (new-dir (concat user-emacs-directory "desktop/" new-name)))
        ;; Check if the new session name is empty or the session already exists.
        (if (or (string-empty-p new-name)
                (file-exists-p new-dir))
            (message "Invalid new session name or session already exists.")
          ;; Rename the directory and update the session name.
          (rename-file old-dir new-dir)
          (setq current-desktop-session-name new-name)
          (message "Session renamed to '%s'." new-name)))))

  (add-hook 'kill-emacs-hook 'save-current-desktop-session)

#+end_src

* Buffers
** Windmove

#+begin_src emacs-lisp

  (require 'windmove)

   ;;;###autoload
  (defun buf-move-up ()
   "Swap the current buffer and the buffer above the split.
   If there is no split, ie now window above the current one, an
   error is signaled."
     ;;  "Switches between the current buffer, and the buffer above the
     ;;  split, if possible."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'up))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No window above this one")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-down ()
   "Swap the current buffer and the buffer under the split.
   If there is no split, ie now window under the current one, an
   error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'down))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (or (null other-win)
 	      (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
 	  (error "No window under this one")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-left ()
   "Swap the current buffer and the buffer on the left of the split.
   If there is no split, ie now window on the left of the current
   one, an error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'left))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No left split")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-right ()
   "Swap the current buffer and the buffer on the right of the split.
   If there is no split, ie now window on the right of the current
   one, an error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'right))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No right split")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

#+end_src

** Messages buffer

#+begin_src emacs-lisp

  (defun open-messages-buffer-in-split ()
    (interactive)
    (switch-to-buffer "*Messages*"))

#+end_src

** Dired buffer

#+begin_src emacs-lisp

  (defun OpenDiredBufferInSplit ()
     "Open a Dired buffer in a vertical split on the right, showing the directory of the current buffer."
     (interactive)
     (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
       (split-window-right)
       (windmove-right)
       (dired current-dir)))

  (defun OpenDiredBufferInCurrentWindow ()
     "Open a Dired buffer in the current window, showing the directory of the current buffer."
     (interactive)
     (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
       (dired current-dir)))

#+end_src

** Cmd shell buffer

#+begin_src emacs-lisp

  (defun RunCmdShellCommand ()
    "Prompt for and run a CMD shell command."
    (interactive)
    (let ((cmd (read-shell-command "Run CMD command: ")))
      (shell-command cmd)))

#+end_src

** Shell buffer

#+begin_src emacs-lisp

  (defun my-shell-mode-hook ()
    (setq-local scroll-margin 0))

  (add-hook 'shell-mode-hook 'my-shell-mode-hook)

  (setq explicit-shell-file-name "/usr/bin/zsh")  ; your shell path here
  (setq explicit-bash-args '("--login" "-i"))

  ;; (defvar
  ;;   shell-toggle-window-configuration nil
  ;;   "Variable to store the window configuration before opening shell.")

  ;; (defvar shell-toggle-selected-window nil
  ;;   "Variable to store the selected window before opening shell.")

  ;; (defun SpawnShellSplitBelow ()
  ;;   "Open a shell in a small split below or toggle it if already open."
  ;;   (interactive)
  ;;   (if (eq major-mode 'shell-mode)
  ;;       (progn
  ;;         (when shell-toggle-window-configuration
  ;;           (set-window-configuration shell-toggle-window-configuration)
  ;;           (setq shell-toggle-window-configuration nil))
  ;;         (when shell-toggle-selected-window
  ;;           (select-window shell-toggle-selected-window)
  ;;           (setq shell-toggle-selected-window nil)))
  ;;     (setq shell-toggle-window-configuration (current-window-configuration))
  ;;     (setq shell-toggle-selected-window (selected-window))
  ;;     (split-window-below -10)
  ;;     (other-window 1)
  ;;     (open-shell-in-current-directory)))

  ;; (defun open-shell-in-current-directory ()
  ;;   "Open shell in the directory of the current buffer.
  ;; If a shell buffer for the directory already exists, switch to it."
  ;;   (interactive)
  ;;   (let* ((buffer-dir (if (buffer-file-name)
  ;;                         (file-name-directory (buffer-file-name))
  ;;                       default-directory))
  ;;         (shell-buffer-name (format "*shell: %s*" buffer-dir))
  ;;         (existing-shell-buffer (get-buffer shell-buffer-name)))
  ;;     (if existing-shell-buffer
  ;;         (switch-to-buffer existing-shell-buffer)
  ;;       (let ((default-directory buffer-dir)) ;; Ensure shell starts in the correct directory
  ;;         (shell (generate-new-buffer-name shell-buffer-name))))))

  ;; (with-eval-after-load 'evil
  ;;   (define-key evil-normal-state-map (kbd "M-s") 'SpawnShellSplitBelow))




  ;; (defvar spawn-toggle-window-configuration nil
  ;;   "Variable to store the window configuration before opening eshell or shell.")

  ;; (defvar spawn-toggle-selected-window nil
  ;;   "Variable to store the selected window before opening eshell or shell.")

  ;; (defun SpawnEshellSplitBelow ()
  ;;   "Open a shell in a small split below or toggle it if already open.
  ;; If the current buffer is a shell buffer, switch to an eshell buffer instead."
  ;;   (interactive)
  ;;   (if (eq major-mode 'shell-mode)
  ;;       (open-eshell-in-current-directory)
  ;;     (if (eq major-mode 'eshell-mode)
  ;;         (SpawnToggleOff)
  ;;       (SpawnToggleOn)
  ;;       (open-eshell-in-current-directory))))

  ;; (defun open-eshell-in-current-directory ()
  ;;   "Open eshell in the directory of the current buffer.
  ;; If an eshell buffer for the directory already exists, switch to it."
  ;;   (interactive)
  ;;   (let* ((buffer-dir (if (buffer-file-name)
  ;;                         (file-name-directory (buffer-file-name))
  ;;                       default-directory))
  ;;         (eshell-buffer-name (concat "*eshell:" buffer-dir "*"))
  ;;         (existing-eshell-buffer (get-buffer eshell-buffer-name)))
  ;;     (if existing-eshell-buffer
  ;;         (switch-to-buffer existing-eshell-buffer)
  ;;       (let ((eshell-buffer (eshell 'N)))
  ;;         (with-current-buffer eshell-buffer
  ;;           (rename-buffer eshell-buffer-name)
  ;;           (eshell/cd buffer-dir))))))

  ;; (defun SpawnShellSplitBelow ()
  ;;   "Open a shell in a small split below or toggle it if already open.
  ;; If the current buffer is an eshell buffer, switch to a shell buffer instead."
  ;;   (interactive)
  ;;   (if (eq major-mode 'eshell-mode)
  ;;       (open-shell-in-current-directory)
  ;;     (if (eq major-mode 'shell-mode)
  ;;         (SpawnToggleOff)
  ;;       (SpawnToggleOn)
  ;;       (open-shell-in-current-directory))))

  ;; (defun open-shell-in-current-directory ()
  ;;   "Open shell in the directory of the current buffer.
  ;; If a shell buffer for the directory already exists, switch to it."
  ;;   (interactive)
  ;;   (let* ((buffer-dir (if (buffer-file-name)
  ;;                         (file-name-directory (buffer-file-name))
  ;;                       default-directory))
  ;;         (shell-buffer-name (format "*shell: %s*" buffer-dir))
  ;;         (existing-shell-buffer (get-buffer shell-buffer-name)))
  ;;     (if existing-shell-buffer
  ;;         (switch-to-buffer existing-shell-buffer)
  ;;       (let ((default-directory buffer-dir)) ;; Ensure shell starts in the correct directory
  ;;         (shell (generate-new-buffer-name shell-buffer-name))))))

  ;; (defun SpawnToggleOff ()
  ;;   "Toggle off eshell or shell buffer and restore the previous window configuration."
  ;;   (when spawn-toggle-window-configuration
  ;;     (set-window-configuration spawn-toggle-window-configuration)
  ;;     (setq spawn-toggle-window-configuration nil))
  ;;   (when spawn-toggle-selected-window
  ;;     (select-window spawn-toggle-selected-window)
  ;;     (setq spawn-toggle-selected-window nil)))

  ;; (defun SpawnToggleOn ()
  ;;   "Store the current window configuration and selected window before spawning eshell or shell."
  ;;   (setq spawn-toggle-window-configuration (current-window-configuration))
  ;;   (setq spawn-toggle-selected-window (selected-window))
  ;;   (split-window-below -10)
  ;;   (other-window 1))

  ;; (with-eval-after-load 'evil
  ;;   (define-key evil-normal-state-map (kbd "M-e") 'SpawnEshellSplitBelow)
  ;;   (define-key evil-normal-state-map (kbd "M-s") 'SpawnShellSplitBelow))

#+end_src

** Eshell buffer

#+begin_src emacs-lisp

  (defvar
    eshell-toggle-window-configuration nil
    "Variable to store the window configuration before opening eshell.")

  (defvar eshell-toggle-selected-window nil
    "Variable to store the selected window before opening eshell.")

  ;; (defun SpawnEshellSplitBelow ()
  ;;   "Open a shell in a small split below or toggle it if already open."
  ;;   (interactive)
  ;;   (if (eq major-mode 'eshell-mode)
  ;;       (progn
  ;;         (when eshell-toggle-window-configuration
  ;;           (set-window-configuration eshell-toggle-window-configuration)
  ;;           (setq eshell-toggle-window-configuration nil))
  ;;         (when eshell-toggle-selected-window
  ;;           (select-window eshell-toggle-selected-window)
  ;;           (setq eshell-toggle-selected-window nil)))
  ;;     (setq eshell-toggle-window-configuration (current-window-configuration))
  ;;     (setq eshell-toggle-selected-window (selected-window))
  ;;     (split-window-below -10)
  ;;     (other-window 1)
  ;;     (open-eshell-in-current-directory)))

  (defun SpawnEshellSplitBelow ()
    "Open a shell in a small split below or toggle it if already open."
    (interactive)
    (if (eq major-mode 'eshell-mode)
        (progn
          (when eshell-toggle-window-configuration
            (set-window-configuration eshell-toggle-window-configuration)
            (setq eshell-toggle-window-configuration nil))
          (when eshell-toggle-selected-window
            (select-window eshell-toggle-selected-window)
            (setq eshell-toggle-selected-window nil)))
      (setq eshell-toggle-window-configuration (current-window-configuration))
      (setq eshell-toggle-selected-window (selected-window))
      ;; Calculate one third of the total window height
      (let ((one-third-height (/ (window-total-height) 3)))
        ;; Ensure the height is at least 1 to avoid errors
        (setq one-third-height (max one-third-height 1))
        (split-window-below (- one-third-height))
        (other-window 1)
        (open-eshell-in-current-directory))))

  (defun open-eshell-in-current-directory ()
    "Open eshell in the directory of the current buffer.
    If an eshell buffer for the directory already exists, switch to it."
    (interactive)
    (let* ((buffer-dir (if (buffer-file-name)
                           (file-name-directory (buffer-file-name))
                         default-directory))
           (eshell-buffer-name (concat "*eshell:" buffer-dir "*"))
           (existing-eshell-buffer (get-buffer eshell-buffer-name)))
      (if existing-eshell-buffer
          (switch-to-buffer existing-eshell-buffer)
        (let ((eshell-buffer (eshell 'N)))
          (with-current-buffer eshell-buffer
            (rename-buffer eshell-buffer-name)
            (eshell/cd buffer-dir))))))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "M-e") 'SpawnEshellSplitBelow))
    ;; (define-key evil-normal-state-map (kbd "M-e") 'open-eshell-in-current-directory))

  (defun kill-all-eshell-buffers ()
    "Kill all Eshell buffers."
    (interactive)
    (dolist (buffer (buffer-list))
      (when (string-match-p "^\\*eshell\\*" (buffer-name buffer))
        (kill-buffer buffer))))

#+end_src

** Transpose frame

#+begin_src emacs-lisp

  (use-package transpose-frame)

#+end_src

** Posframe

#+begin_src emacs-lisp

  (use-package vertico-posframe)

#+end_src

** Shackle

#+begin_src emacs-lisp


;;  (use-package shackle)
  ;;   :config
  ;;   (setq shackle-rules
  ;;       '(("*Async Shell Command*" :size 0.3 :align below :select nil :popup t)))
  ;; (shackle-mode 1))

#+end_src

** Popper

#+begin_src emacs-lisp

  (defun my/show-popper-echo-line ()
    "Briefly toggle popper to show the echo line."
    (interactive)
    ;; Ensure popper-mode and popper-echo-mode are active
    (when (and popper-mode popper-echo-mode)
      ;; Toggle a popper window and immediately toggle it back
      (popper-toggle-latest)
      (popper-toggle-latest)))

  (use-package popper
    :bind (("M-f"   . popper-toggle)
           ("M-`" . my/show-popper-echo-line))
           ;; ("M-~"   . popper-cycle))
    :init
    (setq popper-window-height 0.33)
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            "*Flymake diagnostics.*"
            "\\*compilation\\*"
            "\\*eshell\\*.*"
            ;; "\\*eshell:.*"
            ;; "\\*Warnings\\*"
            ;; "\\*xref\\*"
            ;; "\\*Backtrace\\*"
            ;; "\\*eldoc\\*"
            ;; "\\*Ement Notifications\\*"
            ;; "Output\\*$"
            ;; "\\*Dtache Shell Command\\*"
            ;; "\\*mu4e-update\\*"
            help-mode
            compilation-mode))
    (popper-mode +1)
    (popper-echo-mode +1))
  ;;   (setq display-buffer-alist
  ;;         `(("\\*Async Shell Command\\*.*"
  ;;            (display-buffer-reuse-window display-buffer-at-bottom)
  ;;            (window-height . 0.33))
  ;;           ("\\*Messages\\*"
  ;;            (display-buffer-reuse-window display-buffer-at-bottom)
  ;;            (window-height . 0.33)))))

  (defun popper-diagnostics ()
    "Popper window specifically for Flymake diagnostics buffer."
    (interactive)
    (if (string-match-p "\\*.*Flymake diagnostics.*\\*" (buffer-name))
        (popper-toggle)
      (flymake-show-buffer-diagnostics)))

  ;; (defun fix-cycle ()
  ;;   (interactive)
  ;;   (popper-cycle 1))

  ;; (defun fix-cycle-backwards ()
  ;;   (interactive)
  ;;   (popper-cycle-backwards -1))

  (with-eval-after-load 'evil
    ;;   (define-key evil-normal-state-map (kbd "M-k") 'fix-cycle-backwards)
    ;;   (define-key evil-normal-state-map (kbd "M-j") 'fix-cycle)
    (define-key evil-normal-state-map (kbd "M-t") 'popper-diagnostics))

#+end_src

* LANGUAGE SUPPORT

#+begin_src emacs-lisp

  (use-package raku-mode)
  (use-package go-mode)
  (use-package lua-mode)
  (use-package terraform-mode)
  (use-package dockerfile-mode)
  (use-package haskell-mode)

  (when (require 'dockerfile-mode nil 'noerror)
    ;; Add a hook to automatically use dockerfile-mode for Dockerfiles
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))

  ;; (use-package markdown-mode
  ;;   :ensure t
  ;;   :mode ("README\\.md\\'" . gfm-mode)
  ;;   :init (setq markdown-command "multimarkdown")
  ;;   :bind (:map markdown-mode-map
  ;;         ("C-c C-e" . markdown-do)))


  (add-to-list 'auto-mode-alist '("\\.hs\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.hls\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.cabal\\'" . haskell-cabal-mode))

#+end_src

** Lsp-bridge

#+begin_src emacs-lisp


  ;; (use-package lsp-bridge
  ;;   :elpaca '(lsp-bridge :type git :host github :repo "manateelazycat/lsp-bridge"
  ;;             :files (:defaults "*.el" "*.py" "acm" "core" "langserver" "multiserver" "resources")
  ;;             :build (:not compile))
  ;;   :init
  ;;   (global-lsp-bridge-mode)
  ;;   :config
  ;;   (setq lsp-bridge-complete-manually t)
  ;;   (setq lsp-bridge-enable-log t)
  ;;   (setq lsp-bridge-enable-auto-format-code t)
  ;;   (global-set-key (kbd "C-x C-o") 'lsp-bridge-popup-complete-menu))

#+end_src

** Flycheck

#+begin_src emacs-lisp

  ;; (use-package flycheck
  ;;   :init
  ;;   (add-hook 'after-init-hook #'global-flycheck-mode))

  ;; (use-package flymake-flycheck
  ;;   :after flymake
  ;;   ;; :init
  ;;   ;; (setopt flycheck-disabled-checkers '(python-mypy flymake-flycheck:python-mypy))
  ;;   :config
  ;;   (add-hook 'flymake-mode-hook 'flymake-flycheck-auto))

#+end_src

** Lsp Mode

#+begin_src emacs-lisp

  ;;(use-package flymake
    ;; :init
   ;; (flymake-mode))
   ;; ;; :hook (go-mode . flymake-mode))

  (use-package lsp-mode
    :commands lsp
    :config
    (lsp-register-client
    (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- gopls")
                      :major-modes '(go-mode)
                      :server-id 'gopls))
    (add-hook 'go-mode-hook #'lsp)
    (setq lsp-idle-delay 0.1)
    (setq lsp-diagnostics-provider :flymake)
    (setq lsp-headerline-breadcrumb-enable nil)
    (setq gc-cons-threshold (* 100 1024 1024)
          read-process-output-max (* 1024 1024))
    ;; Small speedups
    (setopt lsp-log-max 0)
    (setopt lsp-log-io nil)
    (setq lsp-enable-symbol-highlighting nil))

  ;; (use-package lsp-ui
  ;;   :after lsp-mode
  ;;   :config
  ;;   (setq lsp-ui-sideline-enable t
  ;;         lsp-ui-sideline-show-diagnostics t
  ;;         lsp-ui-sideline-show-hover t
  ;;         lsp-ui-sideline-show-code-actions t
  ;;         lsp-ui-doc-enable t
  ;;         lsp-ui-doc-position 'top
  ;;         lsp-ui-doc-include-signature t
  ;;         lsp-ui-peek-enable t
  ;;         lsp-ui-imenu-enable t)
  ;;   (add-hook 'lsp-mode-hook #'lsp-ui-mode))

  ;; (use-package lsp-mode
  ;; ;; :commands (lsp lsp-deferred)
  ;; :init
  ;; ;; (setenv "LSP_USE_PLISTS" "1")
  ;; ;; Increase the amount of data emacs reads from processes
  ;; ;; (setq read-process-output-max (* 3 1024 1024))
  ;; ;; (setq lsp-clients-clangd-args '("--header-insertion-decorators=0"
  ;; ;;                                 "--clang-tidy"
  ;; ;;                                 "--enable-config"))
  ;; ;; Small speedups
  ;; ;; (setopt lsp-log-max 0)
  ;; ;; (setopt lsp-log-io nil)
  ;; ;; General lsp-mode settings
  ;; ;; (setq ;; lsp-completion-provider :none
  ;;       ;; lsp-enable-snippet t
  ;;       ;; lsp-enable-on-type-formatting nil
  ;;       ;; lsp-enable-indentation nil
  ;;       ;; lsp-diagnostics-provider :flymake
  ;;       ;; lsp-keymap-prefix "C-x L"
  ;;       ;; lsp-eldoc-render-all t)
  ;; ;; to enable the lenses
  ;; ;; (add-hook 'lsp-mode-hook #'lsp-lens-mode)
  ;; ;; (add-hook 'lsp-completion-mode-hook
  ;; ;;           (lambda ()
  ;; ;;             (setf (alist-get 'lsp-capf completion-category-defaults)
  ;; ;;                   '((styles . (orderless))))))

  ;; :config
  ;; (lsp-register-client
  ;; (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- gopls")
  ;;                 :major-modes '(go-mode)
  ;;                 :server-id 'gopls))

  ;; (use-package lsp-ui
  ;;   :after lsp
  ;;   :init
  ;;   (setq lsp-ui-sideline-show-code-actions t)
  ;;   (setq lsp-ui-sideline-show-diagnostics t))
  ;; )

  ;; (use-package lsp-ui
  ;;   :after lsp-mode
  ;;   :init
  ;;   (setq lsp-ui-sideline-show-code-actions t)
  ;;   (setq lsp-ui-sideline-show-diagnostics t))
  ;;   ;; :custom
  ;;   ;; (lsp-ui-doc-position 'bottom) ;; Set the position of the lsp-ui-doc to bottom
  ;;   ;; (lsp-ui-doc-alignment 'window) ;; Align the doc to the window
  ;;   :hook (lsp-mode . lsp-ui-mode))

  ;; ;; (defun my/lsp-ui-doc-hide ()
  ;; ;;   (unless (eq this-command 'lsp-ui-doc-focus-frame)
  ;; ;;     (lsp-ui-doc-hide)))

  ;; (add-hook 'pre-command-hook 'my/lsp-ui-doc-hide)

  ;; (use-package lsp-haskell
  ;;   :ensure t
  ;;   :init
  ;;   (setq lsp-haskell-server-path "haskell-language-server-wrapper")
  ;;   :after lsp
  ;;   :config
  ;;   ;; (setq lsp-haskell-check-parents 'AlwaysCheck)
  ;;   )

  ;;   (use-package corfu
  ;;       :ensure t
  ;;       :bind (("C-." . corfu-next)
  ;;              ("C-," . corfu-prev)))

#+end_src

** Eglot

#+begin_src emacs-lisp

  ;; (use-package eglot-booster
  ;; :elpaca (eglot-booster :host github :repo "jdtsmith/eglot-booster")
  ;; :after eglot
  ;; :config (eglot-booster-mode))

#+end_src

* Org Mode

** General

#+begin_src emacs-lisp

  ;; (setq org-startup-folded t) 
  ;; (setq org-emphasis-alist
  ;;       ;; '(("*" bold)
  ;;         '(("/" italic)))
  ;;         ;; ("_" underline)
  ;;         ;; ("=" org-verbatim verbatim)
  ;;         ;; ("~" org-code verbatim)
  ;;         ;; ("+" org-strike-through t)))
  ;;   (define-prefix-command 'my-prefix-map)

  (defun todo ()
    "Open the todo_list.org file located in the ~/.secret_dotfiles/org directory."
    (interactive)
    (find-file (expand-file-name "~/.secret_dotfiles/org/todo_list.org")))

  (defun org-insert-top-level-heading ()
    "Insert a new top-level heading with two empty lines before it."
    (interactive)
    (end-of-line)
    (insert "\n\n\n* ")
    (end-of-line))

  (define-key org-mode-map (kbd "M-o M-h") 'org-insert-top-level-heading)

#+end_src

** Org download

#+begin_src emacs-lisp

  (use-package org-download
    :init
    (setq org-download-image-dir "~/.secret_dotfiles/org/images")
    :config
    (add-hook 'org-mode-hook 'org-download-enable)
    (add-hook 'org-mode-hook
              (lambda ()
                (org-display-inline-images))))

#+end_src

** Org modern

#+begin_src emacs-lisp

  ;; (use-package org-modern
  ;;   :config
  ;;   (with-eval-after-load 'org (global-org-modern-mode)))
  
#+end_src

** Drill

#+begin_src emacs-lisp

  (use-package org-drill
    :config
    (setq org-drill-maximum-items-per-session 20))

#+end_src

** Agenda

#+begin_src emacs-lisp

  (setq org-agenda-files
        '("~/.secret_dotfiles/org/todo_list.org"))

#+end_src

** Org-roam

#+begin_src emacs-lisp
#+end_src

** Templates

#+begin_src emacs-lisp

  (require 'org-tempo)
  (add-to-list 'org-structure-template-alist '("sb" . "src bash-ts"))
  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sr" . "src raku"))
  (add-to-list 'org-structure-template-alist '("sf" . "src fundamental"))
  (add-to-list 'org-structure-template-alist '("st" . "src text"))
  (add-to-list 'org-structure-template-alist '("ss" . "src sql"))
  (add-to-list 'org-structure-template-alist '("sg" . "src go-ts"))

  (add-to-list 'org-structure-template-alist
             '("t" . "src TODO\n\n* TODO \n\n?"))

#+end_src

** Visuals

#+begin_src emacs-lisp

  (setq org-hide-emphasis-markers t)

  (defun toggle-org-emphasis-markers ()
    "Toggle the visibility of Org emphasis markers."
    (interactive)
    (setq org-hide-emphasis-markers (not org-hide-emphasis-markers))
    (org-mode-restart))

  (define-key org-mode-map (kbd "M-o M-t") 'toggle-org-emphasis-markers)

  (add-hook 'org-mode-hook 'prettify-symbols-mode)
    (defun my-org-prettify-symbols ()
    (push '("#+begin_src" . ">") prettify-symbols-alist)
      (push '("#+end_src" . ">") prettify-symbols-alist))

  (eval-after-load 'org
    '(add-hook 'org-mode-hook 'my-org-prettify-symbols))

#+end_src

*** Bullets

#+begin_src emacs-lisp

  (add-hook 'org-mode-hook 'org-indent-mode)
  (use-package org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))

#+end_src

** Source block tag expansion cheat sheet

   | Name | Description |
   |------+-------------|
   | se   | lisp        |
   |------+-------------|
   |      |             |


** Enabling Table of Contents

#+begin_src emacs-lisp

  (use-package toc-org
      :commands toc-org-enable
      :init (add-hook 'org-mode-hook 'toc-org-enable))

#+end_src

** Custom key bindings

#+begin_src emacs-lisp

  (defun org-insert-row-with-floor ()
    "Insert a new row with a 'floor' above in an Org mode table."
    (interactive)
    (org-table-next-field)
    (beginning-of-line)
    (insert "|-")
    (org-table-align)
    (org-return))

  (define-key org-mode-map (kbd "C-c f") 'org-insert-row-with-floor)

  (defun FormatToThreshold (char-threshold)
    "Formats the selected text to not exceed CHAR-THRESHOLD characters per line."
    (interactive "nCharacter Threshold: ")
    (let ((start (region-beginning))
          (end (region-end))
          all-text words formatted-text)
      (save-excursion
        (setq all-text (buffer-substring start end))
        (setq words (split-string all-text))
        (let ((current-line "")
              (current-length 0))
          (dolist (word words)
            (if (> (+ current-length (length word) 1) char-threshold)
                (progn
                  (setq formatted-text (concat formatted-text current-line "\n"))
                  (setq current-line word)
                  (setq current-length (length word)))
              (progn
                (setq current-line (if (string= "" current-line)
                                      word
                                    (concat current-line " " word)))
                (setq current-length (+ current-length (length word) 1)))))
          (setq formatted-text (concat formatted-text current-line)))
        (delete-region start end)
        (goto-char start)
        (insert formatted-text))))

  (defun my/evil-org-open-below (count)
    "Open a new line below the current one and insert a new Org list item if on a list item, otherwise just open a new line."
    (interactive "p")
    (if (org-in-item-p)
        (progn
          (end-of-line)
          (org-insert-item))
      (evil-open-below count)))

  (with-eval-after-load 'evil
    (evil-define-key 'normal org-mode-map
      "o" 'my/evil-org-open-below))

#+end_src

* Keybindings

#+begin_src emacs-lisp

  (global-unset-key (kbd "M-;"))

  (global-unset-key (kbd "C-s"))
  (global-unset-key (kbd "M-TAB"))
  (global-set-key (kbd "C-s C-l") 'load-desktop-with-name)
  (global-set-key (kbd "C-s C-s") 'swiper-isearch)
  (global-set-key (kbd "C-s C-q") 'my-sql-connect-with-buffer)
  (global-set-key (kbd "C-s C-b") 'sql-send-buffer)

  (global-unset-key (kbd "C-t"))
  (global-set-key (kbd "C-t C-s") 'jinx-mode)

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "C-t") nil)
    ;; Define the key for normal state globally
    (evil-define-key 'normal 'global (kbd "M-^") 'projectile-run-async-shell-command-in-root))

  (with-eval-after-load 'org
    ;; Override the keybinding in org-mode specifically
    (define-key org-mode-map (kbd "M-^") 'projectile-run-async-shell-command-in-root))
  ;;   (define-key evil-normal-state-map (kbd "M-t s") 'flyspell-mode))

  (global-unset-key (kbd "C-<tab>"))
  (global-set-key (kbd "<C-tab>") 'previous-buffer)

#+end_src

* Custom functions

#+begin_src emacs-lisp

  (defun print-commands-starting-with (input)
  "Print all Emacs commands starting with INPUT to a scratch buffer."
  (interactive "sInput: ")
  (let ((command-list (apropos-internal input 'commandp))
        (output-buffer (get-buffer-create "*Commands*")))
    (with-current-buffer output-buffer
      (erase-buffer)
      (insert (format "Commands starting with '%s':\n\n" input))
      (dolist (command command-list)
        (insert (format "%s\n" command)))
      (goto-char (point-min)))
    (display-buffer output-buffer)))

  ;; Increment
  (defun my/increment-number-at-point (&optional increment)
    "Increment number at point like vim's C-a"
    (interactive "p")
    (my/change-number-at-point '+ (or increment 2)))

  ;; Decrement
  (defun my/decrement-number-at-point (&optional increment)
    "Decrement number at point like vim's C-x"
    (interactive "p")
    (my/change-number-at-point '- (or increment 1)))

  ;; (defun Cp ()
  ;; "Copy the full path of the current buffer's file to the clipboard."
  ;; (interactive)
  ;; (if-let* ((filename (buffer-file-name)))
  ;;     (progn
  ;;       (kill-new filename)
  ;;       (message "Copied buffer file name '%s' to the clipboard." filename))
  ;;   (message "Current buffer is not associated with a file.")))

  (defun Cp ()
    "Copy the full path of the current buffer's file to the clipboard (or appropriate path)."
    (interactive)
    (let ((path-to-copy nil))
      (cond
      ((eq major-mode 'dired-mode)    ; Dired buffer
        (setq path-to-copy (if (dired-get-file-for-visit)
                              (expand-file-name (dired-get-file-for-visit))
                            (expand-file-name default-directory))))
      ((eq major-mode 'eshell-mode)   ; Eshell buffer
        (setq path-to-copy (eshell/pwd)))
      (t                              ; Default: Regular File buffer
        (setq path-to-copy (buffer-file-name))))
      (if path-to-copy
          (progn
            (kill-new path-to-copy)
            (message "Copied path '%s' to the clipboard." path-to-copy))
        (message "Current buffer has no associated path to copy."))))

  (defun sway ()
    "Open sway config file."
    (interactive)
    (find-file (expand-file-name "~/.dotfiles/sway/config")))

  (defun date ()
    "Display the current date and time in the minibuffer using the shell's 'date' command."
    (interactive)
    (let ((date-output (shell-command-to-string "date")))
      (message (string-trim date-output))))

  (defun off ()
    "Shutdown the system."
    (interactive)
    (call-process "poweroff"))

  (defun reboot ()
    "Reboot the system."
    (interactive)
    (call-process "reboot"))

  (defun notes ()
    "Open org notes directory."
    (interactive)
    (find-file (expand-file-name "~/.secret_dotfiles/org")))

  (defun drill ()
    "Open org notes directory."
    (interactive)
    (find-file (expand-file-name "~/.secret_dotfiles/org/drill")))

  (defun cards ()
    "Open org notes directory."
    (interactive)
    (find-file (expand-file-name "~/.secret_dotfiles/org/drill/general.org")))

  (defun nvm ()
    "Open org notes directory."
    (interactive)
    (find-file (expand-file-name "~/.dotfiles/nvim/lua/user/")))

#+end_src
