#+TITLE: Wurfkreuz's GNU Emacs Config
#+AUTHOR: Alex Gud
#+DESCRIPTION: Empty.
#+STARTUP: showeverything ; Wont apply folding
#+OPTIONS: toc:3 ; Table of contents include 3 header levels down

* TABLE OF CONTENTS :toc:
- [[#general-emacs-setting][GENERAL EMACS SETTING]]
  - [[#visuals][Visuals]]
  - [[#system][System]]
  - [[#cursor][Cursor]]
  - [[#find-file][Find-file]]
  - [[#theme-and-font][Theme and Font]]
  - [[#general][General]]
  - [[#avy][Avy]]
  - [[#async][Async]]
  - [[#transient][Transient]]
  - [[#search][Search]]
  - [[#xterm-color][Xterm-color]]
  - [[#jinx][Jinx]]
  - [[#completion][Completion]]
  - [[#acess-to-env-variables][Acess to ENV variables]]
  - [[#treesitter][Treesitter]]
  - [[#sudo-edit][Sudo Edit]]
  - [[#paredit][Paredit]]
  - [[#hyperbole][Hyperbole]]
  - [[#zoxide][Zoxide]]
  - [[#cider][Cider]]
  - [[#projectile][Projectile]]
  - [[#mentor][Mentor]]
  - [[#wgrep][Wgrep]]
  - [[#embark][Embark]]
  - [[#ivycounsel][Ivy/Counsel]]
  - [[#prescient][Prescient]]
  - [[#fzf][Fzf]]
  - [[#hydra][Hydra]]
- [[#dired][Dired]]
  - [[#dired-keybindings][Dired keybindings]]
- [[#tramp][Tramp]]
- [[#shells-and-terminals][Shells and Terminals]]
  - [[#eshell][Eshell]]
  - [[#async-shell][Async shell]]
  - [[#eat][Eat]]
  - [[#cmd][Cmd]]
  - [[#cursor-changer][Cursor changer]]
- [[#database][Database]]
- [[#sessions][Sessions]]
- [[#buffers][Buffers]]
  - [[#dired-buffer][Dired buffer]]
  - [[#shell-buffer][Shell buffer]]
  - [[#eshell-buffer][Eshell buffer]]
  - [[#transpose-frame][Transpose frame]]
  - [[#posframe][Posframe]]
  - [[#popper][Popper]]
- [[#language-support][LANGUAGE SUPPORT]]
  - [[#flymake][Flymake]]
  - [[#modes][Modes]]
  - [[#flycheck][Flycheck]]
  - [[#lsp-mode][Lsp Mode]]
  - [[#eglot][Eglot]]
- [[#org-mode][Org Mode]]
  - [[#general-1][General]]
  - [[#org-download][Org download]]
  - [[#drill][Drill]]
  - [[#agenda][Agenda]]
  - [[#org-roam][Org-roam]]
  - [[#templates][Templates]]
  - [[#visuals-1][Visuals]]
  - [[#source-block-tag-expansion-cheat-sheet][Source block tag expansion cheat sheet]]
  - [[#enabling-table-of-contents][Enabling Table of Contents]]
  - [[#custom-key-bindings][Custom key bindings]]
- [[#keybindings][Keybindings]]
- [[#custom-functions][Custom functions]]

* GENERAL EMACS SETTING
** Visuals

#+begin_src emacs-lisp

  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (setq inhibit-startup-screen t)
  (setq display-line-numbers 'visual
        display-line-numbers-type 'relative)
  (add-hook 'conf-mode-hook 'display-line-numbers-mode)
  (add-hook 'conf-space-mode-hook 'display-line-numbers-mode)
  (global-display-line-numbers-mode 1)

  (defun my-mode-line-major-mode ()
    "Returns a clean name of the current major mode."
    (let ((mode (format "%s" major-mode)))
      (replace-regexp-in-string "-mode$" "" mode)))

  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  (:eval (if (buffer-file-name)
                             (abbreviate-file-name (buffer-file-name))  ; Show abbreviated file path
                           "%b"))  ; Show buffer name if not a file buffer
                  " "
                  (:eval (my-mode-line-major-mode))  ; Custom major mode display
                  (:eval (propertize " " 'display '(space :align-to (- right 12))))
                  (vc-mode vc-mode)))  ; Git branch information

  ;; (defun renz/display-ansi-colors ()
  ;;   "Render colors in a buffer that contains ASCII color escape codes."
  ;;   (interactive)
  ;;   (require 'ansi-color)
  ;;   (let ((inhibit-read-only t))
  ;;     (ansi-color-apply-on-region (point-min) (point-max))))

  ;; (add-hook 'compilation-filter-hook #'renz/display-ansi-colors)

  ;; (add-hook 'eshell-preoutput-filter-functions  #'ansi-color-apply)

#+end_src

*** Tabs

#+begin_src emacs-lisp

  (setq tab-bar-close-button-show nil
        tab-bar-new-button-show nil)

  (defun my-tab-name-format-function (tab i)
    (defface my-active-tab-face
      '((t :background "#2e2c3d" :foreground "#e0def4"))  ;; #373c42 - previous background color
      ;; '((t :background "#3c3836" :foreground "#fbf1c7"))  ;; gruvbox-dark hard
      ;; '((t :background "#282c34" :foreground "#bbc2cf"))
      "Face for the active tab.")
    (defface my-inactive-tab-face
        '((t :background "#1d1f21" :foreground "#6e6a86")) ;; #21242b - previous background color
      ;; '((t :background "#1d2021" :foreground "#a89984"))
      ;; '((t :background "#21242b" :foreground "#83898d"))
      "Face for the inactive tab.")
    (let ((current-p (eq (car tab) 'current-tab)))
      (if current-p
          (propertize (format "%d %s" i (alist-get 'name (cdr tab))) 'face 'my-active-tab-face)
        (propertize (format "%d %s" i (alist-get 'name (cdr tab))) 'face 'my-inactive-tab-face))))

  (setq tab-bar-tab-name-format-function #'my-tab-name-format-function)

  (dotimes (i 9)
    (let ((n (1+ i)))  ; Tab numbers start from 1
      (global-set-key (kbd (format "M-%d" n))
                      `(lambda () (interactive) (tab-bar-select-tab ,n)))))

    #+end_src

** System

#+begin_src emacs-lisp

  ;; (server-start)
  (global-set-key (kbd "C-x u") 'windmove-up)
  (setq evil-want-keybinding nil)

  (setq vc-follow-symlinks t)

  (setq dired-recursive-deletes 'always)

  (setq desktop-load-locked-desktop t)
  (setq backup-inhibited t)

  (add-hook 'prog-mode-hook (show-paren-mode t))

  ;; Auto pairing
  (add-hook 'prog-mode-hook (electric-pair-mode t))
  ;; Don't pair '<'
  (setq electric-pair-inhibit-predicate
        `(lambda (c)
          (if (char-equal c ?\<) t (,electric-pair-inhibit-predicate c))))

  ;; Break lines after a certain length
  (auto-fill-mode 1)
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'auto-fill-mode)

  (setq python-shell-interpreter "/usr/bin/python3")

  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; Autoinsertion on the search buffer
  (setq ivy-initial-inputs-alist nil)
  ;; (setq ivy-initial-inputs-alist ;; If you want there are situations where you would like to have it enabled, try this code.
  ;;     '((counsel-M-x . "")
  ;;       (t . "^")))

  ;; (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (setq-default indent-tabs-mode nil)
  (savehist-mode 1)

  ;; Executable on save if starts with '#!'
  (add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

  (setq undo-tree-auto-save-history t)
  (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo-tree-history"))))
  (make-directory (concat user-emacs-directory "auto-saves") t)
  (setq auto-save-file-name-transforms
        `((".*" ,(concat user-emacs-directory "auto-saves/") t)))
  (make-directory (concat user-emacs-directory "lock-files") t)
  (setq lock-file-name-transforms
        `((".*" ,(concat user-emacs-directory "lock-files/") t)))
  (setq desktop-dirname (concat user-emacs-directory "desktop/"))
  (make-directory (concat user-emacs-directory "backups") t)
  (setq backup-directory-alist
        `((".*" . ,(concat user-emacs-directory "backups/"))))

  (defun my-disable-auto-save-for-scratch ()
  (when (string= (buffer-name) "*scratch*")
    (auto-save-mode -1)))

  (add-hook 'lisp-interaction-mode-hook 'my-disable-auto-save-for-scratch)


  ;; Save sessions
  (unless (file-exists-p desktop-dirname)
    (make-directory desktop-dirname))
  (desktop-save-mode 1)
  (setq desktop-save 't)
  (setq desktop-path (list desktop-dirname))
  (setq desktop-auto-save-timeout 30)
  (setq desktop-auto-save-timeout nil)

  (setq auto-save-interval 1)  ; Auto-save every 1 second
  (setq auto-save-timeout 10)  ; Auto-save after 10 seconds of idle time
  (setq auto-save-no-message t)

  (auto-save-mode 1)

  (setq save-place-file (concat user-emacs-directory "saveplace/places"))

  ;; Save cursor position
  (unless (file-exists-p (concat user-emacs-directory "saveplace/"))
    (make-directory (concat user-emacs-directory "saveplace/")))
  (save-place-mode 1)

  (if (version< emacs-version "29.0")
      (pixel-scroll-mode)
    (pixel-scroll-precision-mode 1)
    (setq pixel-scroll-precision-large-scroll-height 35.0))

  (scroll-bar-mode -1)
  (setq-default display-line-numbers-width 3)
  (setq-default scroll-margin 8)
  (setq use-dialog-box nil)
  (set-fringe-mode 0)
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (setq global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode 1)

  (setq-default truncate-lines t)

  (setenv "PATH" (concat "/home/wurfkreuz/.ghcup/bin:" (getenv "PATH")))

  (setq scroll-conservatively 101)
  (setq scroll-margin 5)
  (setq scroll-step 1)

  (require 'midnight)
  (midnight-delay-set 'midnight-delay "22:00")

#+end_src

** Cursor

#+begin_src emacs-lisp

  (blink-cursor-mode 0)
  (setq show-paren-delay 0)
  (show-paren-mode 1)

#+end_src

** Find-file

#+begin_src emacs-lisp

  (defun find-file-check-dir (filename &optional wildcards)
    "Edit file FILENAME.
     Switch to a buffer visiting file FILENAME,
     creating one if none already exists.
     If the directory path does not exist, create it."
     (interactive
      (find-file-read-args "Find file: " nil))
     (let ((dir (file-name-directory filename)))
       (when (not (file-exists-p dir))
        (make-directory dir t)))
     (find-file filename wildcards))
     #+end_src

 ** Evil Mode

#+begin_src emacs-lisp

  (use-package undo-tree
    :config
    (global-undo-tree-mode))

  (use-package evil
    :init
    (setq evil-want-C-u-scroll t
          evil-want-C-i-jump nil
          evil-want-integration t
          evil-want-minibuffer t
          evil-undo-system 'undo-tree)
    :config
    (evil-mode 1)
    (evil-set-initial-state 'custom-theme-choose-mode 'normal)
    (define-key evil-normal-state-map (kbd "/") 'avy-goto-char-2-all-windows)
    (define-key evil-visual-state-map (kbd "/") 'avy-goto-char-2-all-windows)
    (define-key evil-motion-state-map (kbd "/") 'avy-goto-char-2-all-windows)
    (define-key evil-normal-state-map (kbd "C-n") 'next-line)
    (define-key evil-normal-state-map (kbd "C-p") 'previous-line)
    (define-key evil-insert-state-map (kbd "C-n") 'next-line)
    (define-key evil-insert-state-map (kbd "C-p") 'previous-line)
    (setq evil-shift-width 2))

  (add-hook 'term-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'eat-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'eshell-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'wdired-mode-hook (lambda () (undo-tree-mode 1)))


  (setq evil-undo-system 'undo-tree)

  (use-package evil-surround
    :config
    (global-evil-surround-mode 1)
    ;; Add custom surround pairs
    (setq-default evil-surround-pairs-alist
                  (append evil-surround-pairs-alist
                          '((?/ . ("/" . "/"))
                            (?~ . ("~" . "~"))
                            (?* . ("*" . "*"))
                            (?= . ("=" . "="))
                            (?+ . ("+" . "+"))))))

  (use-package evil-commentary
    :config
    (evil-commentary-mode))

  (use-package evil-org
    :after org
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme)))
    )

  (use-package evil-collection
    :after evil
    :init ;;    (setq evil-want-keybinding nil)
    :config
    (setq evil-collection-mode-list '(dashboard eshell dired wdired ibuffer org emacs-eat term ansi lsp-ui-imenu elpaca minibuffer))
    (evil-collection-init))

  (add-hook 'text-mode-hook 'display-line-numbers-mode)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  (defun my-evil-yank-to-end-of-line ()
    "Yank text from the current point to the end of the line."
    (interactive)
    (evil-yank (point) (line-end-position)))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "Y") 'my-evil-yank-to-end-of-line))

  ;; (define-key evil-insert-state-map (kbd "<backspace>") 'evil-delete-backward-char)

  (defun my-evil-insert-state-minibuffer-setup ()
    (define-key evil-insert-state-local-map (kbd "<backspace>") 'ivy-backward-delete-char)
    (define-key evil-insert-state-local-map (kbd "TAB") 'ivy-partial-or-done))

  (add-hook 'minibuffer-setup-hook 'my-evil-insert-state-minibuffer-setup)

  (evil-global-set-key 'insert (kbd "C-l") 'forward-char)
  (evil-global-set-key 'insert (kbd "C-h") 'backward-char)

  ;; (use-package symex
  ;;   :config
  ;;   (symex-initialize)
  ;;   (global-set-key (kbd "C-;") 'symex-mode-interface))  ; or whatever keybinding you like

#+end_src

*** Custom keybindings

#+begin_src emacs-lisp

  (with-eval-after-load 'evil
    (define-key evil-insert-state-map (kbd "C-S-v") 'yank)
    (define-key evil-visual-state-map (kbd "{") 'evil-backward-paragraph)
    (define-key evil-visual-state-map (kbd "}") 'evil-forward-paragraph)
    (define-key evil-insert-state-map (kbd "M-w") 'evil-forward-word-begin)
    (define-key evil-insert-state-map (kbd "M-b") 'evil-backward-word-begin)
    (define-key evil-insert-state-map (kbd "M-W") 'evil-forward-WORD-begin)
    (define-key evil-insert-state-map (kbd "M-B") 'evil-backward-WORD-begin)

    (define-key evil-normal-state-map (kbd "gq") 'FormatToThreshold)
    (define-key evil-visual-state-map (kbd "gq") 'FormatToThreshold))

  (defun my-move-beginning-of-line ()
    "Move point to the first non-whitespace character of the line and enter insert mode."
    (interactive)
    (evil-first-non-blank)
    (evil-insert-state))

  (defun my-move-end-of-line ()
    "Move point to the very end of the line and enter insert mode."
    (interactive)
    (evil-end-of-line)
    (evil-insert-state)
    (unless (eolp)
      (evil-append-line 1)))

  (with-eval-after-load 'evil
    (define-key evil-insert-state-map (kbd "M-i") 'my-move-beginning-of-line)
    (define-key evil-insert-state-map (kbd "M-a") 'my-move-end-of-line))

#+end_src

** Theme and Font

#+begin_src emacs-lisp

  ;; (require 'color)
  ;;  (hl-line-mode 1)

  (add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))(put 'eval 'safe-local-variable #'identity)
  (load-theme 'rose-pine t)

  ;; (use-package gruvbox-theme
  ;;   :config
  ;;   (load-theme 'gruvbox-dark-hard t))

  ;; (use-package doom-themes
  ;;   :ensure t
  ;;   :config
  ;;   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
  ;;         doom-themes-enable-italic nil) ; if nil, italics is universally disabled
  ;;   (load-theme 'doom-one t)
  ;;   ;Corrects (and improves) org-mode's native fontifcation.
  ;;   (doom-themes-org-config))


  (when (member "NotoSansM Nerd Font Mono" (font-family-list))
    (set-face-attribute 'default nil :font "NotoSansM Nerd Font Mono-12:weight=medium")

    ;; Set a different font for italics
    (set-face-attribute 'italic nil
                        :family "NotoSans Nerd Font"
                        :slant 'italic
                        :weight 'normal
                        :height 130)

    (add-hook 'org-mode-hook
              (lambda ()
                (set-face-attribute 'org-verbatim nil
                                    ;; :family "NotoSerifNerdFontPropo-CondensedExtraLight"
                                    :family "NotoSerifNerdFont"
                                    :height 130
                                    ;; :foreground "#8bc34a"  ; Adjust the color as desired
                                    :weight 'normal))))

#+end_src

*** Icons

#+begin_src emacs-lisp

  (use-package all-the-icons
    :ensure t
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))

#+end_src

** General

#+begin_src emacs-lisp

  (use-package general
    :config
    (general-evil-setup)
    (general-create-definer w/leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC" ;; set leader
      :global-prefix "M-SPC") ;; access leader in insert mode

    (w/leader-keys

      ;; Fuzzy finder
      "fb" '(counsel-switch-buffer :wk "Choose and switch to an active buffer")
      "fe" '(OpenDiredBufferInCurrentWindow :wk "Open a full screen dired buffer in a current window")
      "ff" '(projectile-find-file :wk "Find file fuzzy finder with a git directory as an anchor")
      "fd" '(projectile-find-dir :wk "Find file modified")
      "fh" '(counsel-fzf-home :wk "counsel-fzf from home")
      "fr" '(counsel-fzf-root :wk "counsel-fzf from root")
      "fc" '(counsel-fzf-current :wk "counsel-fzf from root")

      ;; Session management
      "ss" '(save-current-desktop-session :wk "Save the current desktop session into its corresponding directory")
      "sd" '(delete-desktop-session :wk "Delete selected session")
      "sl" '(load-desktop-with-name :wk "Load a desktop session by name, chosen from available sessions")
      "sr" '(rename-desktop-session :wk "Rename a desktop session")

      ;; Org
      "ot" '(todo :wk "Opens the org todo file")

      ;; Paredit
      "pfs" '(paredit-forward-slurp-sexp)
      
      ;; Hyperbole
      "he" '(hkey-either :wk "Opens the org todo file")
      
      ;; Tab management
      "tn" '(tab-bar-new-tab :wk "Create a new tab")
      "tx" '(tab-bar-close-tab :wk "Close a tab")
      "tr" '(tab-bar-rename-tab :wk "Rename a tab")

      ;; Windows
      "w"  'hydra-window-size/body
      "bc" '(kill-buffer :wk "Close selecetd buffer")
      "bx" '(kill-current-buffer :wk "Close selecetd buffer")

      ;; Popper
      "pe" '(popper-toggle-type :wk "Expand/contract a buffer")

      "xx" '(kill-buffer-and-window :wk "Close buffer with its window")

      "ch" '(my-hoogle-search :wk "Hoogle search prompt in the shell cmd")

      "zz" '(z :wk "Call zoxide prompt")

      "dd" '(OpenDiredBufferInSplit :wk "Open Dired buffer in split")
      "dt" '(dired-create-empty-file :wk "Create an empty file")

      "ld" '(lsp-find-definition :wk "Open diagnostic list in a separate split")
      "lk" '(lsp-ui-doc-show :wk "Show hover documentation")

      "ee" '(eshell :wk "Eshell")
      "en" '(eshell-new :wk "Spawn a new eshell buffer")

      ;; Evaluation
      "e" '(:ignore t :wk "Evaluate/Eshell")
      "eb" '(eval-buffer :wk "Evaluate elisp in buffer")
      "ed" '(eval-defun :wk "Evaluate defun containing or after point")
      "ex" '(eval-expression :wk "Evaluate and elisp expression")
      "el" '(eval-last-sexp :wk "Evaluate elisp expression before point")
      "er" '(eval-region :wk "Evaluate elisp in region")

      ;; Eshell
      "es" '(counsel-esh-history :wk "Eshell history")

      )
    
      (w/leader-keys
        :keymaps 'help-mode-map
        "sl" '(load-desktop-with-name :wk "Load a desktop session by name, chosen from available sessions"))
      
    (dotimes (i 9)
      (let ((n (1+ i))) ; Tab numbers start from 1
        (general-def
          :states '(normal emacs)
          :keymaps 'override
          :prefix "SPC"
          (format "%d" n) `(lambda () (interactive) (tab-bar-select-tab ,n)))))
    )

#+end_src

** Avy

#+begin_src emacs-lisp

  (use-package avy)

  (defun avy-goto-char-2-all-windows ()
    "Invoke `avy-goto-char-2` across all windows in the current frame."
    (interactive)
    (let ((avy-all-windows t))
      (call-interactively 'evil-avy-goto-char-2)))

#+end_src

** Async

#+begin_src emacs-lisp

  (use-package async
    :config
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1))

#+end_src

** Transient

#+begin_src emacs-lisp

(use-package transient
  :config
  ;; Define a simple transient for the cp command
  (transient-define-prefix my-eshell-cp-transient ()
    "Transient for the cp command."
    ["cp options"
     ("r" "Recursive" "-r")
     ("v" "Verbose" "-v")
     ("e" "Execute" my-eshell-execute-cp :transient nil)]))

(defun my-eshell-execute-cp ()
  "Function to construct cp command with selected options and insert it into eshell."
  (interactive)
  (let ((args (transient-args 'my-eshell-cp-transient)))
    ;; Construct the cp command with selected options
    (let ((command (concat "cp " (string-join args " "))))
      ;; Insert the command into the eshell buffer
      (insert command)
      ;; Optionally, you can also execute the command immediately
      ;; (eshell-send-input)
      )))

#+end_src

** Search

#+begin_src emacs-lisp

  (use-package rg
    :config
    (rg-enable-default-bindings))

#+end_src

** Xterm-color

#+begin_src emacs-lisp

  (use-package xterm-color)

  (setq comint-output-filter-functions
        (remove 'ansi-color-process-output comint-output-filter-functions))

  ;; Comint
  (add-hook 'shell-mode-hook
            (lambda ()
              ;; Disable font-locking in this buffer to improve performance
              (font-lock-mode -1)
              ;; Prevent font-locking from being re-enabled in this buffer
              (make-local-variable 'font-lock-function)
              (setq font-lock-function (lambda (_) nil))
              (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))

  ;; Eshell
  (require 'eshell) ; or use with-eval-after-load

  (add-hook 'eshell-before-prompt-hook
            (lambda ()
              (setq xterm-color-preserve-properties t)))

  (add-to-list 'eshell-preoutput-filter-functions 'xterm-color-filter)
  (setq eshell-output-filter-functions (remove 'eshell-handle-ansi-color eshell-output-filter-functions))
  (setenv "TERM" "xterm-256color")

  ;; Compilation buffers
  (setq compilation-environment '("TERM=xterm-256color"))

  (defun my/advice-compilation-filter (f proc string)
    (funcall f proc (xterm-color-filter string)))

  (advice-add 'compilation-filter :around #'my/advice-compilation-filter)
  
#+end_src

** Jinx

#+begin_src emacs-lisp

  ;; (use-package jinx
  ;;   ;; :hook
  ;;   ;; (dolist (hook '(text-mode-hook prog-mode-hook conf-mode-hook))
  ;;   ;; (add-hook hook #'jinx-mode))
  ;;   :bind (("M-$" . jinx-correct)
  ;;          ("C-M-$" . jinx-languages)))

#+end_src

** Completion

*** Snippets

#+begin_src emacs-lisp

  (use-package yasnippet
    :config
    (yas-global-mode 1)
    ;; Add your snippets directory to `yas-snippet-dirs`
    ;; (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets/org-mode/")
    ;; (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets/org-mode/")
    ;; Load the snippets
    (yas-reload-all))

#+end_src

*** Orderless

#+begin_src emacs-lisp

  (use-package orderless
    :init
    ;; ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))

#+end_src

*** Company

#+begin_src emacs-lisp

    ;; (use-package company
    ;;   :init
    ;;   (add-hook 'after-init-hook 'global-company-mode)
    ;;   :config
    ;;   (add-to-list 'company-backends 'company-files)
    ;;   (setq company-require-match nil)
    ;;   (setq company-minimum-prefix-length 1)
    ;;   (setq company-idle-delay nil))

  (use-package company
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    :config
    (setq company-require-match nil)
    ;; Set default company-mode settings
    (setq company-minimum-prefix-length 1
          company-idle-delay nil) ;; Disable automatic suggestions globally

    ;; Add company-files to the list of backends
    (add-to-list 'company-backends 'company-files)

    ;; Function to enable automatic suggestions in eshell
    (defun my-company-mode-setup-eshell ()
      (setq-local company-idle-delay 0.1)) ;; Enable automatic suggestions in eshell

    ;; Add the setup function to eshell-mode-hook
    (add-hook 'eshell-mode-hook 'my-company-mode-setup-eshell))

  (defun my/company-manual-complete ()
    "Enable company-mode and call company-complete."
    (interactive)
    (unless company-mode
      (company-mode 1))
    (company-complete))

  (with-eval-after-load 'evil
    (defun my-evil-insert-state-setup ()
      (unless (minibufferp)
        (define-key evil-insert-state-local-map (kbd "TAB") 'my/company-manual-complete)))

    (add-hook 'evil-insert-state-entry-hook 'my-evil-insert-state-setup))

#+end_src

** Acess to ENV variables

#+begin_src emacs-lisp

    (use-package exec-path-from-shell
      :config
      (exec-path-from-shell-initialize)
      (exec-path-from-shell-copy-env "FZF_DEFAULT_COMMAND")
      (exec-path-from-shell-copy-env "SSH_AUTH_SOCK")
      (exec-path-from-shell-copy-env "NOTIFY_TOKEN")
      (exec-path-from-shell-copy-env "SHELF_TOKEN")
      (exec-path-from-shell-copy-env "SHELF_DB_USER")
      (exec-path-from-shell-copy-env "SHELF_DB_NAME")
      (exec-path-from-shell-copy-env "SHELF_DB_PASS")
      (exec-path-from-shell-copy-env "SHELF_DB_PORT")
      )

#+end_src

** Treesitter

#+begin_src emacs-lisp

  (use-package treesit-auto
    :config
    ;; (treesit-auto-add-to-auto-mode-alist
    ;; '(("\\.py$" . python-ts-mode)
    ;;   ("\\.rb$" . ruby-ts-mode)
    ;;   ("\\.go$" . go-ts-mode)
    ;;   ("\\.bashrc\\'" . shell-mode)
    ;;   ("\\.zshrc\\'" . shell-mode))) ; Removed the extra parentheses here
    (global-treesit-auto-mode))

  (use-package clojure-ts-mode)

  ;; (setq treesit-language-source-alist
  ;;       '((templ "https://github.com/vrischmann/tree-sitter-templ")
  ;;         (bash "https://github.com/tree-sitter/tree-sitter-bash")
  ;;         (cmake "https://github.com/uyha/tree-sitter-cmake")
  ;;         (css "https://github.com/tree-sitter/tree-sitter-css")
  ;;         ;; (elisp "https://github.com/Wilfred/tree-sitter-elisp")
  ;;         (go "https://github.com/tree-sitter/tree-sitter-go")
  ;;         (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
  ;;         (html "https://github.com/tree-sitter/tree-sitter-html")
  ;;         (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
  ;;         (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
  ;;         (json "https://github.com/tree-sitter/tree-sitter-json")
  ;;         (make "https://github.com/alemuller/tree-sitter-make")
  ;;         (markdown "https://github.com/ikatyang/tree-sitter-markdown")
  ;;         (python "https://github.com/tree-sitter/tree-sitter-python")
  ;;         (toml "https://github.com/tree-sitter/tree-sitter-toml")
  ;;         (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
  ;;         (typescript "https://github.com/tree-sitter/tree-sitter-typescript"
  ;;                     "master" "typescript/src")
  ;;         (yaml "https://github.com/ikatyang/tree-sitter-yaml")
  ;;         (clojure "https://github.com/sogaiu/tree-sitter-clojure")
  ;;         (haskell "https://github.com/tree-sitter/tree-sitter-haskell")
  ;;         (typst "https://github.com/uben0/tree-sitter-typst")
  ;;         (java "https://github.com/tree-sitter/tree-sitter-java")
  ;;         (ruby "https://github.com/tree-sitter/tree-sitter-ruby")
  ;;         (rust "https://github.com/tree-sitter/tree-sitter-rust")))

  ;;   (add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.clj\\'" . clojure-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.sh\\'" . bash-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.toml\\'" . toml-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.py\\'" . python-ts-mode))
  ;; ;; (with-eval-after-load 'yaml-ts-mode
  ;;   (add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-ts-mode))

#+end_src

** Sudo Edit

#+begin_src emacs-lisp

  (use-package sudo-edit
    :config
      (w/leader-keys
        "sf" '(sudo-edit-find-file :wk "Sudo find file")
        "se" '(sudo-edit :wk "Sudo edit file")))

#+end_src

** Paredit

#+begin_src emacs-lisp

  (use-package paredit)

#+end_src

** Hyperbole

#+begin_src emacs-lisp

  (defun my/hyperbole-disable-key-bindings-after-init-hook ()
    ;; Undefine conflicting keys in the hyperbole mode map.
    (define-key hyperbole-mode-map (kbd "M-RET") nil)
    ;; Add more key unbindings as needed.
  )

  (use-package hyperbole
    :ensure t
    :config
    ;; Add a custom after-init-hook to adjust Hyperbole's keybindings
    ;; after its own initialization process has completed.
    (add-hook 'after-init-hook #'my/hyperbole-disable-key-bindings-after-init-hook t))

    (with-eval-after-load 'hyperbole
      (define-key hyperbole-mode-map (kbd "M-o") nil))

#+end_src

** Zoxide

#+begin_src emacs-lisp
  
  (straight-use-package
   '(zoxide :host gitlab :repo "Vonfry/zoxide.el"))
    
#+end_src

** Cider

#+begin_src emacs-lisp

  (use-package cider
    :config
    (setq cider-eldoc-display-for-symbol-at-point nil)
    (add-hook 'cider-mode-hook (lambda () (eldoc-mode -1))))

  (setq eldoc-documentation-function (lambda () nil))

#+end_src

** Projectile

#+begin_src emacs-lisp

  (defun my/projectile-project-root-advice (original-projectile-root &rest args)
    "Advice to make Projectile recognize custom project roots."
    (or
     ;; First, check if the specific directory should be treated as a project root.
     (when (string-prefix-p "/home/wurfkreuz/.secret_dotfiles/org" (expand-file-name default-directory))
       "/home/wurfkreuz/.secret_dotfiles/org/")
     ;; Next, look for 'bb.edn' up the directory tree to identify a project root.
     (let ((current-dir (expand-file-name default-directory))
           (project-root nil))
       (while (and (not project-root) (not (string= current-dir "/")))
         (when (file-exists-p (concat current-dir "bb.edn"))
           (setq project-root current-dir))
         (setq current-dir (file-name-directory (directory-file-name current-dir))))
       project-root)
     ;; Fallback to the original projectile root detection if none of the above conditions are met.
     (apply original-projectile-root args)))

  (use-package projectile
    :config
    (projectile-mode 1)
    (advice-add 'projectile-project-root :around #'my/projectile-project-root-advice))
  
#+end_src

** Mentor

#+begin_src emacs-lisp

  (use-package mentor)
  
#+end_src

** Wgrep

#+begin_src emacs-lisp

  (use-package wgrep)
  
#+end_src

** Embark

#+begin_src emacs-lisp

  (use-package embark
    :bind
    ("C-;" . embark-act))

#+end_src

** Ivy/Counsel

#+begin_src emacs-lisp

  (defun my-find-file-sudo-advice (orig-fun &rest args)
    "Open file as root if necessary, but skip for directories, writable files, and if parent directory is writable."
    (let ((file (car args)))
      (if (or (file-directory-p file) ; Check if it's a directory
              (file-writable-p file) ; or if it's writable
              (my-check-parent-directory-writable (file-name-directory file))) ; or if any parent directory is writable
          (apply orig-fun args) ; then just open it normally
        ;; Else, try opening with sudo
        (apply orig-fun (list (concat "/sudo:root@localhost:" file))))))

  (defun my-check-parent-directory-writable (dir)
    "Recursively check if any parent directory of DIR is writable."
    (when dir
      (or (file-writable-p dir)
          (unless (or (string= dir "/") (string= dir (directory-file-name dir))) ; Stop if at root
            (my-check-parent-directory-writable (file-name-directory (directory-file-name dir)))))))

  (advice-add 'find-file :around #'my-find-file-sudo-advice)

    (use-package counsel
      :after ivy
      :config
      (counsel-mode))
    (global-set-key (kbd "C-c C-y") 'cousel-yank-pop)

    ;; (push '(counsel-esh-history . ivy-display-function-fallback) ivy-display-functions-alist))

    (use-package ivy
      :bind
      ;; ivy-resume resumes the last Ivy-based completion.
      (("C-c C-r" . ivy-resume)
       ("C-x B" . ivy-switch-buffer-other-window))
      :custom
      (setq ivy-use-virtual-buffers t)
      (setq ivy-count-format "(%d/%d) ")
      (setq enable-recursive-minibuffers t)
      :config
      (ivy-mode))

    (use-package ivy-posframe
      :ensure t
      :after ivy
      :config
      (ivy-posframe-mode 1))
    (setq ivy-posframe-width 50)
    (setq ivy-posframe-display-functions-alist
          '((counsel-esh-history . ivy-posframe-display-at-window-center)))

    ;; To display icons correctly, you should run M-x all-the-icons-install-fonts to install the necessary fonts.
    (use-package all-the-icons-ivy-rich
      :init
      (all-the-icons-ivy-rich-mode 1))

    (use-package ivy-rich
      :after ivy
      :ensure t
      :init (ivy-rich-mode 1) ;; this gets us descriptions in M-x.
      :custom
      (ivy-virtual-abbreviate 'full
                              ivy-rich-switch-buffer-align-virtual-buffer t
                              ivy-rich-path-style 'abbrev))

    (defun counsel-find-file-check-dir ()
      "Like `counsel-find-file', but use `find-file-check-dir' instead of `find-file'."
      (interactive)
      (let* ((current-dir (if (eq major-mode 'dired-mode)
                              "."
                            (buffer-file-name))))
        (ivy-read "Find file: " #'read-file-name-internal
                  :matcher #'counsel--find-file-matcher
                  :action #'find-file-check-dir
                  :preselect current-dir
                  :require-match 'confirm-after-completion
                  :history 'file-name-history
                  :keymap counsel-find-file-map
                  :caller 'counsel-find-file)))

    (global-set-key (kbd "C-x f") 'counsel-find-file-check-dir)

    (defun counsel-fzf-current ()
      "Run a customized `counsel-fzf`-like file selection using `fd` from the current project directory."
      (interactive)
      (let ((default-directory (projectile-project-root))
            (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --hidden"))
        (ivy-read "Find file in project: " (split-string (shell-command-to-string fzf-command) "\n")
                  :action (lambda (f)
                            (find-file (expand-file-name f default-directory)))
                  :caller 'counsel-fzf-current)))

    (defun counsel-fzf-home ()
      "Run a customized `counsel-fzf`-like file selection using `fd` from START-DIRECTORY."
      (interactive)
      (let ((default-directory "~/")
            (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --hidden"))
        (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
                  :action (lambda (f)
                            (find-file (expand-file-name f default-directory)))
                  :caller 'my-counsel-fzf-with-fd)))

    (defun counsel-fzf-root ()
      "Run a customized `counsel-fzf`-like file selection using `fd` from START-DIRECTORY."
      (interactive)
      (let ((default-directory "/")
            (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --hidden"))
        (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
                  :action (lambda (f)
                            (find-file (expand-file-name f default-directory)))
                  :caller 'my-counsel-fzf-with-fd)))

    (defun insert-path-from-counsel-fzf-home ()
      "Insert the path of a file selected by `counsel-fzf` from the home directory into the current buffer."
      (interactive)
      (let ((default-directory "~/")
            (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --type f --hidden"))
        (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
                  :action (lambda (f)
                            (insert (expand-file-name f default-directory)))
                  :caller 'insert-path-from-counsel-fzf-home)))

    (defun insert-path-from-counsel-fzf-root ()
      "Insert the path of a file selected by `counsel-fzf` from the home directory into the current buffer."
      (interactive)
      (let ((default-directory "/")
            (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --type f --hidden"))
        (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
                  :action (lambda (f)
                            (insert (expand-file-name f default-directory)))
                  :caller 'insert-path-from-counsel-fzf-home)))

#+end_src

** Prescient

#+begin_src emacs-lisp

  ;; (use-package ivy-prescient
  ;;   :after counsel
  ;;   :config
  ;;   (ivy-prescient-mode 1))
    
#+end_src
** Fzf

#+begin_src emacs-lisp

  (use-package fzf)

  (defun fzf-from-home-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
        and exclude certain directories but with an ability to interactively change
        the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    (let ((default-directory "~/"))
      (fzf-directory)))

  (defun fzf-from-root-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
        and exclude certain directories but with an ability to interactively change
        the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")
    (let ((default-directory "/"))
      (fzf-directory)))

  (defun fzf-notes ()
    "Start fzf in the notes directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    (let ((default-directory "~/.secret_dotfiles/org"))
      (fzf-directory)))

  ;; (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")

  (defun fzf-from-root-no-prompt ()
    "Starts fzf from the user's root directory using fd to include hidden files
    and exclude certain directories without prompting for a directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")
    (fzf))
  
  (defun fzf-from-home-no-prompt ()
    "Starts fzf from the user's home directory using fd to include hidden files
      and exclude certain directories without prompting for a directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git . /home/wurfkreuz")
    (fzf))

  (defun fzf-from-current-with-fd ()
    "Starts fzf from the current directory using fd to include hidden files
     and exclude certain directories. Works both locally and on remote servers."
    (interactive)
    ;; Set the FZF_DEFAULT_COMMAND environment variable
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    ;; Check if the current directory is a TRAMP directory
    (let ((tramp-address (file-remote-p default-directory)))
      (if tramp-address
          ;; If we're in a TRAMP directory, use the extracted address
          (fzf-directory tramp-address)
        ;; If not in a TRAMP directory, use the local home directory
        (fzf-directory "~/"))))

  (setq fzf/args "-x --color bw --print-query --margin=1,0 --no-hscroll --inline-info --bind ctrl-n:down,ctrl-p:up")

#+end_src

** Hydra

#+begin_src emacs-lisp

  (defun my-enlarge-window-horizontally ()
    "Enlarge the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (shrink-window-horizontally 5)
      (enlarge-window-horizontally 5)))

  (defun my-shrink-window-horizontally ()
    "Shrink the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (enlarge-window-horizontally 5)
      (shrink-window-horizontally 5)))

  (use-package hydra
    :config
    (defhydra hydra-window-size (:color red)
      "window size"
      ("h" my-shrink-window-horizontally "shrink horizontally")
      ("l" my-enlarge-window-horizontally "enlarge horizontally")
      ("k" (lambda () (interactive) (shrink-window 3)) "shrink vertically")
      ("j" (lambda () (interactive) (enlarge-window 3)) "enlarge vertically")
      ("t" transpose-frame "transpose windows")
      ("q" nil "quit")))

#+end_src

* Dired

#+begin_src emacs-lisp

        ;; (add-hook 'dired-mode-hook
        ;;         (lambda ()
        ;;           (wdired-change-to-wdired-mode)))

        (add-to-list 'auto-revert-remote-files "/sudo:root@localhost:/etc/")

        (setq delete-by-moving-to-trash t
              trash-directory "~/.local/share/trash/")

        (setq wdired-allow-to-create-files t)
        (setq wdired-allow-to-change-permissions t)

        (setq evil-move-cursor-back nil)
        (add-hook 'wdired-mode-hook #'evil-normal-state)

        (defun my-dired-do-symlink-with-sudo ()
          "Create a symlink, using sudo if necessary."
          (interactive)
          (let* ((files (dired-get-marked-files))
                (default-directory (if (file-remote-p default-directory)
                                        (tramp-file-name-localname (tramp-dissect-file-name default-directory))
                                      default-directory))
                (target (read-file-name "Symlink to: " default-directory))
                (sudo-target (if (file-writable-p (file-name-directory target))
                                  target
                                (concat "/sudo::" target))))
            (dolist (file files)
              (let ((link-name (read-string (format "Link name for %s: " (file-name-nondirectory file)) (file-name-nondirectory file))))
                (make-symbolic-link file (expand-file-name link-name (file-name-directory sudo-target)) t)))))

        (defun my-dired-setup ()
          (evil-define-key 'normal dired-mode-map (kbd "S") 'my-dired-do-symlink-with-sudo))

        (add-hook 'dired-mode-hook 'my-dired-setup)

        ;; (defun my-dired-do-delete-with-sudo ()
        ;;   "Attempt to move the marked files to trash, using sudo if necessary."
        ;;   (interactive)
        ;;   (let ((files (dired-get-marked-files)))
        ;;     (dolist (file files)
        ;;       (if (yes-or-no-p (format "Move %s to trash? " (file-name-nondirectory file)))
        ;;           (if (file-writable-p (file-name-directory file))
        ;;               (dired-delete-file file 'trash)
        ;;             (let ((sudo-file (concat "/sudo::" file)))
        ;;               (when (yes-or-no-p (format "Insufficient permissions to move %s to trash. Retry with sudo? " (file-name-nondirectory file)))
        ;;                 (with-temp-buffer
        ;;                   (cd (file-name-directory sudo-file))
        ;;                   (dired-delete-file sudo-file 'trash))))))))
        ;;   (revert-buffer))

        ;; (evil-define-key 'normal dired-mode-map (kbd "D") 'my-dired-do-delete-with-sudo)

  ;; (defun dired-run-bak-on-marked-files (beg end)
  ;; "Run the 'bak' script on marked files or visually selected files in Dired."
  ;; (interactive
  ;;  (if (use-region-p)
  ;;      (list (region-beginning) (region-end)) ; If there's an active region, use it
  ;;    (list nil nil))) ; Otherwise, process marked files
  ;; (if (and beg end)
  ;;     ;; If beg and end are provided, process files in the region
  ;;     (save-excursion
  ;;       (goto-char beg)
  ;;       (let ((end-marker (copy-marker end)))
  ;;         (while (< (point) end-marker)
  ;;           (when (dired-move-to-filename)
  ;;             (let ((file (dired-get-filename nil t)))
  ;;               (start-process "bak-process" nil "bak" file)))
  ;;           (dired-next-line 1))))
  ;;   ;; If no region is active, process marked files
  ;;   (let ((files (dired-get-marked-files)))
  ;;     (dolist (file files)
  ;;       (start-process "bak-process" nil "bak" file))))
  ;; ;; Exit visual mode if in Evil mode
  ;; (when (bound-and-true-p evil-local-mode)
  ;;   (evil-normal-state)))

  (defun dired-run-bak-on-marked-files (beg end)
    "Run the 'bak' script on marked files or visually selected files in Dired, with an option to copy."
    (interactive
    (if (use-region-p)
        (list (region-beginning) (region-end)) ; If there's an active region, use it
      (list nil nil))) ; Otherwise, process marked files
    ;; Prompt the user to ask if they want to copy the files.
    (let ((copy-flag (if (yes-or-no-p "Copy files? ") "-c" nil)))
      (if (and beg end)
          ;; If beg and end are provided, process files in the region
          (save-excursion
            (goto-char beg)
            (let ((end-marker (copy-marker end)))
              (while (< (point) end-marker)
                (when (dired-move-to-filename)
                  (let ((file (dired-get-filename nil t)))
                    ;; Conditionally include the -c flag based on user input
                    (if copy-flag
                        (start-process "bak-process" nil "bak" copy-flag file)
                      (start-process "bak-process" nil "bak" file))))
                (dired-next-line 1))))
        ;; If no region is active, process marked files
        (let ((files (dired-get-marked-files)))
          (dolist (file files)
            ;; Conditionally include the -c flag based on user input
            (if copy-flag
                (start-process "bak-process" nil "bak" copy-flag file)
              (start-process "bak-process" nil "bak" file))))))
    ;; Exit visual mode if in Evil mode
    (when (bound-and-true-p evil-local-mode)
      (evil-normal-state)))

      (defun my-dired-setup ()
        (evil-define-key 'normal dired-mode-map (kbd "B") 'dired-run-bak-on-marked-files)
        (evil-define-key 'visual dired-mode-map (kbd "B") 'dired-run-bak-on-marked-files))

      (add-hook 'dired-mode-hook 'my-dired-setup)

        ;; (defun my-dired-setup ()
        ;;   (evil-define-key 'normal dired-mode-map (kbd "B") 'dired-toggle-bak-extension)
        ;;   (evil-define-key 'visual dired-mode-map (kbd "B") 'dired-toggle-bak-extension))

#+end_src


** Dired keybindings

#+begin_src emacs-lisp

  ;; (evil-define-key 'normal dired-mode-map
  ;;   (kbd "+") 'dired-create-directory))

#+end_src

* Tramp

#+begin_src emacs-lisp

  (require 'tramp)

  (setq tramp-ssh-controlmaster-options (format "-i %s" "~/.ssh/git"))
  (add-to-list 'tramp-connection-properties
               (list (regexp-quote "/ssh:")
                     "direct-async-process" t))

  ;; cache file-name forever
  (setq remote-file-name-inhibit-cache nil)

  ;; make sure vc stuff is not making tramp slower
  (setq vc-ignore-dir-regexp
        (format "%s\\|%s"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))

  ;; not sure why we have this? just cargo-culting from an answer I saw
  ;; online.
  (setq tramp-verbose 1)

  ;; projectile has the fun side-effect of wanting to calculate the
  ;; project name, which makes tramp oh-so-much-slower.
  (setq projectile-mode-line "Projectile")

#+end_src

* Shells and Terminals
** Eshell

#+begin_src emacs-lisp

    (setq eshell-destroy-buffer-when-process-dies t)

    (use-package eshell-syntax-highlighting
      :after esh-mode  ;; don't change to 'eshell-mode'
      :config
      (eshell-syntax-highlighting-global-mode +1))

    (add-hook 'eshell-mode-hook 'eshell-hist-mode)  ; Enable Eshell history mode
    ;;(add-hook 'eshell-mode-hook 'eshell-toggle-direct-send) ;; !!! very careful !!!

  (setq eshell-rc-script (concat user-emacs-directory "eshell/eshelrc")
        eshell-aliases-file (concat user-emacs-directory "eshell/aliases")
        eshell-history-size 100000
        eshell-buffer-maximum-lines 5000
        ;; eshell-save-history-on-exit t
          eshell-history-file-name "~/.emacs.d/eshell_history"
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t
          eshell-destroy-buffer-when-process-dies t
          eshell-banner-message ""
          eshell-visual-commands'("bash" "htop" "ssh" "top" "gpg" "paru" "ngrok" "bat"))

    (add-hook 'eshell-mode-hook
              (lambda ()
                (setq-local scroll-margin 0)))

    (with-eval-after-load 'eshell
      ;; Set eshell-save-history-on-exit to nil
      (setq eshell-save-history-on-exit nil)

      ;; Define eshell-append-history function
      (defun eshell-append-history ()
        "Call `eshell-write-history' with the `append' parameter set to `t'."
        (when eshell-history-ring
          (let ((newest-cmd-ring (make-ring 1)))
            (ring-insert newest-cmd-ring (car (ring-elements eshell-history-ring)))
            (let ((eshell-history-ring newest-cmd-ring))
              (eshell-write-history eshell-history-file-name t)))))

    ;; Add eshell-append-history to eshell-pre-command-hook
    (add-hook 'eshell-pre-command-hook #'eshell-append-history))

    (defun eshell-insert-last-argument ()
      "Insert the last argument of the previous command."
      (interactive)
      (let* ((last-command (eshell-previous-input-string 0))
             (args (split-string-and-unquote last-command))
             (last-arg (car (last args))))
        (when last-arg
          (insert last-arg))))

    (defun setup-eshell-keys ()
      (define-key eshell-mode-map (kbd "M-.") 'eshell-insert-last-argument))
    ;; (define-key eshell-mode-map (kbd "M-r") 'counsel-esh-history))

    (add-hook 'eshell-mode-hook 'setup-eshell-keys)

    (with-eval-after-load 'evil
      (evil-define-key 'insert eshell-mode-map (kbd "M-r") 'counsel-esh-history)
      (evil-define-key 'normal eshell-mode-map (kbd "M-r") 'counsel-esh-history))

    (defun eshell/edit (filename)
      "Open FILENAME in the current buffer, using the current TRAMP address."
      (interactive "sEnter the filename to edit: ")
      ;; Extract the current TRAMP address from the Eshell buffer's default directory
      (let ((tramp-address (file-remote-p default-directory)))
        (if tramp-address
            ;; If we're in a TRAMP directory, use the extracted address
            (find-file (concat tramp-address filename))
          ;; If not in a TRAMP directory, fall back to a default address or prompt the user
          (message "Not in a TRAMP directory. Please specify the TRAMP address manually.")
          ;; Optionally, you can add a fallback mechanism here, e.g., prompting the user for a TRAMP address
          )))

    (defalias 'e 'eshell/edit)

    (require 'em-tramp) ; to load eshell’s sudo
    ;; (setq eshell-prefer-lisp-functions t)
    ;; (setq eshell-prefer-lisp-variables t)
    ;; (setq password-cache t) ; enable password caching
    ;; (setq password-cache-expiry 10)
    ;; (add-hook 'eshell-load-hook (lambda () (add-to-list 'eshell-modules-list 'eshell-tramp)))

    (defun eshell-clear-buffer ()
      "Clear the current Eshell buffer."
      (interactive)
      (let ((inhibit-read-only t))
        (erase-buffer)
        (eshell-send-input)))

    (defun eshell-new ()
      "Create a new Eshell buffer with a unique name."
      (interactive)
      (let ((eshell-buffer-name (generate-new-buffer-name "*eshell*")))
        (eshell)))

#+end_src

** Async shell

#+begin_src emacs-lisp

  ;; Execute async shell command on a current file
  (defun async-shell-command-on-file (command)
    "Execute COMMAND asynchronously on the current file."
    (interactive (list (read-shell-command
                        (concat "Async shell command on " (buffer-name) ": "))))
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (async-shell-command (concat command " " filename))))

  
  (defun async-shell-command-filter-hook ()
  "Filter async shell command output via `comint-output-filter'."
  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
    ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
    ;; are displayed
    (setq-local comint-inhibit-carriage-motion nil)
    (when-let ((proc (get-buffer-process (current-buffer))))
      (set-process-filter proc 'comint-output-filter))))

  (with-eval-after-load 'shell
    (add-hook 'shell-mode-hook 'async-shell-command-filter-hook))

#+end_src

** Eat

#+begin_src emacs-lisp

  ;; (let ((lisp-dir "~/.emacs.d/lisp")
  ;;       (emacs-eat-dir "~/.emacs.d/lisp/emacs-eat")
  ;;       (emacs-eat-repo "git@github.com:kephale/emacs-eat.git"))
  ;;   ;; Check if the lisp directory exists, if not, create it
  ;;   (unless (file-directory-p lisp-dir)
  ;;     (make-directory lisp-dir t))

  ;;   ;; Check if the emacs-eat directory exists
  ;;   (unless (file-directory-p emacs-eat-dir)
  ;;     ;; If emacs-eat directory does not exist, check if git is available
  ;;     (if (executable-find "git")
  ;;         (progn
  ;;           (message "Cloning emacs-eat...")
  ;;           (shell-command (concat "git clone " emacs-eat-repo " " emacs-eat-dir))
  ;;           (message "emacs-eat cloned successfully."))
  ;;       (error "Git is not installed, cannot clone emacs-eat"))))

  ;; Add emacs-eat to the load-path
  ;; (add-to-list 'load-path "~/.emacs.d/lisp/emacs-eat")
  ;; (require 'eat)
  ;; (eat-eshell-mode 1)
  ;; ;; (setq eshell-visual-commands nil)

  ;; (add-hook 'eshell-first-time-mode-hook
  ;;           #'eat-eshell-visual-command-mode)
  ;; (add-hook 'eshell-first-time-mode-hook #'eat-eshell-mode)

#+end_src

** Cmd

#+begin_src emacs-lisp

  (defun my-hoogle-search (query)
    "Search Hoogle for QUERY."
    (interactive "sHoogle search: ") ; Prompt for the search term
    (shell-command (concat "hoogle search " (shell-quote-argument query))))

#+end_src

** Cursor changer

#+begin_src emacs-lisp

  (use-package evil-terminal-cursor-changer
    :config
    (unless (display-graphic-p)
      (require 'evil-terminal-cursor-changer)
      (evil-terminal-cursor-changer-activate) ; or (etcc-on)
      )
    )

#+end_src

* Database

#+begin_src emacs-lisp

      ;; Define the connection details for PostgreSQL, including two databases
      (setq sql-connection-alist
            '((postgres-wurfkreuz
              (sql-product 'postgres)
              (sql-user "wurfkreuz")
              (sql-server "localhost")
              (sql-port 5432)
              (sql-database "wurfkreuz"))
              (postgres-shelf
              (sql-product 'postgres)
              (sql-user "wurfkreuz") ; Assuming the same user for simplicity
              (sql-server "localhost")
              (sql-port 5432)
              (sql-database "shelf"))))

  (defun my-sql-connect-with-buffer (connection)
  "Connect to a SQL database using `sql-connect' and open a new SQL mode buffer."
  (interactive (list (completing-read "Select database: "
                                      (mapcar #'car sql-connection-alist)
                                      nil t)))
  (let ((sql-buffer (sql-connect connection)))
    (when (and (boundp 'sql-buffer) sql-buffer)
      (delete-other-windows)
      (switch-to-buffer (get-buffer-create "*SQL Buffer*"))
      (sql-mode)
      (split-window-below)
      (other-window 1)
      (switch-to-buffer sql-buffer)
      (balance-windows))))

  (defun show-table (table-name)
    "Describe the specified table by selecting a few rows."
    (interactive "sTable name: ")
    (let ((query (format "SELECT * FROM %s LIMIT 5;" table-name)))
      (with-current-buffer sql-buffer
        (goto-char (point-max))
        (insert query)
        (sql-send-paragraph))))

#+end_src

* Sessions

#+begin_src emacs-lisp

  ;; (setq desktop-restore-eager 10)

  (defvar current-desktop-session-name nil
    "The name of the currently loaded desktop session.")

  (defvar desktop-autosave-timer nil
    "Timer object for desktop autosave, to avoid multiple timers running.")

  (defun save-eshell-buffer (desktop-dirname)
    ;; Save the current working directory.
    default-directory)

  (defun restore-eshell-buffer (_file-name buffer-name misc)
    "MISC is the value returned by `save-eshell-buffer'.
                  _FILE-NAME is nil."
    (let ((default-directory misc))
      ;; Create an eshell buffer named BUFFER-NAME in directory MISC.
      (eshell buffer-name)))

  ;; Save all eshell-mode buffers.
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local desktop-save-buffer #'save-eshell-buffer)))

  ;; Restore all eshell-mode buffers.
  (add-to-list 'desktop-buffer-mode-handlers '(eshell-mode . restore-eshell-buffer))

  (defun save-current-desktop-session (&optional show-message)
    "Save the current desktop session using the current session name.
  If no session is loaded, prompt to create a new one. SHOW-MESSAGE controls whether a save message is displayed."
    (interactive "p") ; "p" passes a prefix argument, which is non-nil when called interactively
    (if (and current-desktop-session-name (not (string-empty-p current-desktop-session-name)))
        (let ((desktop-dir (concat user-emacs-directory "desktop/" current-desktop-session-name "/")))
          (unless (file-exists-p desktop-dir)
            (make-directory desktop-dir t))
          (desktop-save desktop-dir)
          (when (and show-message (or (called-interactively-p 'any) (eq show-message 1)))
            (message "Session '%s' saved." current-desktop-session-name)))
      ;; No session is loaded or the session name is empty, prompt to create a new one (only when called interactively)
      (when (called-interactively-p 'any)
        (let ((new-session-name (read-string "Enter new session name: ")))
          (if (string-empty-p new-session-name)
              (message "Session name cannot be empty.")
            (progn
              (setq current-desktop-session-name new-session-name)
              (let ((new-desktop-dir (concat user-emacs-directory "desktop/" new-session-name "/")))
                (make-directory new-desktop-dir t)
                (desktop-save new-desktop-dir)
                (message "Session '%s' created and saved." new-session-name))))))))

  (defun setup-desktop-autosave-timer ()
    "Set up or reset the desktop autosave timer."
    (when desktop-autosave-timer
      (cancel-timer desktop-autosave-timer))
    ;; Pass nil to save-current-desktop-session to avoid showing the message during autosaves.
    (setq desktop-autosave-timer (run-with-timer 30 30 (lambda () (save-current-desktop-session nil)))))

  (defun load-desktop-session (session-name)
    "Load a desktop session by name."
    (let ((desktop-dir (concat user-emacs-directory "desktop/")))
      (setq current-desktop-session-name session-name)
      (desktop-change-dir (concat desktop-dir session-name "/"))
      (setup-desktop-autosave-timer)))

  (defun load-desktop-with-name ()
    "Load a desktop session by name, chosen from available sessions."
    (interactive)
    (when current-desktop-session-name
      ;; Save the current session before loading a new one, but only if a session is already loaded.
      (save-current-desktop-session))
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
           (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
           (session-name (completing-read "Choose desktop session: " session-dirs nil t)))
      (setq current-desktop-session-name session-name)  ; Save the session name globally
      (desktop-change-dir (concat desktop-dir session-name "/"))
      (setup-desktop-autosave-timer)))

  ;; Disable the default desktop save mode
  (desktop-save-mode 0)

  (setq desktop-files-not-to-save
      (concat "\\(^/[^/:]*:\\|(ftp)$\\)\\|" desktop-files-not-to-save))
  
  (defun delete-desktop-session ()
    "Delete a desktop session by name, chosen from available sessions."
    (interactive)
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
           (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
           (session-name (completing-read "Choose desktop session to delete: " session-dirs nil t)))
      (when (yes-or-no-p (format "Are you sure you want to delete the '%s' session? " session-name))
        (let ((session-path (concat desktop-dir session-name)))
          (if (file-directory-p session-path)
              (progn
                (delete-directory session-path t)  ; 't' for recursive delete
                (message "Deleted desktop session '%s'." session-name))
            (message "No such desktop session '%s'." session-name))))))

  (defun rename-desktop-session ()
    "Renames the currently loaded desktop session."
    (interactive)
    ;; Check if there's a session loaded.
    (if (not current-desktop-session-name)
        (message "No desktop session is currently loaded.")
      (let* ((new-name (read-string "New session name: "))
             (old-dir (concat user-emacs-directory "desktop/" current-desktop-session-name))
             (new-dir (concat user-emacs-directory "desktop/" new-name)))
        ;; Check if the new session name is empty or the session already exists.
        (if (or (string-empty-p new-name)
                (file-exists-p new-dir))
            (message "Invalid new session name or session already exists.")
          ;; Rename the directory and update the session name.
          (rename-file old-dir new-dir)
          (setq current-desktop-session-name new-name)
          (message "Session renamed to '%s'." new-name)))))

  (add-hook 'kill-emacs-hook 'clean-buffer-list)
  (add-hook 'kill-emacs-hook 'save-current-desktop-session)

  #+end_src

* Buffers

** Dired buffer

#+begin_src emacs-lisp

  (defun OpenDiredBufferInSplit ()
    "Open a Dired buffer in a vertical split on the right, showing the directory of the current buffer."
    (interactive)
    (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
      (split-window-right)
      (windmove-right)
      (dired current-dir)))

  (defun OpenDiredBufferInCurrentWindow ()
    "Open a Dired buffer in the current window, showing the directory of the current buffer."
    (interactive)
    (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
      (dired current-dir)))

#+end_src

** Shell buffer

#+begin_src emacs-lisp

  (defun my-shell-mode-hook ()
    (setq-local scroll-margin 0))

  (add-hook 'shell-mode-hook 'my-shell-mode-hook)

  (setq explicit-shell-file-name "/usr/bin/zsh")  ; your shell path here
  (setq explicit-bash-args '("--login" "-i"))

  ;; (defvar
  ;;   shell-toggle-window-configuration nil
  ;;   "Variable to store the window configuration before opening shell.")

  ;; (defvar shell-toggle-selected-window nil
  ;;   "Variable to store the selected window before opening shell.")

  ;; (defun SpawnShellSplitBelow ()
  ;;   "Open a shell in a small split below or toggle it if already open."
  ;;   (interactive)
  ;;   (if (eq major-mode 'shell-mode)
  ;;       (progn
  ;;         (when shell-toggle-window-configuration
  ;;           (set-window-configuration shell-toggle-window-configuration)
  ;;           (setq shell-toggle-window-configuration nil))
  ;;         (when shell-toggle-selected-window
  ;;           (select-window shell-toggle-selected-window)
  ;;           (setq shell-toggle-selected-window nil)))
  ;;     (setq shell-toggle-window-configuration (current-window-configuration))
  ;;     (setq shell-toggle-selected-window (selected-window))
  ;;     (split-window-below -10)
  ;;     (other-window 1)
  ;;     (open-shell-in-current-directory)))

  ;; (defun open-shell-in-current-directory ()
  ;;   "Open shell in the directory of the current buffer.
  ;; If a shell buffer for the directory already exists, switch to it."
  ;;   (interactive)
  ;;   (let* ((buffer-dir (if (buffer-file-name)
  ;;                         (file-name-directory (buffer-file-name))
  ;;                       default-directory))
  ;;         (shell-buffer-name (format "*shell: %s*" buffer-dir))
  ;;         (existing-shell-buffer (get-buffer shell-buffer-name)))
  ;;     (if existing-shell-buffer
  ;;         (switch-to-buffer existing-shell-buffer)
  ;;       (let ((default-directory buffer-dir)) ;; Ensure shell starts in the correct directory
  ;;         (shell (generate-new-buffer-name shell-buffer-name))))))

  ;; (with-eval-after-load 'evil
  ;;   (define-key evil-normal-state-map (kbd "M-s") 'SpawnShellSplitBelow))




  ;; (defvar spawn-toggle-window-configuration nil
  ;;   "Variable to store the window configuration before opening eshell or shell.")

  ;; (defvar spawn-toggle-selected-window nil
  ;;   "Variable to store the selected window before opening eshell or shell.")

  ;; (defun SpawnEshellSplitBelow ()
  ;;   "Open a shell in a small split below or toggle it if already open.
  ;; If the current buffer is a shell buffer, switch to an eshell buffer instead."
  ;;   (interactive)
  ;;   (if (eq major-mode 'shell-mode)
  ;;       (open-eshell-in-current-directory)
  ;;     (if (eq major-mode 'eshell-mode)
  ;;         (SpawnToggleOff)
  ;;       (SpawnToggleOn)
  ;;       (open-eshell-in-current-directory))))

  ;; (defun open-eshell-in-current-directory ()
  ;;   "Open eshell in the directory of the current buffer.
  ;; If an eshell buffer for the directory already exists, switch to it."
  ;;   (interactive)
  ;;   (let* ((buffer-dir (if (buffer-file-name)
  ;;                         (file-name-directory (buffer-file-name))
  ;;                       default-directory))
  ;;         (eshell-buffer-name (concat "*eshell:" buffer-dir "*"))
  ;;         (existing-eshell-buffer (get-buffer eshell-buffer-name)))
  ;;     (if existing-eshell-buffer
  ;;         (switch-to-buffer existing-eshell-buffer)
  ;;       (let ((eshell-buffer (eshell 'N)))
  ;;         (with-current-buffer eshell-buffer
  ;;           (rename-buffer eshell-buffer-name)
  ;;           (eshell/cd buffer-dir))))))

  ;; (defun SpawnShellSplitBelow ()
  ;;   "Open a shell in a small split below or toggle it if already open.
  ;; If the current buffer is an eshell buffer, switch to a shell buffer instead."
  ;;   (interactive)
  ;;   (if (eq major-mode 'eshell-mode)
  ;;       (open-shell-in-current-directory)
  ;;     (if (eq major-mode 'shell-mode)
  ;;         (SpawnToggleOff)
  ;;       (SpawnToggleOn)
  ;;       (open-shell-in-current-directory))))

  ;; (defun open-shell-in-current-directory ()
  ;;   "Open shell in the directory of the current buffer.
  ;; If a shell buffer for the directory already exists, switch to it."
  ;;   (interactive)
  ;;   (let* ((buffer-dir (if (buffer-file-name)
  ;;                         (file-name-directory (buffer-file-name))
  ;;                       default-directory))
  ;;         (shell-buffer-name (format "*shell: %s*" buffer-dir))
  ;;         (existing-shell-buffer (get-buffer shell-buffer-name)))
  ;;     (if existing-shell-buffer
  ;;         (switch-to-buffer existing-shell-buffer)
  ;;       (let ((default-directory buffer-dir)) ;; Ensure shell starts in the correct directory
  ;;         (shell (generate-new-buffer-name shell-buffer-name))))))

  ;; (defun SpawnToggleOff ()
  ;;   "Toggle off eshell or shell buffer and restore the previous window configuration."
  ;;   (when spawn-toggle-window-configuration
  ;;     (set-window-configuration spawn-toggle-window-configuration)
  ;;     (setq spawn-toggle-window-configuration nil))
  ;;   (when spawn-toggle-selected-window
  ;;     (select-window spawn-toggle-selected-window)
  ;;     (setq spawn-toggle-selected-window nil)))

  ;; (defun SpawnToggleOn ()
  ;;   "Store the current window configuration and selected window before spawning eshell or shell."
  ;;   (setq spawn-toggle-window-configuration (current-window-configuration))
  ;;   (setq spawn-toggle-selected-window (selected-window))
  ;;   (split-window-below -10)
  ;;   (other-window 1))

  ;; (with-eval-after-load 'evil
  ;;   (define-key evil-normal-state-map (kbd "M-e") 'SpawnEshellSplitBelow)
  ;;   (define-key evil-normal-state-map (kbd "M-s") 'SpawnShellSplitBelow))

#+end_src

** Eshell buffer

#+begin_src emacs-lisp

  (defvar
    eshell-toggle-window-configuration nil
    "Variable to store the window configuration before opening eshell.")

  (defvar eshell-toggle-selected-window nil
    "Variable to store the selected window before opening eshell.")

  (defun SpawnEshellSplitBelow ()
    "Open a shell in a small split below or toggle it if already open."
    (interactive)
    (if (eq major-mode 'eshell-mode)
        (progn
          (when eshell-toggle-window-configuration
            (set-window-configuration eshell-toggle-window-configuration)
            (setq eshell-toggle-window-configuration nil))
          (when eshell-toggle-selected-window
            (select-window eshell-toggle-selected-window)
            (setq eshell-toggle-selected-window nil)))
      (setq eshell-toggle-window-configuration (current-window-configuration))
      (setq eshell-toggle-selected-window (selected-window))
      ;; Calculate one third of the total window height
      (let ((one-third-height (/ (window-total-height) 3)))
        ;; Ensure the height is at least 1 to avoid errors
        (setq one-third-height (max one-third-height 1))
        (split-window-below (- one-third-height))
        (other-window 1)
        (open-eshell-in-current-directory))))

  (defun open-eshell-in-current-directory ()
    "Open eshell in the directory of the current buffer.
      If an eshell buffer for the directory already exists, switch to it."
    (interactive)
    (let* ((buffer-dir (if (buffer-file-name)
                           (file-name-directory (buffer-file-name))
                         default-directory))
           (eshell-buffer-name (concat "*eshell:" buffer-dir "*"))
           (existing-eshell-buffer (get-buffer eshell-buffer-name)))
      (if existing-eshell-buffer
          (switch-to-buffer existing-eshell-buffer)
        (let ((eshell-buffer (eshell 'N)))
          (with-current-buffer eshell-buffer
            (rename-buffer eshell-buffer-name)
            (eshell/cd buffer-dir))))))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "M-e") 'SpawnEshellSplitBelow))
  ;; (define-key evil-normal-state-map (kbd "M-e") 'open-eshell-in-current-directory))

  (defun SpawnEshellInProjectRoot ()
    "Open eshell in the project's root directory or toggle it if already open."
    (interactive)
    (if (eq major-mode 'eshell-mode)
        (progn
          (when eshell-toggle-window-configuration
            (set-window-configuration eshell-toggle-window-configuration)
            (setq eshell-toggle-window-configuration nil))
          (when eshell-toggle-selected-window
            (select-window eshell-toggle-selected-window)
            (setq eshell-toggle-selected-window nil)))
      (setq eshell-toggle-window-configuration (current-window-configuration))
      (setq eshell-toggle-selected-window (selected-window))
      ;; Calculate one third of the total window height
      (let ((one-third-height (/ (window-total-height) 3)))
        ;; Ensure the height is at least 1 to avoid errors
        (setq one-third-height (max one-third-height 1))
        (split-window-below (- one-third-height))
        (other-window 1)
        (let ((project-root (projectile-project-root)))
          (open-eshell-in-directory project-root)))))

  (defun open-eshell-in-directory (dir)
    "Open eshell in the specified directory DIR.
  If an eshell buffer for the directory already exists, switch to it."
    (interactive "DDirectory: ")
    (let* ((eshell-buffer-name (concat "*eshell:" dir "*"))
           (existing-eshell-buffer (get-buffer eshell-buffer-name)))
      (if existing-eshell-buffer
          (switch-to-buffer existing-eshell-buffer)
        (let ((eshell-buffer (eshell 'N)))
          (with-current-buffer eshell-buffer
            (rename-buffer eshell-buffer-name)
            (eshell/cd dir))))))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "M-p") 'SpawnEshellInProjectRoot))

  (defun kill-all-eshell-buffers ()
    "Kill all Eshell buffers."
    (interactive)
    (dolist (buffer (buffer-list))
      (when (string-match-p "^\\*eshell\\*" (buffer-name buffer))
        (kill-buffer buffer))))

#+end_src

** Transpose frame

#+begin_src emacs-lisp

  (use-package transpose-frame)

#+end_src

** Posframe

#+begin_src emacs-lisp

  (use-package vertico-posframe)

#+end_src

** Popper

#+begin_src emacs-lisp

  (defun my/show-popper-echo-line ()
    "Briefly toggle popper to show the echo line."
    (interactive)
    ;; Ensure popper-mode and popper-echo-mode are active
    (when (and popper-mode popper-echo-mode)
      ;; Toggle a popper window and immediately toggle it back
      (popper-toggle-latest)
      (popper-toggle-latest)))

  (use-package popper
    :bind (("M-`" . my/show-popper-echo-line))
           ;; ("M-f"   . popper-toggle))
           ;; ("M-~"   . popper-cycle))
    :init
    (setq popper-window-height 0.33)
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            "*Flymake diagnostics.*"
            "*Flycheck errors.*"
            "\\*compilation\\*"
            "\\*eshell\\*.*"
            "\\*cider-repl.*"
            "\\*cider-doc.*"
            ;; "\\*eshell:.*"
            ;; "\\*Warnings\\*"
            ;; "\\*xref\\*"
            ;; "\\*Backtrace\\*"
            "\\*eldoc\\*"
            ;; "\\*Ement Notifications\\*"
            ;; "Output\\*$"
            ;; "\\*Dtache Shell Command\\*"
            ;; "\\*mu4e-update\\*"
            help-mode
            compilation-mode))
    (popper-mode +1)
    (popper-echo-mode +1))

  (defun m-f-toggle-or-forward-word ()
    "Toggle popper or move forward a word depending on context."
    (interactive)
    (if (window-minibuffer-p)
        (forward-word)
      (popper-toggle)))

  (global-set-key (kbd "M-f") 'm-f-toggle-or-forward-word)

  (defun popper-flymake-diagnostics ()
    "Popper window specifically for Flymake diagnostics buffer."
    (interactive)
    (if (string-match-p "\\*.*Flymake diagnostics.*\\*" (buffer-name))
        (popper-toggle)
      (flymake-show-buffer-diagnostics)))

  (defun popper-flycheck-diagnostics ()
    "Popper window specifically for Flycheck errors buffer."
    (interactive)
    (if (string-match-p "\\*Flycheck errors\\*" (buffer-name))
        (popper-toggle)
      (flycheck-list-errors)))

  ;; (defun fix-cycle ()
  ;;   (interactive)
  ;;   (popper-cycle 1))

  ;; (defun fix-cycle-backwards ()
  ;;   (interactive)
  ;;   (popper-cycle-backwards -1))

  (with-eval-after-load 'evil
    ;;   (define-key evil-normal-state-map (kbd "M-k") 'fix-cycle-backwards)
    ;;   (define-key evil-normal-state-map (kbd "M-j") 'fix-cycle)
    (define-key evil-normal-state-map (kbd "M-t M-m") 'popper-flymake-diagnostics)
    (define-key evil-normal-state-map (kbd "M-t M-c") 'popper-flycheck-diagnostics))

#+end_src

* LANGUAGE SUPPORT

** Flymake

#+begin_src emacs-lisp

#+end_src

** Modes

#+begin_src emacs-lisp

  (use-package raku-mode)
  (use-package go-mode)
  (use-package lua-mode)
  (use-package terraform-mode)
  (use-package dockerfile-mode)
  (use-package haskell-mode)

  (when (require 'dockerfile-mode nil 'noerror)
    ;; Add a hook to automatically use dockerfile-mode for Dockerfiles
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))

  (use-package ansible
    :config
    (add-hook 'yaml-ts-mode-hook '(lambda () (ansible 1))))

  (require 'compile)
  (add-to-list 'compilation-error-regexp-alist
               'yaml)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(yaml "^\\(.*?\\):\\([0-9]+\\)" 1 2)
               )

                                          ; Replace make -k with ansible-lint, with an UTF-8 locale to avoid crashes
  (defun ansible-lint-errors ()
    (make-local-variable 'compile-command)
    (let ((ansiblelint_command "ansible-lint ") (loc "LANG=C.UTF-8 "))
      (setq compile-command (concat loc ansiblelint_command buffer-file-name)))
    )
  (add-hook 'yaml-ts-mode-hook 'ansible-lint-errors)

  ;; (use-package markdown-mode
  ;;   :ensure t
  ;;   :mode ("README\\.md\\'" . gfm-mode)
  ;;   :init (setq markdown-command "multimarkdown")
  ;;   :bind (:map markdown-mode-map
  ;;         ("C-c C-e" . markdown-do)))

  (add-to-list 'auto-mode-alist '("\\.hs\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.hls\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.cabal\\'" . haskell-cabal-mode))

#+end_src

** Flycheck

#+begin_src emacs-lisp

  (defun my/set-flycheck-faces ()
    (with-eval-after-load 'flycheck
      ;; Customize Flycheck error face
      (set-face-attribute 'flycheck-error nil
                          :underline `(:style line :color "#e0def4")) ; rose-pine-gold
      ;; Customize Flycheck warning face
      (set-face-attribute 'flycheck-warning nil
                          :underline `(:style line :color "#f6c177")) ; rose-pine-gold
      ;; Customize Flycheck info (note) face
      (set-face-attribute 'flycheck-info nil
                          :underline `(:style line :color "#c4a7e7")))) ; rose-pine-iris

  (add-hook 'after-init-hook 'my/set-flycheck-faces)

  (use-package flycheck
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode)
    :config
    (my/set-flycheck-faces))

  (defun my/disable-flycheck-in-emacs-lisp-mode ()
    "Disable flycheck in emacs-lisp-mode."
    (setq-local flycheck-disabled-checkers '(emacs-lisp emacs-lisp-checkdoc)))

  (add-hook 'emacs-lisp-mode-hook #'my/disable-flycheck-in-emacs-lisp-mode)

  ;; (use-package flycheck-clj-kondo)

  ;; (with-eval-after-load 'flycheck
  ;;   (flycheck-add-mode 'clj-kondo-clj 'clojure-ts-mode)
  ;;   (flycheck-add-mode 'clj-kondo-cljs 'clojure-ts-mode)
  ;;   (flycheck-add-mode 'clj-kondo-cljc 'clojure-ts-mode)
  ;;   (flycheck-add-mode 'clj-kondo-edn 'clojure-ts-mode))

  ;; (use-package flycheck-raku)

  ;; (use-package flymake-flycheck
  ;;   :after flymake
  ;;   ;; :init
  ;;   ;; (setopt flycheck-disabled-checkers '(python-mypy flymake-flycheck:python-mypy))
  ;;   :config
  ;;   (add-hook 'flymake-mode-hook 'flymake-flycheck-auto))

#+end_src

** Lsp Mode

#+begin_src emacs-lisp

(use-package lsp-mode
  :commands lsp
  :hook ((go-ts-mode . lsp)
         (clojure-ts-mode . lsp)
         (raku-mode . lsp)) ;; Assuming raku-mode is the major mode for Raku files
  :init
  (setq lsp-session-file "~/.emacs.d/.lsp-session-v1")
  (setq lsp-lens-enable nil)
  :config
  ;; Register Go LSP client
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- gopls")
                    :major-modes '(go-ts-mode) ; Corrected to go-mode
                    :server-id 'gopls)) ; Correct server-id for Go

  ;; Register Clojure LSP client
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- clojure-lsp")
                    :major-modes '(clojure-ts-mode) ; Corrected to clojure-mode
                    :server-id 'clojure-lsp)) ; Correct and unique server-id for Clojure

  ;; Register Raku Navigator LSP client
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection
                                     (list "node" "/home/wurfkreuz/.source/RakuNavigator/server/out/server.js" "--stdio"))
                    :major-modes '(raku-mode) ; Ensure this is the correct major mode for Raku
                    :server-id 'raku-navigator)) ; Unique server-id for Raku Navigator

  ;; General LSP settings
  (lsp-signature-mode nil)
  (setq lsp-idle-delay 0.1
        lsp-diagnostics-provider :flymake
        lsp-headerline-breadcrumb-enable nil
        gc-cons-threshold (* 100 1024 1024)
        read-process-output-max (* 1024 1024)
        lsp-log-max 0
        lsp-log-io nil
        lsp-enable-symbol-highlighting nil
        lsp-signature-render-documentation nil
        lsp--last-signature nil
        lsp--last-signature-index nil
        lsp--last-signature-buffer nil
        lsp-signature-auto-activate nil
        lsp-signature-cycle nil
        lsp-signature-doc-lines nil
        lsp-signature-face nil
        lsp-signature-function nil
        lsp-signature-posframe nil
        lsp-eldoc-enable-hover nil
        lsp-eldoc-render-all nil
        lsp-signature-render-documentation nil))

  ;; (use-package lsp-ui
  ;;   :after lsp-mode
  ;;   :config
  ;;   (setq lsp-ui-sideline-enable t
  ;;         lsp-ui-sideline-show-diagnostics t
  ;;         lsp-ui-sideline-show-hover t
  ;;         lsp-ui-sideline-show-code-actions t
  ;;         lsp-ui-doc-enable t
  ;;         lsp-ui-doc-position 'top
  ;;         lsp-ui-doc-include-signature t
  ;;         lsp-ui-peek-enable t
  ;;         lsp-ui-imenu-enable t)
  ;;   (add-hook 'lsp-mode-hook #'lsp-ui-mode)))

  ;; (use-package lsp-mode
  ;; ;; :commands (lsp lsp-deferred)
  ;; :init
  ;; ;; (setenv "LSP_USE_PLISTS" "1")
  ;; ;; Increase the amount of data emacs reads from processes
  ;; ;; (setq read-process-output-max (* 3 1024 1024))
  ;; ;; (setq lsp-clients-clangd-args '("--header-insertion-decorators=0"
  ;; ;;                                 "--clang-tidy"
  ;; ;;                                 "--enable-config"))
  ;; ;; Small speedups
  ;; ;; (setopt lsp-log-max 0)
  ;; ;; (setopt lsp-log-io nil)
  ;; ;; General lsp-mode settings
  ;; ;; (setq ;; lsp-completion-provider :none
  ;;       ;; lsp-enable-snippet t
  ;;       ;; lsp-enable-on-type-formatting nil
  ;;       ;; lsp-enable-indentation nil
  ;;       ;; lsp-diagnostics-provider :flymake
  ;;       ;; lsp-keymap-prefix "C-x L"
  ;;       ;; lsp-eldoc-render-all t)
  ;; ;; to enable the lenses
  ;; ;; (add-hook 'lsp-mode-hook #'lsp-lens-mode)
  ;; ;; (add-hook 'lsp-completion-mode-hook
  ;; ;;           (lambda ()
  ;; ;;             (setf (alist-get 'lsp-capf completion-category-defaults)
  ;; ;;                   '((styles . (orderless))))))

  ;; :config
  ;; (lsp-register-client
  ;; (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- gopls")
  ;;                 :major-modes '(go-mode)
  ;;                 :server-id 'gopls))

  ;; (use-package lsp-ui
  ;;   :after lsp
  ;;   :init
  ;;   (setq lsp-ui-sideline-show-code-actions t)
  ;;   (setq lsp-ui-sideline-show-diagnostics t))
  ;; )

  ;; (use-package lsp-ui
  ;;   :after lsp-mode
  ;;   :init
  ;;   (setq lsp-ui-sideline-show-code-actions t)
  ;;   (setq lsp-ui-sideline-show-diagnostics t))
  ;;   ;; :custom
  ;;   ;; (lsp-ui-doc-position 'bottom) ;; Set the position of the lsp-ui-doc to bottom
  ;;   ;; (lsp-ui-doc-alignment 'window) ;; Align the doc to the window
  ;;   :hook (lsp-mode . lsp-ui-mode))

  ;; ;; (defun my/lsp-ui-doc-hide ()
  ;; ;;   (unless (eq this-command 'lsp-ui-doc-focus-frame)
  ;; ;;     (lsp-ui-doc-hide)))

  ;; (add-hook 'pre-command-hook 'my/lsp-ui-doc-hide)

  ;; (use-package lsp-haskell
  ;;   :ensure t
  ;;   :init
  ;;   (setq lsp-haskell-server-path "haskell-language-server-wrapper")
  ;;   :after lsp
  ;;   :config
  ;;   ;; (setq lsp-haskell-check-parents 'AlwaysCheck)
  ;;   )

  ;;   (use-package corfu
  ;;       :ensure t
  ;;       :bind (("C-." . corfu-next)
  ;;              ("C-," . corfu-prev)))

#+end_src

** Eglot

#+begin_src emacs-lisp

  ;; (use-package eglot-booster
  ;; :elpaca (eglot-booster :host github :repo "jdtsmith/eglot-booster")
  ;; :after eglot
  ;; :config (eglot-booster-mode))

#+end_src

* Org Mode

** General

#+begin_src emacs-lisp

  ;; (org-link-minor-mode 1)
  
  ;; (setq org-startup-folded t) 
  ;; (setq org-emphasis-alist
  ;;       ;; '(("*" bold)
  ;;         '(("/" italic)))
  ;;         ;; ("_" underline)
  ;;         ;; ("=" org-verbatim verbatim)
  ;;         ;; ("~" org-code verbatim)
  ;;         ;; ("+" org-strike-through t)))
  ;;   (define-prefix-command 'my-prefix-map)

  (defun todo ()
    "Open the todo_list.org file located in the ~/.secret_dotfiles/org directory."
    (interactive)
    (find-file (expand-file-name "~/.secret_dotfiles/org/todo_list.org")))

  (defun org-insert-top-level-heading ()
    "Insert a new top-level heading with two empty lines before it."
    (interactive)
    (end-of-line)
    (insert "\n\n\n* ")
    (end-of-line))

  (define-key org-mode-map (kbd "M-o M-h") 'org-insert-top-level-heading)

  ;; (setq org-src-fontify-natively t)

  ;; (defun my/org-show-all-and-refresh ()
  ;;   "Expand all blocks and refresh fontification."
  ;;   (org-show-all '(blocks))
  ;;   (redisplay t))

  ;; (add-hook 'org-mode-hook #'my/org-show-all-and-refresh)

#+end_src

** Org download

#+begin_src emacs-lisp

  (use-package org-download
    :init
    (setq org-download-image-dir "~/.secret_dotfiles/org/images")
    :config
    (add-hook 'org-mode-hook 'org-download-enable)
    (add-hook 'org-mode-hook
              (lambda ()
                (org-display-inline-images))))

#+end_src

** Drill

#+begin_src emacs-lisp

  (use-package org-drill
    :config
    (setq org-drill-maximum-items-per-session 20))

#+end_src

** Agenda

#+begin_src emacs-lisp

  (setq org-agenda-files
        '("~/.secret_dotfiles/org/todo_list.org"))

#+end_src

** Org-roam

#+begin_src emacs-lisp
#+end_src

** Templates

#+begin_src emacs-lisp

  (require 'org-tempo)
  (add-to-list 'org-structure-template-alist '("sb" . "src bash-ts"))
  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sr" . "src raku"))
  (add-to-list 'org-structure-template-alist '("sf" . "src fundamental"))
  (add-to-list 'org-structure-template-alist '("st" . "src text"))
  (add-to-list 'org-structure-template-alist '("ss" . "src sql"))
  (add-to-list 'org-structure-template-alist '("sg" . "src go-ts"))
  (add-to-list 'org-structure-template-alist '("sc" . "src clojure-ts"))

  (add-to-list 'org-structure-template-alist
             '("t" . "src TODO\n\n* TODO \n\n?"))

#+end_src

** Visuals

#+begin_src emacs-lisp

  (setq org-hide-emphasis-markers t)

  (defun toggle-org-emphasis-markers ()
    "Toggle the visibility of Org emphasis markers."
    (interactive)
    (setq org-hide-emphasis-markers (not org-hide-emphasis-markers))
    (org-mode-restart))

  (define-key org-mode-map (kbd "M-o M-t") 'toggle-org-emphasis-markers)

  (add-hook 'org-mode-hook 'prettify-symbols-mode)
    (defun my-org-prettify-symbols ()
    (push '("#+begin_src" . ">") prettify-symbols-alist)
      (push '("#+end_src" . ">") prettify-symbols-alist))

  (eval-after-load 'org
    '(add-hook 'org-mode-hook 'my-org-prettify-symbols))

#+end_src

*** Bullets

#+begin_src emacs-lisp

  (add-hook 'org-mode-hook 'org-indent-mode)
  (use-package org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))

#+end_src

** Source block tag expansion cheat sheet

   | Name | Description |
   |------+-------------|
   | se   | lisp        |
   |------+-------------|
   |      |             |


** Enabling Table of Contents

#+begin_src emacs-lisp

  (use-package toc-org
      :commands toc-org-enable
      :init (add-hook 'org-mode-hook 'toc-org-enable))

#+end_src

** Custom key bindings

#+begin_src emacs-lisp

  (defun org-insert-row-with-floor ()
    "Insert a new row with a 'floor' above in an Org mode table."
    (interactive)
    (org-table-next-field)
    (beginning-of-line)
    (insert "|-")
    (org-table-align)
    (org-return))

  (define-key org-mode-map (kbd "C-c f") 'org-insert-row-with-floor)

  (defun FormatToThreshold (char-threshold)
    "Formats the selected text to not exceed CHAR-THRESHOLD characters per line."
    (interactive "nCharacter Threshold: ")
    (let ((start (region-beginning))
          (end (region-end))
          all-text words formatted-text)
      (save-excursion
        (setq all-text (buffer-substring start end))
        (setq words (split-string all-text))
        (let ((current-line "")
              (current-length 0))
          (dolist (word words)
            (if (> (+ current-length (length word) 1) char-threshold)
                (progn
                  (setq formatted-text (concat formatted-text current-line "\n"))
                  (setq current-line word)
                  (setq current-length (length word)))
              (progn
                (setq current-line (if (string= "" current-line)
                                      word
                                    (concat current-line " " word)))
                (setq current-length (+ current-length (length word) 1)))))
          (setq formatted-text (concat formatted-text current-line)))
        (delete-region start end)
        (goto-char start)
        (insert formatted-text))))

  (defun my/evil-org-open-below (count)
    "Open a new line below the current one and insert a new Org list item if on a list item, otherwise just open a new line."
    (interactive "p")
    (if (org-in-item-p)
        (progn
          (end-of-line)
          (org-insert-item))
      (evil-open-below count)))

  (with-eval-after-load 'evil
    (evil-define-key 'normal org-mode-map
      "o" 'my/evil-org-open-below))

#+end_src

* Keybindings

#+begin_src emacs-lisp

  ;; (global-unset-key (kbd "M-;"))

  (defun my-noop ()
  "A no-op function that does nothing."
  (interactive))

  (global-set-key (kbd "M-;") 'my-noop)

  (global-unset-key (kbd "C-s"))
  (global-unset-key (kbd "M-TAB"))
  (global-set-key (kbd "C-s C-l") 'load-desktop-with-name)
  (global-set-key (kbd "C-s C-s") 'swiper-isearch)
  (global-set-key (kbd "C-s C-q") 'my-sql-connect-with-buffer)
  (global-set-key (kbd "C-s C-b") 'sql-send-buffer)
  (global-set-key (kbd "C-h M-f") 'describe-face)

  (global-unset-key (kbd "C-t"))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "C-t") nil)
    (evil-define-key 'normal 'global (kbd "M-^") 'projectile-run-async-shell-command-in-root)
    (define-key evil-normal-state-map (kbd "gz") 'zoxide-travel)
    (define-key evil-insert-state-map (kbd "C-i h") 'insert-path-from-counsel-fzf-home)
    (define-key evil-insert-state-map (kbd "C-i r") 'insert-path-from-counsel-fzf-root))

  (defun my-org-cycle-or-yasnippet-expand ()
    "Expand Yasnippet or perform org-cycle based on the context."
    (interactive)
    ;; First, try to expand a Yasnippet if possible.
    (unless (yas-expand)
      ;; If no snippet was expanded, call org-cycle.
      ;; This is a more liberal fallback, allowing org-cycle to handle its various contexts.
      (org-cycle)))

  (with-eval-after-load 'evil
    (evil-define-key 'insert global-map (kbd "C-a") 'my-org-cycle-or-yasnippet-expand))

  (with-eval-after-load 'org
    ;; Override the keybinding in org-mode specifically
    (define-key org-mode-map (kbd "M-^") 'projectile-run-async-shell-command-in-root)
    (define-key evil-normal-state-map (kbd "C-t C-s") 'flyspell-mode))

  (global-unset-key (kbd "C-<tab>"))
  (global-set-key (kbd "<C-tab>") 'previous-buffer)

#+end_src

* Custom functions

#+begin_src emacs-lisp

  (defun print-commands-starting-with (input)
    "Print all Emacs commands starting with INPUT to a scratch buffer."
    (interactive "sInput: ")
    (let ((command-list (apropos-internal input 'commandp))
          (output-buffer (get-buffer-create "*Commands*")))
      (with-current-buffer output-buffer
        (erase-buffer)
        (insert (format "Commands starting with '%s':\n\n" input))
        (dolist (command command-list)
          (insert (format "%s\n" command)))
        (goto-char (point-min)))
      (display-buffer output-buffer)))

  ;; Increment
  (defun my/increment-number-at-point (&optional increment)
    "Increment number at point like vim's C-a"
    (interactive "p")
    (my/change-number-at-point '+ (or increment 2)))

  ;; Decrement
  (defun my/decrement-number-at-point (&optional increment)
    "Decrement number at point like vim's C-x"
    (interactive "p")
    (my/change-number-at-point '- (or increment 1)))

  (defun Cp ()
    "Copy the full path of the current buffer's file to the clipboard (or appropriate path)."
    (interactive)
    (let ((path-to-copy nil))
      (cond
       ((eq major-mode 'dired-mode)    ; Dired buffer
        (setq path-to-copy (if (dired-get-file-for-visit)
                               (expand-file-name (dired-get-file-for-visit))
                             (expand-file-name default-directory))))
       ((eq major-mode 'eshell-mode)   ; Eshell buffer
        (setq path-to-copy (eshell/pwd)))
       (t                              ; Default: Regular File buffer
        (setq path-to-copy (buffer-file-name))))
      (if path-to-copy
          (progn
            (kill-new path-to-copy)
            (message "Copied path '%s' to the clipboard." path-to-copy))
        (message "Current buffer has no associated path to copy."))))

  (defun sway ()
    "Open sway config file."
    (interactive)
    (find-file (expand-file-name "~/.dotfiles/sway/config")))

  (defun date ()
    "Display the current date and time in the minibuffer using the shell's 'date' command."
    (interactive)
    (let ((date-output (shell-command-to-string "date")))
      (message (string-trim date-output))))

  (defun off ()
    "Shutdown the system."
    (interactive)
    (call-process "poweroff"))

  (defun reboot ()
    "Reboot the system."
    (interactive)
    (call-process "reboot"))

  (defun notes ()
    "Open org notes directory."
    (interactive)
    (find-file (expand-file-name "~/.secret_dotfiles/org")))

  (defun drill ()
    "Open org notes directory."
    (interactive)
    (find-file (expand-file-name "~/.secret_dotfiles/org/drill")))

  (defun cards ()
    "Open org notes directory."
    (interactive)
    (find-file (expand-file-name "~/.secret_dotfiles/org/drill/general.org")))

  (defun nvm ()
    "Open org notes directory."
    (interactive)
    (find-file (expand-file-name "~/.dotfiles/nvim/lua/user/")))

  (defun emc ()
    "Open a specific file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defun alc ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/zellij/config.kdl"))

  (defun zsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/zsh/.zshrc"))

  (defun bsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/bash/.bashrc"))

  (defun scr ()
    "Open a specific file."
    (interactive)
    (find-file "~/.secret_dotfiles"))

  (defun szsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.secret_dotfiles/zsh/.zshrc"))

  (defun scripts ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/scripts/"))

  (defun so ()
    "Reload the Emacs configuration."
    (interactive)
    (load-file "~/.emacs.d/init.el")
    (load-file "~/.emacs.d/init.el"))

  (with-eval-after-load 'evil
    (evil-ex-define-cmd "so" 'so))

  (defun z (q)
    "Query zoxide and launch dired or change directory in Eshell."
    (interactive "sZoxide: ")
    (if-let
        ((zoxide (executable-find "zoxide"))
         (target
          (with-temp-buffer
            (if (= 0 (call-process zoxide nil t nil "query" q))
                (string-trim (buffer-string))))))
        (if (derived-mode-p 'eshell-mode)
            (eshell/cd target)
          (funcall-interactively #'dired target))
      (unless zoxide (error "Install zoxide"))
      (unless target (error "No Match"))))

  (defun push ()
    "Execute git add, commit, and push in sequence asynchronously."
    (interactive)
    ;; Execute 'push' asynchronously and display output in a separate buffer.
    (async-shell-command "push"))

  (defun s ()
    "Reload the ~/.zshrc file in the current shell."
    (interactive)
    (call-process-shell-command "source ~/.zshrc" nil 0))

  (defun home ()
    "Open a specific file."
    (interactive)
    (find-file "~/"))

  (defun root ()
    "Open a specific file."
    (interactive)
    (find-file "/"))

  (defun theme ()
    "Open a specific file."
    (interactive)
    (find-file "~/.emacs.d/themes/rose-pine-theme.el"))


  (defun trash ()
    "Open a specific file."
    (interactive)
    (find-file "~/.local/share/trash"))

  (defun ngrok ()
    "Open a terminal and execute 'ngrok http http://localhost:8080'."
    (interactive)
    (let ((term-buffer-name "*ngrok-http-8080*"))
      ;; Check if the buffer already exists
      (if (get-buffer term-buffer-name)
          ;; If it does, switch to it
          (switch-to-buffer term-buffer-name)
        ;; Otherwise, create a new terminal and execute the command
        (progn
          (ansi-term "/bin/bash" "ngrok-http-8080")
          (rename-buffer term-buffer-name)
          (comint-send-string nil "ngrok http http://localhost:8080\n")
          (popper-toggle-type)))))

#+end_src
