#+TITLE: Wurfkreuz's GNU Emacs Config
#+AUTHOR: Alex Gud
#+DESCRIPTION: Empty.
#+STARTUP: showeverything ; Wont apply folding
#+OPTIONS: toc:3 ; Table of contents include 3 header levels down

* TABLE OF CONTENTS :toc:
- [[#general-emacs-setting][GENERAL EMACS SETTING]]
  - [[#visual][Visual]]
  - [[#system][System]]
  - [[#custom-commands][Custom Commands]]
  - [[#cursor][Cursor]]
  - [[#find-file][Find-file]]
- [[#packages][PACKAGES]]
  - [[#elpaca-package-manager][Elpaca Package Manager]]
  - [[#evil-mode][Evil Mode]]
  - [[#theme-and-font][Theme and Font]]
  - [[#general][General]]
  - [[#async][Async]]
  - [[#search][Search]]
  - [[#consult][Consult]]
  - [[#acess-to-env-variables][Acess to ENV variables]]
  - [[#treesitter][Treesitter]]
  - [[#sudo-edit][Sudo Edit]]
  - [[#ivy][Ivy]]
  - [[#hydra][Hydra]]
- [[#dired][Dired]]
  - [[#dired-keybindings][Dired keybindings]]
- [[#tramp][Tramp]]
- [[#shells-and-terminals][Shells and Terminals]]
  - [[#eshell][Eshell]]
  - [[#eat][Eat]]
  - [[#cmd][Cmd]]
  - [[#cursor-changer][Cursor changer]]
- [[#database][Database]]
- [[#sessions][Sessions]]
- [[#buffers][Buffers]]
  - [[#windmove][Windmove]]
  - [[#messages-buffer][Messages buffer]]
  - [[#dired-buffer][Dired buffer]]
  - [[#cmd-shell-buffer][Cmd shell buffer]]
  - [[#shell-buffer][Shell buffer]]
  - [[#eshell-buffer][Eshell buffer]]
  - [[#transpose-frame][Transpose frame]]
  - [[#posframe][Posframe]]
  - [[#popper][Popper]]
- [[#language-support][LANGUAGE SUPPORT]]
  - [[#lsp-bridge][Lsp-bridge]]
  - [[#flycheck][Flycheck]]
  - [[#lsp-mode][Lsp Mode]]
- [[#org-mode][ORG MODE]]
  - [[#tuning][Tuning]]
  - [[#bullets][Bullets]]
  - [[#source-block-tag-expansion-cheetsheat][Source Block Tag Expansion Cheetsheat]]
  - [[#enabling-table-of-contents][Enabling Table of Contents]]
  - [[#custom-key-bindings][Custom key bindings]]
- [[#custom-functions][Custom functions]]

* GENERAL EMACS SETTING
** Visual

#+begin_src emacs-lisp

   (menu-bar-mode -1)
   (tool-bar-mode -1)
   (setq inhibit-startup-screen t)
   (setq display-line-numbers 'visual)
   (setq display-line-numbers-type 'relative)

   (defun my-mode-line-major-mode ()
     "Returns a clean name of the current major mode."
     (let ((mode (format "%s" major-mode)))
       (replace-regexp-in-string "-mode$" "" mode)))

   (setq-default mode-line-format
                 '("%e"
                   mode-line-front-space
                   mode-line-buffer-identification  ; Buffer name
                   " "
                   (:eval (my-mode-line-major-mode))  ; Custom major mode display
                   (:eval (propertize " " 'display '(space :align-to (- right 12))))
                   (vc-mode vc-mode)))  ; Git branch information

#+end_src

*** Tabs

#+begin_src emacs-lisp

  (setq tab-bar-close-button-show nil
        tab-bar-new-button-show nil)

  (defun my-tab-name-format-function (tab i)
    (defface my-active-tab-face
      '((t :background "#2e2c3d" :foreground "#e0def4"))  ;; #373c42 - previous background color
      ;; '((t :background "#3c3836" :foreground "#fbf1c7"))  ;; gruvbox-dark hard
      ;; '((t :background "#282c34" :foreground "#bbc2cf"))
      "Face for the active tab.")
    (defface my-inactive-tab-face
        '((t :background "#1d1f21" :foreground "#6e6a86")) ;; #21242b - previous background color
      ;; '((t :background "#1d2021" :foreground "#a89984"))
      ;; '((t :background "#21242b" :foreground "#83898d"))
      "Face for the inactive tab.")
    (let ((current-p (eq (car tab) 'current-tab)))
      (if current-p
          (propertize (format "%d %s" i (alist-get 'name (cdr tab))) 'face 'my-active-tab-face)
        (propertize (format "%d %s" i (alist-get 'name (cdr tab))) 'face 'my-inactive-tab-face))))

  (setq tab-bar-tab-name-format-function #'my-tab-name-format-function)

  (dotimes (i 9)
    (let ((n (1+ i)))  ; Tab numbers start from 1
      (global-set-key (kbd (format "M-%d" n))
                      `(lambda () (interactive) (tab-bar-select-tab ,n)))))

  ;; (defun my-create-or-switch-to-scratch-tab ()
  ;;   "Create a new tab named 'scratch' with a scratch buffer, or switch to an existing 'scratch' tab."
  ;;   (interactive)
  ;;   (let* ((tabs (tab-bar-tabs))
  ;;          (scratch-tab (seq-find (lambda (tab)
  ;;                                   (string= (alist-get 'name tab) "scratch"))
  ;;                                 tabs)))
  ;;     (if scratch-tab
  ;;         (progn
  ;;           (message "Switching to existing 'scratch' tab")
  ;;           (tab-bar-select-tab-by-name "scratch"))
  ;;       (message "Creating a new 'scratch' tab")
  ;;       (tab-bar-new-tab)
  ;;       (tab-bar-rename-tab "scratch")
  ;;       (switch-to-buffer (get-buffer-create "scratch")))))

  ;; (with-eval-after-load 'evil
  ;;   (define-key evil-normal-state-map (kbd "M-f") 'my-create-or-switch-to-scratch-tab))

  ;; (defun tab-bar-tab-exists (name)
  ;;   (member name
  ;;           (mapcar #'(lambda (tab) (alist-get 'name tab))
  ;;                   (tab-bar-tabs))))

    #+end_src

** System

#+begin_src emacs-lisp

  ;; (server-start)
  (global-set-key (kbd "C-x u") 'windmove-up)
  (setq evil-want-keybinding nil)

  (setq vc-follow-symlinks t)

  (setq python-shell-interpreter "/usr/bin/python3")

  (defalias 'yes-or-no-p 'y-or-n-p)

  (add-hook 'before-save-hook 'delete-trailing-whitespace)
  (setq-default indent-tabs-mode nil)
  (savehist-mode 1)

  ;; Executable on save if starts with '#!'
  (add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

  ;; Set directory for undo-tree history files
  (setq undo-tree-auto-save-history t)
  (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo-tree-history"))))
  ;; Set directory for backup files
  (setq desktop-dirname (concat user-emacs-directory "desktop/"))

  ;; Save sessions
  (unless (file-exists-p desktop-dirname)
    (make-directory desktop-dirname))
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
  (desktop-save-mode 1)
  (setq desktop-save 't)
  (setq desktop-path (list desktop-dirname))
  (setq desktop-auto-save-timeout 30)
  (setq desktop-auto-save-timeout nil)

  (global-set-key (kbd "C-c d l") 'load-desktop-with-name)

  (setq save-place-file (concat user-emacs-directory "saveplace/places"))

  ;; Save cursor position
  (unless (file-exists-p (concat user-emacs-directory "saveplace/"))
    (make-directory (concat user-emacs-directory "saveplace/")))
  (save-place-mode 1)

  (scroll-bar-mode -1)
  (pixel-scroll-mode 1)
  (setq-default display-line-numbers-width 3)
  (setq-default scroll-margin 8)
  (setq use-dialog-box nil)
  (set-fringe-mode 0)
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (setq global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode 1)

  (add-to-list 'auto-mode-alist '("\\.hs\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.hls\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.cabal\\'" . haskell-cabal-mode))

  (setq-default truncate-lines t)

  (setenv "PATH" (concat "/home/wurfkreuz/.ghcup/bin:" (getenv "PATH")))

  (setq scroll-conservatively 101)
  (setq scroll-margin 5)
  (setq scroll-step 1)

#+end_src

** Custom Commands

#+begin_src emacs-lisp

  (defun emc ()
    "Open a specific file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defun alc ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/zellij/config.kdl"))

  (defun zsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/zsh/.zshrc"))

  (defun bsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/bash/.bashrc"))

  (defun so ()
    "Reload the Emacs configuration."
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (with-eval-after-load 'evil
    (evil-ex-define-cmd "so" 'so))

  (defun z (q)
    "Query zoxide and launch dired."
    (interactive "sZoxide: ")
    (if-let
        ((zoxide (executable-find "zoxide"))
         (target
          (with-temp-buffer
            (if (= 0 (call-process zoxide nil t nil "query" q))
                (string-trim (buffer-string))))))
        (funcall-interactively #'dired  target)
      (unless zoxide (error "Install zoxide"))
      (unless target (error "No Match"))))

  (defun git-push ()
    "Execute git add, commit, and push in sequence."
    (interactive)
    (let ((output-buffer (get-buffer-create "*Git Push Output*")))
      (with-current-buffer output-buffer
        (erase-buffer))
      (call-process-shell-command "git add . && git commit -m 'n' && git push" nil output-buffer)
      (display-buffer output-buffer)))

  (defun s ()
    "Reload the ~/.zshrc file in the current shell."
    (interactive)
    (call-process-shell-command "source ~/.zshrc" nil 0))

#+end_src

** Cursor

#+begin_src emacs-lisp

  (blink-cursor-mode 0)
  (setq show-paren-delay 0)
  (show-paren-mode 1)

#+end_src

** Find-file

#+begin_src emacs-lisp

  (defun find-file-check-dir (filename &optional wildcards)
    "Edit file FILENAME.
     Switch to a buffer visiting file FILENAME,
     creating one if none already exists.
     If the directory path does not exist, create it."
     (interactive
      (find-file-read-args "Find file: " nil))
     (let ((dir (file-name-directory filename)))
       (when (not (file-exists-p dir))
 	(make-directory dir t)))
     (find-file filename wildcards))

#+end_src

* PACKAGES
** Elpaca Package Manager

#+begin_src emacs-lisp

  (defvar elpaca-installer-version 0.7)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
			  :ref nil
			  :files (:defaults (:exclude "extensions"))
			  :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
   (build (expand-file-name "elpaca/" elpaca-builds-directory))
   (order (cdr elpaca-order))
   (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
    (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
	     ((zerop (call-process "git" nil buffer t "clone"
				   (plist-get order :repo) repo)))
	     ((zerop (call-process "git" nil buffer t "checkout"
				   (or (plist-get order :ref) "--"))))
	     (emacs (concat invocation-directory invocation-name))
	     ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
				   "--eval" "(byte-recompile-directory \".\" 0 'force)")))
	     ((require 'elpaca))
	     ((elpaca-generate-autoloads "elpaca" repo)))
	(kill-buffer buffer)
      (error "%s" (with-current-buffer buffer (buffer-string))))
  ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
     ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable :elpaca use-package keyword.
    (elpaca-use-package-mode)
    ;; Assume :elpaca t unless otherwise specified.
    (setq elpaca-use-package-by-default t))

  ;; Block until current queue processed.
  (elpaca-wait)
   (setq package-enable-at-startup nil)

#+end_src

** Evil Mode

#+begin_src emacs-lisp

  (use-package undo-tree
    :config
    (global-undo-tree-mode))

  ;; (use-package evil
  ;;   :init
  ;;   (setq evil-want-C-u-scroll t
  ;;         evil-want-C-i-jump nil
  ;;         evil-want-integration t)
  ;;   :config
  ;;   (evil-mode 1)
  ;;   (evil-set-initial-state 'custom-theme-choose-mode 'normal)
  ;;   (setq evil-shift-width 2)
  ;;   (add-hook 'evil-mode-hook 'undo-tree-mode))

  ;; (add-hook 'after-init-hook
  ;;         (lambda ()
  ;;           (add-hook 'evil-local-mode-hook 'turn-on-undo-tree-mode)))

  (use-package evil
  :init
  (setq evil-want-C-u-scroll t
        evil-want-C-i-jump nil
        evil-want-integration t
        evil-undo-system 'undo-tree) ;; Move this line here
  :config
  (evil-mode 1)
  (evil-set-initial-state 'custom-theme-choose-mode 'normal)
  (setq evil-shift-width 2))

  (add-hook 'term-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'eat-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'eshell-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'wdired-mode-hook (lambda () (undo-tree-mode 1)))


  (setq evil-undo-system 'undo-tree)

  (use-package evil-commentary
    :config
    (evil-commentary-mode))

  (use-package evil-org
    :after org
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme)))
    )
  ;; :ensure nil)

  (use-package evil-collection
    :after evil
    :init ;;    (setq evil-want-keybinding nil)
    :config
    (setq evil-collection-mode-list '(dashboard eshell dired wdired ibuffer org emacs-eat term ansi lsp-ui-imenu))
    (evil-collection-init))


  (add-hook 'text-mode-hook 'display-line-numbers-mode)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  (defun my-eshell-evil-yank-to-end-of-line ()
    "Yank text from the current point to the end of the line in Eshell."
    (interactive)
    (evil-yank (point) (line-end-position)))

  (with-eval-after-load 'eshell
    (require 'evil)
    (evil-define-key 'normal eshell-mode-map (kbd "Y") 'my-eshell-evil-yank-to-end-of-line))

#+end_src

*** Custom keybindings

#+begin_src emacs-lisp

  (with-eval-after-load 'evil
    (define-key evil-insert-state-map (kbd "C-S-v") 'yank)
    (define-key evil-visual-state-map (kbd "{") 'evil-backward-paragraph)
    (define-key evil-visual-state-map (kbd "}") 'evil-forward-paragraph)
    (define-key evil-insert-state-map (kbd "M-f") 'evil-forward-word-begin)
    (define-key evil-insert-state-map (kbd "M-b") 'evil-backward-word-begin)

    (define-key evil-normal-state-map (kbd "gq") 'FormatToThreshold)
    (define-key evil-visual-state-map (kbd "gq") 'FormatToThreshold))


#+end_src

** Theme and Font

#+begin_src emacs-lisp

  ;; (require 'color)
  ;;  (hl-line-mode 1)

  (add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))(put 'eval 'safe-local-variable #'identity)
  (load-theme 'rose-pine t)

  ;; (use-package gruvbox-theme
  ;;   :config
  ;;   (load-theme 'gruvbox-dark-hard t))

  ;; (use-package doom-themes
  ;;   :ensure t
  ;;   :config
  ;;   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
  ;;         doom-themes-enable-italic nil) ; if nil, italics is universally disabled
  ;;   (load-theme 'doom-one t)
  ;;   ;Corrects (and improves) org-mode's native fontifcation.
  ;;   (doom-themes-org-config))

  (when (member "NotoSansM Nerd Font Mono" (font-family-list))
    (set-face-attribute 'default nil :font "NotoSansM Nerd Font Mono-12:weight=medium")
    )

#+end_src

*** Icons

#+begin_src emacs-lisp

  (use-package all-the-icons
    :ensure t
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))

#+end_src

** General

#+begin_src emacs-lisp

  (use-package general
    :config
    (general-evil-setup)

  ;; "C-M-j" 'counsel-switch-buffer

  ;; set up 'SPC' as the global leader key
  (general-create-definer w/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "M-SPC") ;; access leader in insert mode

  (w/leader-keys

    ;; Fuzzy finder
    "fd" '(counsel-find-file-check-dir :wk "Find file modified")
    "fb" '(counsel-switch-buffer :wk "Choose and switch to an active buffer")
    "fe" '(OpenDiredBufferInCurrentWindow :wk "Open a full screen dired buffer in a current window")
    "ff" '(projectile-find-file :wk "Find file fuzzy finder with a git directory as an anchor")
    ;; "fh" '(fzf-from-home-no-prompt :wk "Fzf with fd and hidden files from a home directory")
    "ft" '(fzf-from-current-with-fd :wk "Fzf with fd and hidden files with a prompt from a current directory")
    "fh" '(fzf-from-home-with-fd :wk "Fzf with fd and hidden files with an ability to change the searching point")
    "fr" '(fzf-from-root-with-fd :wk "Fzf with fd and hidden files form root")

    ;; Session management
    "ss" '(save-current-desktop-session :wk "Save the current desktop session into its corresponding directory")
    "sd" '(delete-desktop-session :wk "Delete selected session")
    "sl" '(load-desktop-with-name :wk "Load a desktop session by name, chosen from available sessions")
    "sr" '(rename-desktop-session :wk "Rename a desktop session")

    ;; Tab management
    "tn" '(tab-bar-new-tab :wk "Create a new tab")
    "tx" '(tab-bar-close-tab :wk "Close a tab")
    "tr" '(tab-bar-rename-tab :wk "Rename a tab")

    "w"  'hydra-window-size/body

    ;; Window swapping
    "bk" '(buf-move-up :wk "Swap with buffer above")
    "bj" '(buf-move-down :wk "Swap with buffer below")
    "bh" '(buf-move-left :wk "Swap with buffer left")
    "bl" '(buf-move-right :wk "Swap with buffer right")

    "bc" '(kill-buffer :wk "Close selecetd buffer")

    "mm" '(open-messages-buffer-in-split :wk "Open the *Messages buffer")

    "xx" '(kill-buffer-and-window :wk "Close buffer with its window")

    "pp" '(git-push :wk "Activate an elisp copy of the git push alias")

    "cc" '(RunCmdShellCommand :wk "Run CMD command")
    "ch" '(my-hoogle-search :wk "Hoogle search prompt in the shell cmd")

    ;; "ts" '(SpawnShellSplitBelow :wk "Spawn shell below")

    "zz" '(z :wk "Call zoxide prompt")

    "vv" '(OpenVtermBelow :wk "Toggle vterm")

    "dd" '(OpenDiredBufferInSplit :wk "Open Dired buffer in split")
    "de" '(wdired-change-to-wdired-mode :wk "Switch to wdired mode")

    "ld" '(lsp-find-definition :wk "Open diagnostic list in a separate split")
    ;; "lk" '(lsp-describe-thing-at-point :wk "Open a hover window")
    "lk" '(lsp-ui-doc-show :wk "Show hover documentation")
    ;; "ld" '(lsp-bridge-diagnostic-list :wk "Open diagnostic list in a separate split")
    ;; "lk" '(lsp-bridge-popup-documentation :wk "Open a hover window")

    "ee" '(SpawnEshellSplitBelow :wk "Create a new lessend eshell window under a current one")
    "es" '(eshell :wk "Eshell")

    ;; Evaluation
    "e" '(:ignore t :wk "Evaluate/Eshell")
    "eb" '(eval-buffer :wk "Evaluate elisp in buffer")
    "ed" '(eval-defun :wk "Evaluate defun containing or after point")
    "ex" '(eval-expression :wk "Evaluate and elisp expression")
    "el" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "er" '(eval-region :wk "Evaluate elisp in region")

    ;; Eshell
    "es" '(counsel-esh-history :wk "Eshell history")
    ;; "ef" '(vertico-buffers/eshell :wk "test")

        )
    (dotimes (i 9)
        (let ((n (1+ i))) ; Tab numbers start from 1
          (general-def
            :states '(normal emacs)
            :keymaps 'override
            :prefix "SPC"
            (format "%d" n) `(lambda () (interactive) (tab-bar-select-tab ,n)))))
  )

#+end_src

** Async

#+begin_src emacs-lisp

  (use-package async
    :config
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1))

#+end_src

** Search

#+begin_src emacs-lisp

  (use-package rg
   :config
   (rg-enable-default-bindings))

#+end_src

** Consult

#+begin_src emacs-lisp

  ;; (use-package consult)

  ;; (defun consult-fd-from-home ()
  ;;   "Starts a consult-find search from the user's home directory using fd,
  ;; including hidden files and excluding certain directories."
  ;;   (interactive)
  ;;   (let ((consult-find-command "fd --hidden --exclude .git --color=never --full-path"))
  ;;     (consult-find "~/")))

#+end_src
** Acess to ENV variables

#+begin_src emacs-lisp

  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))

#+end_src

** Treesitter

#+begin_src emacs-lisp

  (use-package treesit-auto
    :config
    (treesit-auto-add-to-auto-mode-alist
    '(("\\.py$" . python-ts-mode)
      ("\\.rb$" . ruby-ts-mode)
      ("\\.go$" . go-ts-mode)
      ("\\.bashrc\\'" . shell-mode)
      ("\\.zshrc\\'" . shell-mode))) ; Removed the extra parentheses here
    (global-treesit-auto-mode))

  ;; (setq treesit-language-source-alist
  ;;       '((yaml "https://github.com/tree-sitter/tree-sitter-yaml")
  ;;         (go "https://github.com/tree-sitter/tree-sitter-go")
  ;;         (python "https://github.com/tree-sitter/tree-sitter-python")
  ;;         (toml "https://github.com/tree-sitter/tree-sitter-toml")
  ;;         (bash "https://github.com/tree-sitter/tree-sitter-bash")))

  ;; (dolist (lang treesit-language-source-alist)
  ;;   (unless (treesit-language-available-p (car lang))
  ;;     (treesit-install-language-grammar (car lang))))

  ;; (defun my-treesitter-hooks ()
  ;;   (when (equal major-mode 'fundamental-mode)
  ;;     (let ((filename (buffer-file-name)))
  ;;       (cl-case filename
  ;;         (".py$" (python-ts-mode))
  ;;         (".go$" (go-ts-mode))
  ;;         (".bashrc$" (bash-ts-mode))
  ;;         (".bashrc$" (bash-ts-mode))
  ;;         ; Add more cases as needed
  ;;         ))))

  ;; (add-hook 'find-file-hook 'my-treesitter-hooks)

#+end_src

** Sudo Edit

#+begin_src emacs-lisp

  (use-package sudo-edit
    :config
      (w/leader-keys
         "sf" '(sudo-edit-find-file :wk "Sudo find file")
         "se" '(sudo-edit :wk "Sudo edit file")))

#+end_src

** Ivy

#+begin_src emacs-lisp

  (use-package projectile
    :config
    (projectile-mode 1))

  (use-package counsel
    :after ivy
    :config
    (counsel-mode))
    ;; (push '(counsel-esh-history . ivy-display-function-fallback) ivy-display-functions-alist))

  (use-package ivy
    :bind
    ;; ivy-resume resumes the last Ivy-based completion.
    (("C-c C-r" . ivy-resume)
     ("C-x B" . ivy-switch-buffer-other-window))
    :custom
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq enable-recursive-minibuffers t)
    :config
    (ivy-mode))

  (use-package ivy-posframe
    :ensure t
    :after ivy
    :config
    (ivy-posframe-mode 1))
    (setq ivy-posframe-width 50)
    (setq ivy-posframe-display-functions-alist
        '((counsel-esh-history . ivy-posframe-display-at-window-center)))

  ;; To display icons correctly, you should run M-x all-the-icons-install-fonts to install the necessary fonts.
  (use-package all-the-icons-ivy-rich
    :init
    (all-the-icons-ivy-rich-mode 1))

  (use-package ivy-rich
    :after ivy
    :ensure t
    :init (ivy-rich-mode 1) ;; this gets us descriptions in M-x.
    :custom
    (ivy-virtual-abbreviate 'full
                            ivy-rich-switch-buffer-align-virtual-buffer t
                            ivy-rich-path-style 'abbrev))

  (defun counsel-find-file-check-dir ()
    "Like `counsel-find-file', but use `find-file-check-dir' instead of `find-file'."
    (interactive)
    (let* ((current-dir (if (eq major-mode 'dired-mode)
                            "."
                            (buffer-file-name))))
      (ivy-read "Find file: " #'read-file-name-internal
                :matcher #'counsel--find-file-matcher
                :action #'find-file-check-dir
                :preselect current-dir
                :require-match 'confirm-after-completion
                :history 'file-name-history
                :keymap counsel-find-file-map
                :caller 'counsel-find-file)))

  (global-set-key (kbd "C-x f") 'counsel-find-file-check-dir)

#+end_src

*** Fzf

#+begin_src emacs-lisp

  (use-package fzf)

  (defun fzf-from-home-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
      and exclude certain directories but with an ability to interactively change
      the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    (let ((default-directory "~/"))
      (fzf-directory)))

    (defun fzf-from-root-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
      and exclude certain directories but with an ability to interactively change
      the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")
    (let ((default-directory "/"))
      (fzf-directory)))

   ;; (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")

  (defun fzf-from-root-no-prompt ()
    "Starts fzf from the user's root directory using fd to include hidden files
    and exclude certain directories without prompting for a directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")
    (fzf))

  (defun fzf-from-home-no-prompt ()
    "Starts fzf from the user's home directory using fd to include hidden files
    and exclude certain directories without prompting for a directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git . /home/wurfkreuz")
    (fzf))

  (defun fzf-from-current-with-fd ()
    "Starts fzf from the current directory using fd to include hidden files
   and exclude certain directories. Works both locally and on remote servers."
    (interactive)
    ;; Set the FZF_DEFAULT_COMMAND environment variable
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    ;; Check if the current directory is a TRAMP directory
    (let ((tramp-address (file-remote-p default-directory)))
      (if tramp-address
          ;; If we're in a TRAMP directory, use the extracted address
          (fzf-directory tramp-address)
        ;; If not in a TRAMP directory, use the local home directory
        (fzf-directory "~/"))))

  (setq fzf/args "-x --color bw --print-query --margin=1,0 --no-hscroll --inline-info --bind ctrl-n:down,ctrl-p:up")

#+end_src

** Hydra

#+begin_src emacs-lisp

  ;; (use-package hydra
  ;;   :config
  ;;   (defhydra hydra-window-size (:color red)
  ;;     "window size"
  ;;     ("h" (lambda () (interactive) (shrink-window-horizontally 5)) "shrink horizontally")
  ;;     ("l" (lambda () (interactive) (enlarge-window-horizontally 5)) "enlarge horizontally")
  ;;     ("k" (lambda () (interactive) (shrink-window 3)) "shrink vertically")
  ;;     ("j" (lambda () (interactive) (enlarge-window 3)) "enlarge vertically")
  ;;     ("t" transpose-frame "transpose windows")
  ;;     ("q" nil "quit")))

  (defun my-enlarge-window-horizontally ()
    "Enlarge the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (shrink-window-horizontally 5)
      (enlarge-window-horizontally 5)))

  (defun my-shrink-window-horizontally ()
    "Shrink the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (enlarge-window-horizontally 5)
      (shrink-window-horizontally 5)))

  (use-package hydra
    :config
    (defhydra hydra-window-size (:color red)
      "window size"
      ("h" my-shrink-window-horizontally "shrink horizontally")
      ("l" my-enlarge-window-horizontally "enlarge horizontally")
      ("k" (lambda () (interactive) (shrink-window 3)) "shrink vertically")
      ("j" (lambda () (interactive) (enlarge-window 3)) "enlarge vertically")
      ("t" transpose-frame "transpose windows")
      ("q" nil "quit")))

#+end_src

* Dired

#+begin_src emacs-lisp

  ;; (add-hook 'dired-mode-hook
  ;;         (lambda ()
  ;;           (wdired-change-to-wdired-mode)))

  (setq delete-by-moving-to-trash t
        trash-directory "~/.local/share/trash")

  (setq wdired-allow-to-create-files t)
  (setq wdired-allow-to-change-permissions t)

  (setq evil-move-cursor-back nil)
  (add-hook 'wdired-mode-hook #'evil-normal-state)

#+end_src


** Dired keybindings

#+begin_src emacs-lisp

  ;; (evil-define-key 'normal dired-mode-map
  ;;   (kbd "+") 'dired-create-directory))

#+end_src

* Tramp

#+begin_src emacs-lisp

  (require 'tramp)

  (setq tramp-ssh-controlmaster-options (format "-i %s" "~/.ssh/git"))
  (add-to-list 'tramp-connection-properties
               (list (regexp-quote "/ssh:")
                     "direct-async-process" t))

  ;; cache file-name forever
  (setq remote-file-name-inhibit-cache nil)

  ;; make sure vc stuff is not making tramp slower
  (setq vc-ignore-dir-regexp
        (format "%s\\|%s"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))

  ;; not sure why we have this? just cargo-culting from an answer I saw
  ;; online.
  (setq tramp-verbose 1)

  ;; projectile has the fun side-effect of wanting to calculate the
  ;; project name, which makes tramp oh-so-much-slower.
  (setq projectile-mode-line "Projectile")

#+end_src

* Shells and Terminals
** Eshell

#+begin_src emacs-lisp

  (use-package eshell-syntax-highlighting
    :after esh-mode
    :config
    (eshell-syntax-highlighting-global-mode +1))

  (setq eshell-rc-script (concat user-emacs-directory "eshell/eshelrc")
        eshell-aliases-file (concat user-emacs-directory "eshell/aliases")
        eshell-history-size 1000000
        eshell-buffer-maximum-lines 5000
        eshell-save-history-on-exit t
        eshell-history-file-name "~/.emacs.d/eshell_history"
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t
        eshell-destroy-buffer-when-process-dies t
        eshell-banner-message ""
        eshell-visual-commands'("bash" "fish" "htop" "ssh" "top" "zsh"))

  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local scroll-margin 0)))

  (defun eshell-insert-last-argument ()
    "Insert the last argument of the previous command."
    (interactive)
    (let* ((last-command (eshell-previous-input-string 0))
           (args (split-string-and-unquote last-command))
           (last-arg (car (last args))))
      (when last-arg
        (insert last-arg))))

  (defun setup-eshell-keys ()
    (define-key eshell-mode-map (kbd "M-.") 'eshell-insert-last-argument))
  ;; (define-key eshell-mode-map (kbd "M-r") 'counsel-esh-history))

  (add-hook 'eshell-mode-hook 'setup-eshell-keys)

  (with-eval-after-load 'evil
    (evil-define-key 'insert eshell-mode-map (kbd "M-r") 'counsel-esh-history)
    (evil-define-key 'normal eshell-mode-map (kbd "M-r") 'counsel-esh-history))

  ;; (defun my/counsel-file-jump ()
  ;;   "Jump to a file beneath the current directory using a custom find command to avoid permission errors."
  ;;   (interactive)
  ;;   (let ((default-directory "/")
  ;;         (counsel-file-jump-args '("-type" "f" "-not" "-path" "*/\\.*" "-not" "-path" "./proc/*" "-not" "-path" "./sys/*" "-not" "-path" "./dev/*" "-not" "-path" "./run/*" "-print")))
  ;;     (counsel-file-jump)))

  (defun eshell/edit (filename)
    "Open FILENAME in the current buffer, using the current TRAMP address."
    (interactive "sEnter the filename to edit: ")
    ;; Extract the current TRAMP address from the Eshell buffer's default directory
    (let ((tramp-address (file-remote-p default-directory)))
      (if tramp-address
          ;; If we're in a TRAMP directory, use the extracted address
          (find-file (concat tramp-address filename))
        ;; If not in a TRAMP directory, fall back to a default address or prompt the user
        (message "Not in a TRAMP directory. Please specify the TRAMP address manually.")
        ;; Optionally, you can add a fallback mechanism here, e.g., prompting the user for a TRAMP address
        )))

  (defalias 'e 'eshell/edit)

  (require 'em-tramp) ; to load eshellâ€™s sudo
  ;; (setq eshell-prefer-lisp-functions t)
  ;; (setq eshell-prefer-lisp-variables t)
  ;; (setq password-cache t) ; enable password caching
  ;; (setq password-cache-expiry 10)
  ;; (add-hook 'eshell-load-hook (lambda () (add-to-list 'eshell-modules-list 'eshell-tramp)))

#+end_src

** Eat

#+begin_src emacs-lisp

  (add-to-list 'load-path "~/.emacs.d/lisp/emacs-eat")
  (require 'eat)

  (add-hook 'eshell-first-time-mode-hook
            #'eat-eshell-visual-command-mode)
  (add-hook 'eshell-first-time-mode-hook #'eat-eshell-mode)

#+end_src

** Cmd

#+begin_src emacs-lisp

  (defun my-hoogle-search (query)
    "Search Hoogle for QUERY."
    (interactive "sHoogle search: ") ; Prompt for the search term
    (shell-command (concat "hoogle search " (shell-quote-argument query))))

#+end_src

** Cursor changer

#+begin_src emacs-lisp

  (use-package evil-terminal-cursor-changer
    :config
    (unless (display-graphic-p)
      (require 'evil-terminal-cursor-changer)
      (evil-terminal-cursor-changer-activate) ; or (etcc-on)
      )
    )

#+end_src

* Database

#+begin_src emacs-lisp

  ;; (use-package emacs-edbi
  ;;   :ensure t   ;; Ensure the package is installed
  ;;   ;; :config     ;; Optional: Add your configuration here
  ;;   ;;   ;; Example configuration:
  ;;   ;;   (setq edbi-default-connection-alist
  ;;   ;;         '(("my-db" . ("localhost" 3306 "my_database"))))
  ;; )

#+end_src

* Sessions

#+begin_src emacs-lisp

  (defvar current-desktop-session-name nil
    "The name of the currently loaded desktop session.")

  (defvar desktop-autosave-timer nil
    "Timer object for desktop autosave, to avoid multiple timers running.")

  (defun save-eshell-buffer (desktop-dirname)
    ;; Save the current working directory.
    default-directory)

  (defun restore-eshell-buffer (_file-name buffer-name misc)
    "MISC is the value returned by `save-eshell-buffer'.
  _FILE-NAME is nil."
    (let ((default-directory misc))
      ;; Create an eshell buffer named BUFFER-NAME in directory MISC.
      (eshell buffer-name)))

  ;; Save all eshell-mode buffers.
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local desktop-save-buffer #'save-eshell-buffer)))

  ;; Restore all eshell-mode buffers.
  (add-to-list 'desktop-buffer-mode-handlers '(eshell-mode . restore-eshell-buffer))

  (defun save-current-desktop-session (&optional manual-save)
    "Save the current desktop session using the current session name.
  If no session is loaded, prompt to create a new one. If MANUAL-SAVE is non-nil, show a message for existing sessions."
    (interactive "p") ; "p" passes a prefix argument, which is non-nil when called interactively
    (if current-desktop-session-name
        (let ((desktop-dir (concat user-emacs-directory "desktop/" current-desktop-session-name "/")))
          (unless (file-exists-p desktop-dir)
            (make-directory desktop-dir))
          (desktop-save desktop-dir)
          (when manual-save
            (message "Session '%s' saved." current-desktop-session-name)))
      ;; No session is loaded, prompt to create a new one
      (let ((new-session-name (read-string "Enter new session name: ")))
        (unless (string-empty-p new-session-name)
          (let ((new-desktop-dir (concat user-emacs-directory "desktop/" new-session-name "/")))
            (make-directory new-desktop-dir t)
            (setq current-desktop-session-name new-session-name)
            (desktop-save new-desktop-dir))))))

  (defun load-desktop-session (session-name)
    "Load a desktop session by name."
    (let ((desktop-dir (concat user-emacs-directory "desktop/")))
      (setq current-desktop-session-name session-name)
      (desktop-change-dir (concat desktop-dir session-name "/"))
      ;; Set up the autosave timer when a new session is loaded
      (when desktop-autosave-timer
        (cancel-timer desktop-autosave-timer))
      (setq desktop-autosave-timer (run-with-timer 0 30 'save-current-desktop-session))))

  (defun load-desktop-with-name ()
    "Load a desktop session by name, chosen from available sessions."
    (interactive)
    (when current-desktop-session-name
      ;; Save the current session before loading a new one, but only if a session is already loaded.
      (save-current-desktop-session))
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
           (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
           (session-name (completing-read "Choose desktop session: " session-dirs nil t)))
      (setq current-desktop-session-name session-name)  ; Save the session name globally
      (desktop-change-dir (concat desktop-dir session-name "/"))
      ;; Set up the autosave timer when a new session is loaded
      (when desktop-autosave-timer
        (cancel-timer desktop-autosave-timer))
      (setq desktop-autosave-timer (run-with-timer 0 30 'save-current-desktop-session))))

  ;; Disable the default desktop save mode
  (desktop-save-mode 0)

  (defun delete-desktop-session ()
    "Delete a desktop session by name, chosen from available sessions."
    (interactive)
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
           (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
           (session-name (completing-read "Choose desktop session to delete: " session-dirs nil t)))
      (when (yes-or-no-p (format "Are you sure you want to delete the '%s' session? " session-name))
        (let ((session-path (concat desktop-dir session-name)))
          (if (file-directory-p session-path)
              (progn
                (delete-directory session-path t)  ; 't' for recursive delete
                (message "Deleted desktop session '%s'." session-name))
            (message "No such desktop session '%s'." session-name))))))

  (defun rename-desktop-session ()
    "Renames the currently loaded desktop session."
    (interactive)
    ;; Check if there's a session loaded.
    (if (not current-desktop-session-name)
        (message "No desktop session is currently loaded.")
      (let* ((new-name (read-string "New session name: "))
             (old-dir (concat user-emacs-directory "desktop/" current-desktop-session-name))
             (new-dir (concat user-emacs-directory "desktop/" new-name)))
        ;; Check if the new session name is empty or the session already exists.
        (if (or (string-empty-p new-name)
                (file-exists-p new-dir))
            (message "Invalid new session name or session already exists.")
          ;; Rename the directory and update the session name.
          (rename-file old-dir new-dir)
          (setq current-desktop-session-name new-name)
          (message "Session renamed to '%s'." new-name)))))

#+end_src

* Buffers
** Windmove

#+begin_src emacs-lisp

  (require 'windmove)

   ;;;###autoload
  (defun buf-move-up ()
   "Swap the current buffer and the buffer above the split.
   If there is no split, ie now window above the current one, an
   error is signaled."
     ;;  "Switches between the current buffer, and the buffer above the
     ;;  split, if possible."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'up))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No window above this one")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-down ()
   "Swap the current buffer and the buffer under the split.
   If there is no split, ie now window under the current one, an
   error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'down))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (or (null other-win)
 	      (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
 	  (error "No window under this one")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-left ()
   "Swap the current buffer and the buffer on the left of the split.
   If there is no split, ie now window on the left of the current
   one, an error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'left))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No left split")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-right ()
   "Swap the current buffer and the buffer on the right of the split.
   If there is no split, ie now window on the right of the current
   one, an error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'right))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No right split")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

#+end_src

** Messages buffer

#+begin_src emacs-lisp

  (defun open-messages-buffer-in-split ()
    (interactive)
    (switch-to-buffer "*Messages*"))

#+end_src

** Dired buffer

#+begin_src emacs-lisp

  (defun OpenDiredBufferInSplit ()
     "Open a Dired buffer in a vertical split on the right, showing the directory of the current buffer."
     (interactive)
     (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
       (split-window-right)
       (windmove-right)
       (dired current-dir)))

  (defun OpenDiredBufferInCurrentWindow ()
     "Open a Dired buffer in the current window, showing the directory of the current buffer."
     (interactive)
     (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
       (dired current-dir)))

#+end_src

** Cmd shell buffer

#+begin_src emacs-lisp

  (defun RunCmdShellCommand ()
    "Prompt for and run a CMD shell command."
    (interactive)
    (let ((cmd (read-shell-command "Run CMD command: ")))
      (shell-command cmd)))

#+end_src

** Shell buffer

#+begin_src emacs-lisp

  (defun my-shell-mode-hook ()
    (setq-local scroll-margin 0))

  (add-hook 'shell-mode-hook 'my-shell-mode-hook)

  (setq explicit-shell-file-name "/usr/bin/bash")  ; your shell path here
  (setq explicit-bash-args '("--login" "-i"))

  (defun SpawnShellSplitBelow ()
    "Open a shell in a small split below."
    (interactive)
    (split-window-below -10)
    (other-window 1)
    (shell))

#+end_src

** Eshell buffer

#+begin_src emacs-lisp

  ;; (defun SpawnEshellSplitBelow ()
  ;;   "Open a shell in a small split below."
  ;;   (interactive)
  ;;   (split-window-below -10)
  ;;   (other-window 1)
  ;;   (open-eshell-in-current-directory))

  ;; (defun open-eshell-in-current-directory ()
  ;;   "Open eshell in the directory of the current buffer."
  ;;   (interactive)
  ;;   (let* ((buffer-dir (if (buffer-file-name)
  ;;                         (file-name-directory (buffer-file-name))
  ;;                       default-directory))
  ;;         (eshell-buffer (eshell 'N)))
  ;;     (with-current-buffer eshell-buffer
  ;;       (eshell/cd buffer-dir))))

  (defvar
    eshell-toggle-window-configuration nil
    "Variable to store the window configuration before opening eshell.")

  (defvar eshell-toggle-selected-window nil
    "Variable to store the selected window before opening eshell.")

  (defun SpawnEshellSplitBelow ()
    "Open a shell in a small split below or toggle it if already open."
    (interactive)
    (if (eq major-mode 'eshell-mode)
        (progn
          (when eshell-toggle-window-configuration
            (set-window-configuration eshell-toggle-window-configuration)
            (setq eshell-toggle-window-configuration nil))
          (when eshell-toggle-selected-window
            (select-window eshell-toggle-selected-window)
            (setq eshell-toggle-selected-window nil)))
      (setq eshell-toggle-window-configuration (current-window-configuration))
      (setq eshell-toggle-selected-window (selected-window))
      (split-window-below -10)
      (other-window 1)
      (open-eshell-in-current-directory)))

  (defun open-eshell-in-current-directory ()
    "Open eshell in the directory of the current buffer.
  If an eshell buffer for the directory already exists, switch to it."
    (interactive)
    (let* ((buffer-dir (if (buffer-file-name)
                           (file-name-directory (buffer-file-name))
                         default-directory))
           (eshell-buffer-name (concat "*eshell:" buffer-dir "*"))
           (existing-eshell-buffer (get-buffer eshell-buffer-name)))
      (if existing-eshell-buffer
          (switch-to-buffer existing-eshell-buffer)
        (let ((eshell-buffer (eshell 'N)))
          (with-current-buffer eshell-buffer
            (rename-buffer eshell-buffer-name)
            (eshell/cd buffer-dir))))))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "M-e") 'SpawnEshellSplitBelow))

  (defun kill-all-eshell-buffers ()
    "Kill all Eshell buffers."
    (interactive)
    (dolist (buffer (buffer-list))
      (when (string-match-p "^\\*eshell\\*" (buffer-name buffer))
        (kill-buffer buffer))))

#+end_src

** Transpose frame

#+begin_src emacs-lisp

  (use-package transpose-frame)

#+end_src

** Posframe

#+begin_src emacs-lisp

  (use-package vertico-posframe)

#+end_src

** Popper

#+begin_src emacs-lisp

  (use-package popper
    :config
    (popper-mode 1))

  (defun my-popper-toggle ()
    "Toggle the Popper window and resize it to one-third of the frame height."
    (interactive)
    (popper-toggle))

  (defun my-popper-and-resize-new ()
    "Toggle the Popper window and resize it to one-third of the frame height."
    (interactive)
    (open-eshell-in-current-directory)
    ;; (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
    ;;   (dired current-dir))
    (popper-toggle-type))

  (defun fix-cycle ()
    (interactive)
    (popper-cycle 1))

  (defun fix-cycle-backwards ()
    (interactive)
    (popper-cycle-backwards -1))

  ;; (with-eval-after-load 'evil
  ;;   (define-key evil-normal-state-map (kbd "M-k") 'fix-cycle-backwards)
  ;;   (define-key evil-normal-state-map (kbd "M-j") 'fix-cycle)
  ;;   (define-key evil-normal-state-map (kbd "M-n") 'my-popper-and-resize-new)
  ;;   (define-key evil-normal-state-map (kbd "M-f") 'my-popper-toggle))

#+end_src

* LANGUAGE SUPPORT

#+begin_src emacs-lisp

  (use-package raku-mode)
  (use-package lua-mode)
  (use-package terraform-mode)
  (use-package dockerfile-mode)

  (when (require 'dockerfile-mode nil 'noerror)
    ;; Add a hook to automatically use dockerfile-mode for Dockerfiles
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))

  ;; (use-package markdown-mode
  ;;   :ensure t
  ;;   :mode ("README\\.md\\'" . gfm-mode)
  ;;   :init (setq markdown-command "multimarkdown")
  ;;   :bind (:map markdown-mode-map
  ;;         ("C-c C-e" . markdown-do)))

#+end_src

** Lsp-bridge

#+begin_src emacs-lisp

  ;; (use-package yasnippet
  ;;   :config
  ;;   (yas-global-mode 1))

  ;; (use-package lsp-bridge
  ;;   :elpaca '(lsp-bridge :type git :host github :repo "manateelazycat/lsp-bridge"
  ;;             :files (:defaults "*.el" "*.py" "acm" "core" "langserver" "multiserver" "resources")
  ;;             :build (:not compile))
  ;;   :init
  ;;   (global-lsp-bridge-mode)
  ;;   :config
  ;;   (setq lsp-bridge-complete-manually t)
  ;;   (setq lsp-bridge-enable-log t)
  ;;   (setq lsp-bridge-enable-auto-format-code t)
  ;;   (global-set-key (kbd "C-x C-o") 'lsp-bridge-popup-complete-menu))

#+end_src

** Flycheck

#+begin_src emacs-lisp

  (use-package flycheck
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode))

#+end_src

** Lsp Mode

#+begin_src emacs-lisp

  (use-package lsp-mode
    :ensure t
    :commands lsp
    :config
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- gopls")
                      :major-modes '(go-mode)
                      :server-id 'gopls))
    (add-hook 'go-mode-hook #'lsp)
    (setq lsp-idle-delay 0.1)
    (setq lsp-enable-symbol-highlighting nil))

  (setq gc-cons-threshold (* 100 1024 1024)
        read-process-output-max (* 1024 1024))

  ;; (use-package lsp-ui
  ;;   :after lsp-mode
  ;;   :commands lsp-ui-mode
  ;;   :custom
  ;;   (lsp-ui-doc-position 'bottom) ;; Set the position of the lsp-ui-doc to bottom
  ;;   (lsp-ui-doc-alignment 'window) ;; Align the doc to the window
  ;;   :hook (lsp-mode . lsp-ui-mode))

  ;; (defun my/lsp-ui-doc-hide ()
  ;;   (unless (eq this-command 'lsp-ui-doc-focus-frame)
  ;;     (lsp-ui-doc-hide)))

  ;; (add-hook 'pre-command-hook 'my/lsp-ui-doc-hide)

  (use-package lsp-haskell
    :ensure t
    :init
    (setq lsp-haskell-server-path "haskell-language-server-wrapper")
    :after lsp
    :config
    ;; (setq lsp-haskell-check-parents 'AlwaysCheck)
    )

  ;;   (use-package corfu
  ;;       :ensure t
  ;;       :bind (("C-." . corfu-next)
  ;;              ("C-," . corfu-prev)))

#+end_src

* ORG MODE
** Tuning

#+begin_src emacs-lisp

  ;; (electric-indent-mode -1)
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))

#+end_src

** Bullets

#+begin_src emacs-lisp

  (add-hook 'org-mode-hook 'org-indent-mode)
  (use-package org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))

#+end_src

** Source Block Tag Expansion Cheetsheat

    | Name | Description |
    |------+-------------|
    | se   | lisp        |
    |------+-------------|
    |      |             |


** Enabling Table of Contents

#+begin_src emacs-lisp

  (use-package toc-org
      :commands toc-org-enable
      :init (add-hook 'org-mode-hook 'toc-org-enable))

#+end_src

** Custom key bindings

#+begin_src emacs-lisp

  (defun org-insert-row-with-floor ()
    "Insert a new row with a 'floor' above in an Org mode table."
    (interactive)
    (org-table-next-field)
    (beginning-of-line)
    (insert "|-")
    (org-table-align)
    (org-return))

  ;; (define-key org-mode-map (kbd "C-c f") 'org-insert-row-with-floor)

  (defun FormatToThreshold (char-threshold)
    "Formats the selected text to not exceed CHAR-THRESHOLD characters per line."
    (interactive "nCharacter Threshold: ")
    (let ((start (region-beginning))
          (end (region-end))
          all-text words formatted-text)
      (save-excursion
        (setq all-text (buffer-substring start end))
        (setq words (split-string all-text))
        (let ((current-line "")
              (current-length 0))
          (dolist (word words)
            (if (> (+ current-length (length word) 1) char-threshold)
                (progn
                  (setq formatted-text (concat formatted-text current-line "\n"))
                  (setq current-line word)
                  (setq current-length (length word)))
              (progn
                (setq current-line (if (string= "" current-line)
                                      word
                                    (concat current-line " " word)))
                (setq current-length (+ current-length (length word) 1)))))
          (setq formatted-text (concat formatted-text current-line)))
        (delete-region start end)
        (goto-char start)
        (insert formatted-text))))

#+end_src

* Custom functions

#+begin_src emacs-lisp

    (defun print-commands-starting-with (input)
  "Print all Emacs commands starting with INPUT to a scratch buffer."
  (interactive "sInput: ")
  (let ((command-list (apropos-internal input 'commandp))
        (output-buffer (get-buffer-create "*Commands*")))
    (with-current-buffer output-buffer
      (erase-buffer)
      (insert (format "Commands starting with '%s':\n\n" input))
      (dolist (command command-list)
        (insert (format "%s\n" command)))
      (goto-char (point-min)))
    (display-buffer output-buffer)))

#+end_src
