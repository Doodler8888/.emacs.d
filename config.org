#+TITLE: Wurfkreuz's GNU Emacs Config
#+AUTHOR: Alex Gud
#+DESCRIPTION: Empty.
#+STARTUP: showeverything ; Wont apply folding
#+OPTIONS: toc:3 ; Table of contents include 3 header levels down

* TABLE OF CONTENTS :toc:
- [[#general-emacs-setting][GENERAL EMACS SETTING]]
  - [[#visual][Visual]]
  - [[#system][System]]
  - [[#custom-commands][Custom Commands]]
  - [[#cursor][Cursor]]
  - [[#find-file][Find-file]]
- [[#packages][PACKAGES]]
  - [[#elpaca-package-manager][Elpaca Package Manager]]
  - [[#evil-mode][Evil Mode]]
  - [[#theme-and-font][Theme and Font]]
  - [[#general][General]]
  - [[#search][Search]]
  - [[#acess-to-env-variables][Acess to ENV variables]]
  - [[#treesitter][Treesitter]]
  - [[#sudo-edit][Sudo Edit]]
  - [[#ivy][Ivy]]
  - [[#hydra][Hydra]]
- [[#dired][Dired]]
  - [[#dired-keybindings][Dired keybindings]]
- [[#tramp][Tramp]]
- [[#shells-and-terminals][Shells and Terminals]]
  - [[#eshell][Eshell]]
  - [[#vterm][Vterm]]
  - [[#cmd][Cmd]]
- [[#sessions][Sessions]]
- [[#buffers][Buffers]]
  - [[#windmove][Windmove]]
  - [[#messages-buffer][Messages buffer]]
  - [[#dired-buffer][Dired buffer]]
  - [[#cmd-shell-buffer][Cmd shell buffer]]
  - [[#shell-buffer][Shell buffer]]
  - [[#vterm-buffer][Vterm buffer]]
  - [[#eshell-buffer][Eshell buffer]]
  - [[#transpose-frame][Transpose frame]]
- [[#language-support][LANGUAGE SUPPORT]]
  - [[#lsp-bridge][Lsp-bridge]]
  - [[#flycheck][Flycheck]]
  - [[#lsp-mode][Lsp Mode]]
- [[#org-mode][ORG MODE]]
  - [[#tuning][Tuning]]
  - [[#bullets][Bullets]]
  - [[#source-block-tag-expansion-cheetsheat][Source Block Tag Expansion Cheetsheat]]
  - [[#enabling-table-of-contents][Enabling Table of Contents]]
  - [[#custom-key-bindings][Custom key bindings]]

* GENERAL EMACS SETTING
** Visual

#+begin_src emacs-lisp

  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (setq inhibit-startup-screen t)
  (setq display-line-numbers 'visual)
  (setq display-line-numbers-type 'relative)
  (setq-default truncate-lines nil)

  (defun my-mode-line-major-mode ()
    "Returns a clean name of the current major mode."
    (let ((mode (format "%s" major-mode)))
      (replace-regexp-in-string "-mode$" "" mode)))  

  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  mode-line-buffer-identification  ; Buffer name
                  " "
                  (:eval (my-mode-line-major-mode))  ; Custom major mode display
                  (:eval (propertize " " 'display '(space :align-to (- right 12))))
                  (vc-mode vc-mode)))  ; Git branch information

#+end_src

*** Tabs

#+begin_src emacs-lisp

  (setq tab-bar-close-button-show nil
      tab-bar-new-button-show nil)

  (defun my-tab-name-format-function (tab i)
    (defface my-active-tab-face
      '((t :background "#2e2c3d" :foreground "#c0c5ce"))  ;; #373c42 - previous background color
      "Face for the active tab.")
    (defface my-inactive-tab-face
      '((t :background "#1d1f21" :foreground "#5B6268")) ;; #21242b - previous background color
      "Face for the inactive tab.")
    (let ((current-p (eq (car tab) 'current-tab)))
      (if current-p
          (propertize (format "%d %s" i (alist-get 'name (cdr tab))) 'face 'my-active-tab-face)
        (propertize (format "%d %s" i (alist-get 'name (cdr tab))) 'face 'my-inactive-tab-face))))

  (setq tab-bar-tab-name-format-function #'my-tab-name-format-function)

  (dotimes (i 9)
    (let ((n (1+ i)))  ; Tab numbers start from 1
      (global-set-key (kbd (format "M-%d" n))
                      `(lambda () (interactive) (tab-bar-select-tab ,n)))))

#+end_src

** System

#+begin_src emacs-lisp

  ;; (server-start)
  (global-set-key (kbd "C-x u") 'windmove-up)
  (setq evil-want-keybinding nil)

  (setq vc-follow-symlinks t)

  (setq python-shell-interpreter "/usr/bin/python3")

  (defalias 'yes-or-no-p 'y-or-n-p)

  ;; Set directory for undo-tree history files
  (setq undo-tree-auto-save-history t)
  (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo-tree-history"))))
  ;; Set directory for backup files
  (setq desktop-dirname (concat user-emacs-directory "desktop/"))

  ;; Save sessions
  (unless (file-exists-p desktop-dirname)
    (make-directory desktop-dirname))
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory "backups"))))
  (desktop-save-mode 1)
  (setq desktop-save 't)
  (setq desktop-path (list desktop-dirname))
  (setq desktop-auto-save-timeout 30)
  (setq desktop-auto-save-timeout nil)

  (global-set-key (kbd "C-c d l") 'load-desktop-with-name)

  (setq save-place-file (concat user-emacs-directory "saveplace/places"))

  ;; Save cursor position
  (unless (file-exists-p (concat user-emacs-directory "saveplace/"))
    (make-directory (concat user-emacs-directory "saveplace/")))
  (save-place-mode 1)

  (scroll-bar-mode -1)
  (pixel-scroll-mode 1)
  (setq-default display-line-numbers-width 3)
  (setq-default scroll-margin 8)
  (setq use-dialog-box nil)
  (set-fringe-mode 0)
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (setq global-auto-revert-non-file-buffers t)
  (global-auto-revert-mode 1)

  (add-to-list 'auto-mode-alist '("\\.hs\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.hls\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.cabal\\'" . haskell-cabal-mode))

  (setq-default truncate-lines t)

  (setenv "PATH" (concat "/home/wurfkreuz/.ghcup/bin:" (getenv "PATH")))

  (setq scroll-conservatively 101)
  (setq scroll-margin 5)
  (setq scroll-step 1)

#+end_src

*** Garbage Collection

#+begin_src emacs-lisp

   (defun my-minibuffer-setup-hook ()
     (setq gc-cons-threshold most-positive-fixnum))

   (defun my-minibuffer-exit-hook ()
     (setq gc-cons-threshold 800000))

   (add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
   (add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)

#+end_src
 
** Custom Commands

#+begin_src emacs-lisp

  (defun emc ()
    "Open a specific file."
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (defun zsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/zsh/.zshrc"))

  (defun bsh ()
    "Open a specific file."
    (interactive)
    (find-file "~/.dotfiles/bash/.bashrc"))

  (defun so ()
    "Reload the Emacs configuration."
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (with-eval-after-load 'evil
    (evil-ex-define-cmd "so" 'so))

  (defun z (q)
    "Query zoxide and launch dired."
    (interactive "sZoxide: ")
    (if-let
        ((zoxide (executable-find "zoxide"))
         (target
          (with-temp-buffer
            (if (= 0 (call-process zoxide nil t nil "query" q))
                (string-trim (buffer-string))))))
        (funcall-interactively #'dired  target)
      (unless zoxide (error "Install zoxide"))
      (unless target (error "No Match"))))

  (defun git-push ()
    "Execute git add, commit, and push in sequence."
    (interactive)
    (let ((output-buffer (get-buffer-create "*Git Push Output*")))
      (with-current-buffer output-buffer
        (erase-buffer))
      (call-process-shell-command "git add . && git commit -m 'n' && git push" nil output-buffer)
      (display-buffer output-buffer)))

#+end_src

** Cursor

#+begin_src emacs-lisp

  (blink-cursor-mode 0)
  (setq show-paren-delay 0)
  (show-paren-mode 1)

#+end_src

** Find-file

#+begin_src emacs-lisp

  (defun find-file-check-dir (filename &optional wildcards)
    "Edit file FILENAME.
     Switch to a buffer visiting file FILENAME,
     creating one if none already exists.
     If the directory path does not exist, create it."
     (interactive
      (find-file-read-args "Find file: " nil))
     (let ((dir (file-name-directory filename)))
       (when (not (file-exists-p dir))
 	(make-directory dir t)))
     (find-file filename wildcards))

#+end_src

* PACKAGES
** Elpaca Package Manager

#+begin_src emacs-lisp

  (defvar elpaca-installer-version 0.6)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
			  :ref nil
			  :files (:defaults (:exclude "extensions"))
			  :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
   (build (expand-file-name "elpaca/" elpaca-builds-directory))
   (order (cdr elpaca-order))
   (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (< emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
    (if-let ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
	     ((zerop (call-process "git" nil buffer t "clone"
				   (plist-get order :repo) repo)))
	     ((zerop (call-process "git" nil buffer t "checkout"
				   (or (plist-get order :ref) "--"))))
	     (emacs (concat invocation-directory invocation-name))
	     ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
				   "--eval" "(byte-recompile-directory \".\" 0 'force)")))
	     ((require 'elpaca))
	     ((elpaca-generate-autoloads "elpaca" repo)))
	(kill-buffer buffer)
      (error "%s" (with-current-buffer buffer (buffer-string))))
  ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (load "./elpaca-autoloads")))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
     ;; Install use-package support
  (elpaca elpaca-use-package
    ;; Enable :elpaca use-package keyword.
    (elpaca-use-package-mode)
    ;; Assume :elpaca t unless otherwise specified.
    (setq elpaca-use-package-by-default t))

  ;; Block until current queue processed.
  (elpaca-wait)
   (setq package-enable-at-startup nil)

#+end_src

** Evil Mode

#+begin_src emacs-lisp

  (use-package undo-tree
    :config
    (global-undo-tree-mode))

  (use-package evil
    :init
    (setq evil-want-C-u-scroll t
          evil-want-C-i-jump nil
          evil-want-integration t)
    :config
    (evil-mode 1)
    (setq evil-shift-width 2)
    (add-hook 'evil-mode-hook 'undo-tree-mode))


  (setq evil-undo-system 'undo-tree)

  (use-package evil-commentary
    :config
    (evil-commentary-mode))

  (use-package evil-collection
    :after evil
    :init ;;    (setq evil-want-keybinding nil)
    :config
    (setq evil-collection-mode-list '(dashboard eshell dired ibuffer vterm))
    (evil-collection-init))

  ;; (use-package evil-org
  ;;   :after org
  ;;   :config 
  ;;   (require 'evil-org-agenda)
  ;;   (evil-org-agenda-set-keys)
  ;;   (add-hook 'org-mode-hook 'evil-org-mode)
  ;;   (add-hook 'evil-org-mode-hook
  ;;             (lambda ()
  ;;               (evil-org-set-key-theme)))
  ;;   :ensure nil)


  (add-hook 'text-mode-hook 'display-line-numbers-mode)
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)

  ;; (global-set-key (kbd "C-x f") 'find-file)


#+end_src

*** Custom keybindings

#+begin_src emacs-lisp

  (with-eval-after-load 'evil
    (define-key evil-insert-state-map (kbd "C-S-v") 'yank)
    (define-key evil-visual-state-map (kbd "{") 'evil-backward-paragraph)
    (define-key evil-visual-state-map (kbd "}") 'evil-forward-paragraph)
    (define-key evil-insert-state-map (kbd "M-f") 'evil-forward-word-begin)
    (define-key evil-insert-state-map (kbd "M-b") 'evil-backward-word-begin)
  
    (define-key evil-normal-state-map (kbd "gq") 'FormatToThreshold)
    (define-key evil-visual-state-map (kbd "gq") 'FormatToThreshold))


#+end_src

** Theme and Font

#+begin_src emacs-lisp

  ;; (require 'color)
  ;;  (hl-line-mode 1) 

  ;; (add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))(put 'eval 'safe-local-variable #'identity)
  ;; (load-theme 'rose-pine t)

  (use-package gruvbox-theme
    :config
    (load-theme 'gruvbox-dark-hard t))

  ;; (use-package doom-themes
  ;;   :ensure t
  ;;   :config
  ;;   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
  ;;         doom-themes-enable-italic nil) ; if nil, italics is universally disabled
  ;;   (load-theme 'doom-one t)
  ;;   ;Corrects (and improves) org-mode's native fontification.
  ;;   (doom-themes-org-config))

  (when (member "NotoSansM Nerd Font Mono" (font-family-list))
    (set-face-attribute 'default nil :font "NotoSansM Nerd Font Mono-12:weight=medium")
    )

#+end_src

*** Icons

#+begin_src emacs-lisp

  (use-package all-the-icons
    :ensure t
    :if (display-graphic-p))

  (use-package all-the-icons-dired
    :hook (dired-mode . (lambda () (all-the-icons-dired-mode t))))

#+end_src

** General

#+begin_src emacs-lisp

  (use-package general
    :config
    (general-evil-setup)

  ;; "C-M-j" 'counsel-switch-buffer

  ;; set up 'SPC' as the global leader key
  (general-create-definer w/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "M-SPC") ;; access leader in insert mode

  (w/leader-keys

    ;; Fuzzy finder
    "fr" '(counsel-recentf :wk "Find recent files")
    "fd" '(counsel-find-file-check-dir :wk "Find file modified")
    "fb" '(counsel-switch-buffer :wk "Choose and switch to an active buffer")
    "fe" '(OpenDiredBufferInCurrentWindow :wk "Open a full screen dired buffer in a current window")
    "ff" '(projectile-find-file :wk "Find file fuzzy finder with a git directory as an anchor")
    "fz" '(fzf-from-home-with-fd :wk "Fzf with fd and hidden files with an ability to change the searching point")

    ;; Session management
    "ss" '(save-current-desktop-session :wk "Save the current desktop session into its corresponding directory")
    "sd" '(delete-desktop-session :wk "Delete selected session")
    "sl" '(load-desktop-with-name :wk "Load a desktop session by name, chosen from available sessions")
    "sr" '(rename-desktop-session :wk "Rename a desktop session")

    ;; Tab management
    "tn" '(tab-bar-new-tab :wk "Create a new tab")
    "tc" '(tab-bar-close-tab :wk "Close a tab")
    "tr" '(tab-bar-rename-tab :wk "Rename a tab")

    "w"  'hydra-window-size/body 

    ;; Window swapping
    "bk" '(buf-move-up :wk "Swap with buffer above")
    "bj" '(buf-move-down :wk "Swap with buffer below")
    "bh" '(buf-move-left :wk "Swap with buffer left")
    "bl" '(buf-move-right :wk "Swap with buffer right")

    "mm" '(open-messages-buffer-in-split :wk "Open the *Messages buffer")

    "xx" '(kill-buffer-and-window :wk "Close buffer with its window")

    "pp" '(git-push :wk "Activate an elisp copy of the git push alias")

    "cc" '(RunCmdShellCommand :wk "Run CMD command")
    "ch" '(my-hoogle-search :wk "Hoogle search prompt in the shell cmd")

    ;; "ts" '(SpawnShellSplitBelow :wk "Spawn shell below")

    "zz" '(z :wk "Call zoxide prompt")

    "vv" '(OpenVtermBelow :wk "Toggle vterm")

    "dd" '(OpenDiredBufferInSplit :wk "Open Dired buffer in split")

    "ld" '(lsp-find-definition :wk "Open diagnostic list in a separate split")
    ;; "lk" '(lsp-describe-thing-at-point :wk "Open a hover window")
    "lk" '(lsp-ui-doc-show :wk "Show hover documentation")
    ;; "ld" '(lsp-bridge-diagnostic-list :wk "Open diagnostic list in a separate split")
    ;; "lk" '(lsp-bridge-popup-documentation :wk "Open a hover window")

    "ee" '(SpawnEshellSplitBelow :wk "Create a new lessend eshell window under a current one")
    "es" '(eshell :wk "Eshell")

    ;; Evaluation
    "e" '(:ignore t :wk "Evaluate/Eshell")
    "eb" '(eval-buffer :wk "Evaluate elisp in buffer")
    "ed" '(eval-defun :wk "Evaluate defun containing or after point")
    "ex" '(eval-expression :wk "Evaluate and elisp expression")
    "el" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "er" '(eval-region :wk "Evaluate elisp in region")
    "es" '(counsel-esh-history :wk "Eshell history")

        )
    (dotimes (i 9)
        (let ((n (1+ i))) ; Tab numbers start from 1
          (general-def
            :states '(normal emacs)
            :keymaps 'override
            :prefix "SPC"
            (format "%d" n) `(lambda () (interactive) (tab-bar-select-tab ,n)))))
  )

#+end_src

** Search

#+begin_src emacs-lisp

  (use-package rg
   :config
   (rg-enable-default-bindings))
  
#+end_src

** Acess to ENV variables

#+begin_src emacs-lisp

  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize)
    (exec-path-from-shell-copy-env "SSH_AUTH_SOCK"))

#+end_src

** Treesitter

#+begin_src emacs-lisp

  ;; (use-package treesit-auto
  ;;   :custom
  ;;   (treesit-auto-install 'prompt)
  ;;   :config
  ;;   (treesit-auto-add-to-auto-mode-alist 'all)
  ;;   (global-treesit-auto-mode))  

  ;; (add-hook 'python-mode-hook #'tree-sitter-hl-mode)
  ;; (add-hook 'go-mode-hook #'tree-sitter-hl-mode)

  ;; (use-package tree-sitter
  ;;   :config
  ;;   (require 'tree-sitter-langs)
  ;;   (global-tree-sitter-mode)
  ;;   (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))  

  ;; (use-package tree-sitter-langs)

  ;; (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)

  ;; (defvar tree-sitter-go-face-map
  ;;   '((identifier . font-lock-variable-name-face)
  ;;     (string . font-lock-string-face)
  ;;     (comment . font-lock-comment-face)))

  ;; (defun tree-sitter-go--hl-face-mapping-function ()
  ;;     tree-sitter-go-face-map)
  ;;   (add-hook 'go-mode-hook
  ;;             (lambda ()
  ;;               (setq-local tree-sitter-hl-face-mapping-function
  ;;                           #'tree-sitter-go--hl-face-mapping-function)))

  ;; (setq treesit-language-source-alist
  ;;  '((bash "https://github.com/tree-sitter/tree-sitter-bash")
  ;;    (cmake "https://github.com/uyha/tree-sitter-cmake")
  ;;    (elisp "https://github.com/Wilfred/tree-sitter-elisp")
  ;;    (go "https://github.com/tree-sitter/tree-sitter-go")
  ;;    (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
  ;;    (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
  ;;    (html "https://github.com/tree-sitter/tree-sitter-html")
  ;;    (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
  ;;    (json "https://github.com/tree-sitter/tree-sitter-json")
  ;;    (make "https://github.com/alemuller/tree-sitter-make")
  ;;    (markdown "https://github.com/ikatyang/tree-sitter-markdown")
  ;;    (python "https://github.com/tree-sitter/tree-sitter-python")
  ;;    (toml "https://github.com/tree-sitter/tree-sitter-toml")
  ;;    (yaml "https://github.com/ikatyang/tree-sitter-yaml")))

#+end_src

** Sudo Edit

#+begin_src emacs-lisp

  (use-package sudo-edit
    :config
      (w/leader-keys
         "sf" '(sudo-edit-find-file :wk "Sudo find file")
         "se" '(sudo-edit :wk "Sudo edit file")))

#+end_src

** Ivy

#+begin_src emacs-lisp

  (use-package projectile
    :config
    (projectile-mode 1))

  (use-package counsel
    :after ivy
    :config 
    (counsel-mode))
    ;; (push '(counsel-esh-history . ivy-display-function-fallback) ivy-display-functions-alist))

  (use-package ivy
    :bind
    ;; ivy-resume resumes the last Ivy-based completion.
    (("C-c C-r" . ivy-resume)
     ("C-x B" . ivy-switch-buffer-other-window))
    :custom
    (setq ivy-use-virtual-buffers t)
    (setq ivy-count-format "(%d/%d) ")
    (setq enable-recursive-minibuffers t)
    :config
    (ivy-mode))
  
  (use-package ivy-posframe
    :ensure t
    :after ivy
    :config
    (ivy-posframe-mode 1))
    (setq ivy-posframe-width 50)
    (setq ivy-posframe-display-functions-alist
        '((counsel-esh-history . ivy-posframe-display-at-window-center)))

  (use-package all-the-icons-ivy-rich
    :init
    (all-the-icons-ivy-rich-mode 1))

  (use-package ivy-rich
    :after ivy
    :ensure t
    :init (ivy-rich-mode 1) ;; this gets us descriptions in M-x.
    :custom
    (ivy-virtual-abbreviate 'full
                            ivy-rich-switch-buffer-align-virtual-buffer t
                            ivy-rich-path-style 'abbrev))

  (defun counsel-find-file-check-dir ()
    "Like `counsel-find-file', but use `find-file-check-dir' instead of `find-file'."
    (interactive)
    (let* ((current-dir (if (eq major-mode 'dired-mode)
                            "."
                            (buffer-file-name))))
      (ivy-read "Find file: " #'read-file-name-internal
                :matcher #'counsel--find-file-matcher
                :action #'find-file-check-dir
                :preselect current-dir
                :require-match 'confirm-after-completion
                :history 'file-name-history
                :keymap counsel-find-file-map
                :caller 'counsel-find-file)))

  (global-set-key (kbd "C-x f") 'counsel-find-file-check-dir)

#+end_src

*** Fuzzy search

#+begin_src emacs-lisp

  (use-package fzf)

  (defun fzf-from-home-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
    and exclude certain directories but with an ability to interactively change
    the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --type f --hidden --follow --exclude .git .")
    (let ((default-directory "~/"))
      (fzf-directory)))

  ;; (defun fzf-from-home ()
  ;;   "Starts fzf from the user's home directory."
  ;;   (interactive)
  ;;   (let ((default-directory "~/"))
  ;;     (fzf-directory)))

#+end_src

** Hydra

#+begin_src emacs-lisp

  ;; (use-package hydra
  ;;   :config
  ;;   (defhydra hydra-window-size (:color red)
  ;;     "window size"
  ;;     ("h" (lambda () (interactive) (shrink-window-horizontally 5)) "shrink horizontally")
  ;;     ("l" (lambda () (interactive) (enlarge-window-horizontally 5)) "enlarge horizontally")
  ;;     ("k" (lambda () (interactive) (shrink-window 3)) "shrink vertically")
  ;;     ("j" (lambda () (interactive) (enlarge-window 3)) "enlarge vertically")
  ;;     ("t" transpose-frame "transpose windows")
  ;;     ("q" nil "quit")))

  (defun my-enlarge-window-horizontally ()
    "Enlarge the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (shrink-window-horizontally 5)
      (enlarge-window-horizontally 5)))

  (defun my-shrink-window-horizontally ()
    "Shrink the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (enlarge-window-horizontally 5)
      (shrink-window-horizontally 5)))

  (use-package hydra
    :config
    (defhydra hydra-window-size (:color red)
      "window size"
      ("h" my-shrink-window-horizontally "shrink horizontally")
      ("l" my-enlarge-window-horizontally "enlarge horizontally")
      ("k" (lambda () (interactive) (shrink-window 3)) "shrink vertically")
      ("j" (lambda () (interactive) (enlarge-window 3)) "enlarge vertically")
      ("t" transpose-frame "transpose windows")
      ("q" nil "quit")))

#+end_src

* Dired

#+begin_src emacs-lisp

  ;; (add-hook 'dired-mode-hook
  ;;         (lambda ()
  ;;           (wdired-change-to-wdired-mode)))

  (setq delete-by-moving-to-trash t
        trash-directory "~/.local/share/trash")

  (setq evil-move-cursor-back nil)
  (add-hook 'wdired-mode-hook #'evil-normal-state)

#+end_src


** Dired keybindings

#+begin_src emacs-lisp

  ;; (evil-define-key 'normal dired-mode-map
  ;;   (kbd "+") 'dired-create-directory))
  
#+end_src

* Tramp

#+begin_src emacs-lisp

  (require 'tramp)

  (setq remote-file-name-inhibit-cache nil)
  (setq vc-ignore-dir-regexp
      (format "%s\\|%s"
                    vc-ignore-dir-regexp
                    tramp-file-name-regexp))

  (with-eval-after-load 'tramp
  (setq tramp-inline-compress-start-size 1000)
  (setq tramp-copy-size-limit 10000)
  (setq vc-handled-backends '(Git))
  (setq tramp-verbose 1)
  (setq tramp-default-method "scp")
  (setq tramp-use-ssh-controlmaster-options nil)
  (setq projectile--mode-line "Projectile"))

#+end_src

* Shells and Terminals
** Eshell

#+begin_src emacs-lisp

  (use-package eshell-syntax-highlighting
    :after esh-mode
    :config
    (eshell-syntax-highlighting-global-mode +1))

  ;; eshell-syntax-highlighting -- adds fish/zsh-like syntax highlighting.
  ;; eshell-rc-script -- your profile for eshell; like a bashrc for eshell.
  ;; eshell-aliases-file -- sets an aliases file for the eshell.

  (setq eshell-rc-script (concat user-emacs-directory "eshell/eshelrc")
        eshell-aliases-file (concat user-emacs-directory "eshell/aliases")
        eshell-history-size 5000
        eshell-buffer-maximum-lines 5000
        eshell-save-history-on-exit t
        eshell-history-file-name "~/.emacs.d/eshell_history"
        eshell-hist-ignoredups t
        eshell-scroll-to-bottom-on-input t
        eshell-destroy-buffer-when-process-dies t
        eshell-visual-commands'("bash" "fish" "htop" "ssh" "top" "zsh"))

  (add-hook 'eshell-mode-hook
          (lambda ()
            (setq-local scroll-margin 0)))

  (defun eshell-insert-last-argument ()
    "Insert the last argument of the previous command."
    (interactive)
    (let* ((last-command (eshell-previous-input-string 0))
          (args (split-string-and-unquote last-command))
          (last-arg (car (last args))))
      (when last-arg
        (insert last-arg))))

  (defun setup-eshell-keys ()
    (define-key eshell-mode-map (kbd "M-.") 'eshell-insert-last-argument))
    ;; (define-key eshell-mode-map (kbd "M-r") 'counsel-esh-history))

  (add-hook 'eshell-mode-hook 'setup-eshell-keys)

  (with-eval-after-load 'evil
    (evil-define-key 'insert eshell-mode-map (kbd "M-r") 'counsel-esh-history)
    (evil-define-key 'normal eshell-mode-map (kbd "M-r") 'counsel-esh-history))

  ;; (defun my/counsel-file-jump ()
  ;;   "Jump to a file beneath the current directory using a custom find command to avoid permission errors."
  ;;   (interactive)
  ;;   (let ((default-directory "/")
  ;;         (counsel-file-jump-args '("-type" "f" "-not" "-path" "*/\\.*" "-not" "-path" "./proc/*" "-not" "-path" "./sys/*" "-not" "-path" "./dev/*" "-not" "-path" "./run/*" "-print")))
  ;;     (counsel-file-jump)))

#+end_src

** Vterm

#+begin_src emacs-lisp

  (use-package vterm
    :ensure t
    :config
    ;; (add-hook 'vterm-mode-hook #'evil-insert-state)
    ;; (add-hook 'vterm-mode-hook (lambda () (setq evil-default-state 'emacs)))
    (setq vterm-shell "/bin/bash")
    :bind (:map vterm-mode-map
                ("M-e" . (lambda ()
                           (interactive)
                           (if (bound-and-true-p evil-local-mode)
                               (evil-local-mode -1)
                             (evil-local-mode 1))))))

#+end_src

** Cmd

#+begin_src emacs-lisp

  (defun my-hoogle-search (query)
    "Search Hoogle for QUERY."
    (interactive "sHoogle search: ") ; Prompt for the search term
    (shell-command (concat "hoogle search " (shell-quote-argument query))))

#+end_src

* Sessions

#+begin_src emacs-lisp

  (defvar current-desktop-session-name nil
    "The name of the currently loaded desktop session.")

  (defvar desktop-autosave-timer nil
    "Timer object for desktop autosave, to avoid multiple timers running.")

  (defun save-eshell-buffer (desktop-dirname)
    ;; Save the current working directory.
    default-directory)

  (defun restore-eshell-buffer (_file-name buffer-name misc)
    "MISC is the value returned by `save-eshell-buffer'.
  _FILE-NAME is nil."
    (let ((default-directory misc))
      ;; Create an eshell buffer named BUFFER-NAME in directory MISC.
      (eshell buffer-name)))

  ;; Save all eshell-mode buffers.
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local desktop-save-buffer #'save-eshell-buffer)))

  ;; Restore all eshell-mode buffers.
  (add-to-list 'desktop-buffer-mode-handlers '(eshell-mode . restore-eshell-buffer))

  (defun save-current-desktop-session (&optional manual-save)
    "Save the current desktop session using the current session name.
  If no session is loaded, prompt to create a new one. If MANUAL-SAVE is non-nil, show a message for existing sessions."
    (interactive "p") ; "p" passes a prefix argument, which is non-nil when called interactively
    (if current-desktop-session-name
        (let ((desktop-dir (concat user-emacs-directory "desktop/" current-desktop-session-name "/")))
          (unless (file-exists-p desktop-dir)
            (make-directory desktop-dir))
          (desktop-save desktop-dir)
          (when manual-save
            (message "Session '%s' saved." current-desktop-session-name)))
      ;; No session is loaded, prompt to create a new one
      (let ((new-session-name (read-string "Enter new session name: ")))
        (unless (string-empty-p new-session-name)
          (let ((new-desktop-dir (concat user-emacs-directory "desktop/" new-session-name "/")))
            (make-directory new-desktop-dir t)
            (setq current-desktop-session-name new-session-name)
            (desktop-save new-desktop-dir))))))

  (defun load-desktop-with-name ()
    "Load a desktop session by name, chosen from available sessions."
    (interactive)
    (when current-desktop-session-name
      ;; Save the current session before loading a new one, but only if a session is already loaded.
      (save-current-desktop-session))
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
          (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
          (session-name (completing-read "Choose desktop session: " session-dirs nil t)))
      (setq current-desktop-session-name session-name)  ; Save the session name globally
      (desktop-change-dir (concat desktop-dir session-name "/"))
      ;; Set up the autosave timer when a new session is loaded
      (when desktop-autosave-timer
        (cancel-timer desktop-autosave-timer))
      (setq desktop-autosave-timer (run-with-timer 0 30 'save-current-desktop-session))))

  ;; Disable the default desktop save mode
  (desktop-save-mode 0)

  (defun delete-desktop-session ()
    "Delete a desktop session by name, chosen from available sessions."
    (interactive)
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
          (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
          (session-name (completing-read "Choose desktop session to delete: " session-dirs nil t)))
      (when (yes-or-no-p (format "Are you sure you want to delete the '%s' session? " session-name))
        (let ((session-path (concat desktop-dir session-name)))
          (if (file-directory-p session-path)
              (progn
                (delete-directory session-path t)  ; 't' for recursive delete
                (message "Deleted desktop session '%s'." session-name))
            (message "No such desktop session '%s'." session-name))))))
  
  (defun rename-desktop-session ()
    "Renames the currently loaded desktop session."
    (interactive)
    ;; Check if there's a session loaded.
    (if (not current-desktop-session-name)
        (message "No desktop session is currently loaded.")
      (let* ((new-name (read-string "New session name: "))
            (old-dir (concat user-emacs-directory "desktop/" current-desktop-session-name))
            (new-dir (concat user-emacs-directory "desktop/" new-name)))
        ;; Check if the new session name is empty or the session already exists.
        (if (or (string-empty-p new-name)
                (file-exists-p new-dir))
            (message "Invalid new session name or session already exists.")
          ;; Rename the directory and update the session name.
          (rename-file old-dir new-dir)
          (setq current-desktop-session-name new-name)
          (message "Session renamed to '%s'." new-name)))))

#+end_src

* Buffers
** Windmove

#+begin_src emacs-lisp

  (require 'windmove)

   ;;;###autoload
  (defun buf-move-up ()
   "Swap the current buffer and the buffer above the split.
   If there is no split, ie now window above the current one, an
   error is signaled."
     ;;  "Switches between the current buffer, and the buffer above the
     ;;  split, if possible."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'up))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No window above this one")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-down ()
   "Swap the current buffer and the buffer under the split.
   If there is no split, ie now window under the current one, an
   error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'down))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (or (null other-win) 
 	      (string-match "^ \\*Minibuf" (buffer-name (window-buffer other-win))))
 	  (error "No window under this one")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-left ()
   "Swap the current buffer and the buffer on the left of the split.
   If there is no split, ie now window on the left of the current
   one, an error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'left))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No left split")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

   ;;;###autoload
  (defun buf-move-right ()
   "Swap the current buffer and the buffer on the right of the split.
   If there is no split, ie now window on the right of the current
   one, an error is signaled."
     (interactive)
     (let* ((other-win (windmove-find-other-window 'right))
 	   (buf-this-buf (window-buffer (selected-window))))
       (if (null other-win)
 	  (error "No right split")
 	;; swap top with this one
 	(set-window-buffer (selected-window) (window-buffer other-win))
 	;; move this one to top
 	(set-window-buffer other-win buf-this-buf)
 	(select-window other-win))))

#+end_src

** Messages buffer

#+begin_src emacs-lisp

  (defun open-messages-buffer-in-split ()
     (interactive)
     (split-window-horizontally)
     (other-window 1)
     (switch-to-buffer "*Messages*"))

#+end_src

** Dired buffer

#+begin_src emacs-lisp

  (defun OpenDiredBufferInSplit ()
     "Open a Dired buffer in a vertical split on the right, showing the directory of the current buffer."
     (interactive)
     (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
       (split-window-right)
       (windmove-right)
       (dired current-dir)))

  (defun OpenDiredBufferInCurrentWindow ()
     "Open a Dired buffer in the current window, showing the directory of the current buffer."
     (interactive)
     (let ((current-dir (file-name-directory (or (buffer-file-name) default-directory))))
       (dired current-dir)))

#+end_src

** Cmd shell buffer

#+begin_src emacs-lisp

  (defun RunCmdShellCommand ()
    "Prompt for and run a CMD shell command."
    (interactive)
    (let ((cmd (read-shell-command "Run CMD command: ")))
      (shell-command cmd)))

#+end_src

** Shell buffer

#+begin_src emacs-lisp

  (defun my-shell-mode-hook ()
    (setq-local scroll-margin 0))

  (add-hook 'shell-mode-hook 'my-shell-mode-hook)

  (setq explicit-shell-file-name "/usr/bin/bash")  ; your shell path here
  (setq explicit-bash-args '("--login" "-i"))

  (add-hook 'shell-mode-hook 'ShellModeSetup)

  (defun SpawnShellSplitBelow ()
    "Open a shell in a small split below."
    (interactive)
    (split-window-below -10)
    (other-window 1)
    (shell))

#+end_src

** Vterm buffer

#+begin_src emacs-lisp

  (defun OpenVtermBelow ()
    "Open a `vterm' buffer in a new window below the current one."
    (interactive)
    (let ((buf (generate-new-buffer "*vterm*"))
          (cur-window (selected-window)))
      (save-excursion
        (select-window cur-window)
        (split-window-below)
        (windmove-down)
        (switch-to-buffer buf)
        (vterm)
        (shrink-window 10)
        (if (bound-and-true-p evil-local-mode)
            (evil-local-mode -1)
          (evil-local-mode 1)))))

#+end_src

** Eshell buffer

#+begin_src emacs-lisp

  (defun SpawnEshellSplitBelow ()
    "Open a shell in a small split below."
    (interactive)
    (split-window-below -10)
    (other-window 1)
    (open-eshell-in-current-directory))

  (defun open-eshell-in-current-directory ()
    "Open eshell in the directory of the current buffer."
    (interactive)
    (let* ((buffer-dir (if (buffer-file-name)
                          (file-name-directory (buffer-file-name))
                        default-directory))
          (eshell-buffer (eshell 'N)))
      (with-current-buffer eshell-buffer
        (eshell/cd buffer-dir))))  
  
#+end_src

** Transpose frame

#+begin_src emacs-lisp

  (use-package transpose-frame)
 
#+end_src

* LANGUAGE SUPPORT

#+begin_src emacs-lisp

  (use-package haskell-mode)
  ;; (use-package lua-mode)
  (use-package go-mode)
  (use-package raku-mode)
  ;; (use-package markdown-mode
  ;;   :ensure t
  ;;   :mode ("README\\.md\\'" . gfm-mode)
  ;;   :init (setq markdown-command "multimarkdown")
  ;;   :bind (:map markdown-mode-map
  ;;         ("C-c C-e" . markdown-do)))

#+end_src

** Lsp-bridge

#+begin_src emacs-lisp

  ;; (use-package yasnippet
  ;;   :config
  ;;   (yas-global-mode 1))

  ;; (use-package lsp-bridge
  ;;   :elpaca '(lsp-bridge :type git :host github :repo "manateelazycat/lsp-bridge"
  ;;             :files (:defaults "*.el" "*.py" "acm" "core" "langserver" "multiserver" "resources")
  ;;             :build (:not compile))
  ;;   :init
  ;;   (global-lsp-bridge-mode)
  ;;   :config
  ;;   (setq lsp-bridge-complete-manually t)
  ;;   (setq lsp-bridge-enable-log t)
  ;;   (setq lsp-bridge-enable-auto-format-code t)
  ;;   (global-set-key (kbd "C-x C-o") 'lsp-bridge-popup-complete-menu))

#+end_src

** Flycheck

#+begin_src emacs-lisp

  (use-package flycheck
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode))
    ;; :config
    ;; (add-hook 'flycheck-mode-hook #'flycheck-inline-mode))

#+end_src

** Lsp Mode

#+begin_src emacs-lisp

  (use-package lsp-mode
      :ensure t
      :commands lsp
      :config 
      (add-hook 'haskell-mode-hook #'lsp))
      (setq lsp-idle-delay 0.1)
      (setq lsp-enable-symbol-highlighting nil)

  (use-package lsp-ui
    :after lsp-mode
    :commands lsp-ui-mode
    :custom
    (lsp-ui-doc-position 'bottom) ;; Set the position of the lsp-ui-doc to bottom
    (lsp-ui-doc-alignment 'window) ;; Align the doc to the window
    :hook (lsp-mode . lsp-ui-mode))

  (defun my/lsp-ui-doc-hide ()
    (unless (eq this-command 'lsp-ui-doc-focus-frame)
      (lsp-ui-doc-hide)))

  (add-hook 'pre-command-hook 'my/lsp-ui-doc-hide)

  (use-package lsp-haskell
      :ensure t
      :init
      (setq lsp-haskell-server-path "haskell-language-server-wrapper")
      :after lsp
      :config
      ;; (setq lsp-haskell-check-parents 'AlwaysCheck)
  )

    ;;   (use-package corfu
    ;;       :ensure t
    ;;       :bind (("C-." . corfu-next)
    ;;              ("C-," . corfu-prev)))

#+end_src

* ORG MODE
** Tuning

#+begin_src emacs-lisp

  ;; (electric-indent-mode -1)
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))

#+end_src

** Bullets

#+begin_src emacs-lisp

  (add-hook 'org-mode-hook 'org-indent-mode)
  (use-package org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))

#+end_src

** Source Block Tag Expansion Cheetsheat

    | Name | Description |
    |------+-------------|
    | se   | lisp        |
    |------+-------------|
    |      |             |

  
** Enabling Table of Contents

#+begin_src emacs-lisp

  (use-package toc-org
      :commands toc-org-enable
      :init (add-hook 'org-mode-hook 'toc-org-enable))

#+end_src

** Custom key bindings

#+begin_src emacs-lisp

  (defun org-insert-row-with-floor ()
    "Insert a new row with a 'floor' above in an Org mode table."
    (interactive)
    (org-table-next-field)
    (beginning-of-line)
    (insert "|-")
    (org-table-align)
    (org-return))

  ;; (define-key org-mode-map (kbd "C-c f") 'org-insert-row-with-floor)

  (defun FormatToThreshold (char-threshold)
    "Formats the selected text to not exceed CHAR-THRESHOLD characters per line."
    (interactive "nCharacter Threshold: ")
    (let ((start (region-beginning))
          (end (region-end))
          all-text words formatted-text)
      (save-excursion
        (setq all-text (buffer-substring start end))
        (setq words (split-string all-text))
        (let ((current-line "")
              (current-length 0))
          (dolist (word words)
            (if (> (+ current-length (length word) 1) char-threshold)
                (progn
                  (setq formatted-text (concat formatted-text current-line "\n"))
                  (setq current-line word)
                  (setq current-length (length word)))
              (progn
                (setq current-line (if (string= "" current-line)
                                      word
                                    (concat current-line " " word)))
                (setq current-length (+ current-length (length word) 1)))))
          (setq formatted-text (concat formatted-text current-line)))
        (delete-region start end)
        (goto-char start)
        (insert formatted-text))))

#+end_src

