#+TITLE: Wurfkreuz's GNU Emacs Config
#+AUTHOR: Alex Gud
#+DESCRIPTION: Empty.
#+STARTUP: showeverything ; Wont apply folding
#+OPTIONS: toc:3 ; Table of contents include 3 header levels down

* TABLE OF CONTENTS :toc:
- [[#general-emacs-setting][GENERAL EMACS SETTING]]
  - [[#visuals][Visuals]]
  - [[#system][System]]
  - [[#cursor][Cursor]]
  - [[#find-file][Find-file]]
  - [[#evil-mode][Evil Mode]]
  - [[#theme-and-font][Theme and Font]]
- [[#highlighting][Highlighting]]
  - [[#treesitter][Treesitter]]
- [[#packages][Packages]]
  - [[#general][General]]
  - [[#daemons][Daemons]]
  - [[#proced][Proced]]
  - [[#avy][Avy]]
  - [[#async][Async]]
  - [[#transient][Transient]]
  - [[#search][Search]]
  - [[#xterm-color][Xterm-color]]
  - [[#circe][Circe]]
  - [[#docker][Docker]]
  - [[#folds][Folds]]
  - [[#ispell][Ispell]]
  - [[#jinx][Jinx]]
  - [[#completion][Completion]]
  - [[#acess-to-env-variables][Acess to ENV variables]]
  - [[#sudo-edit][Sudo Edit]]
  - [[#symex][Symex]]
  - [[#paredit][Paredit]]
  - [[#hyperbole][Hyperbole]]
  - [[#zoxide][Zoxide]]
  - [[#cider][Cider]]
  - [[#mentor][Mentor]]
  - [[#wgrep][Wgrep]]
  - [[#embark][Embark]]
  - [[#ivycounsel][Ivy/Counsel]]
  - [[#with-editor][With-editor]]
  - [[#cron][Cron]]
  - [[#systemd][Systemd]]
  - [[#prescient][Prescient]]
  - [[#fzf][Fzf]]
  - [[#helpful][Helpful]]
  - [[#hydra][Hydra]]
- [[#dired][Dired]]
  - [[#dired-keybindings][Dired keybindings]]
- [[#tramp][Tramp]]
- [[#shells-and-terminals][Shells and Terminals]]
  - [[#eshell][Eshell]]
  - [[#async-shell][Async shell]]
  - [[#cmd][Cmd]]
  - [[#cursor-changer][Cursor changer]]
- [[#database][Database]]
- [[#sessions][Sessions]]
- [[#buffers][Buffers]]
  - [[#shell-buffer][Shell buffer]]
  - [[#eshell-buffer][Eshell buffer]]
  - [[#transpose-frame][Transpose frame]]
  - [[#popper][Popper]]
- [[#language-support][Language Support]]
  - [[#python][Python]]
  - [[#flymake][Flymake]]
  - [[#modes][Modes]]
  - [[#flycheck][Flycheck]]
  - [[#lsp-mode][Lsp Mode]]
- [[#org-mode][Org Mode]]
  - [[#general-1][General]]
  - [[#org-capture][Org capture]]
  - [[#org-download][Org download]]
  - [[#drill][Drill]]
  - [[#agenda][Agenda]]
  - [[#org-roam][Org-roam]]
  - [[#templates][Templates]]
  - [[#visuals-1][Visuals]]
  - [[#source-block-tag-expansion-cheat-sheet][Source block tag expansion cheat sheet]]
  - [[#enabling-table-of-contents][Enabling Table of Contents]]
  - [[#custom-key-bindings][Custom key bindings]]
- [[#keybindings][Keybindings]]
- [[#custom-functions][Custom functions]]

* GENERAL EMACS SETTING
** Visuals

#+begin_src emacs-lisp

(menu-bar-mode -1)
(tool-bar-mode -1)
(setq inhibit-startup-screen t)
(global-display-line-numbers-mode 1)
(setq display-line-numbers 'visual
      display-line-numbers-type 'relative)
(add-hook 'conf-mode-hook 'display-line-numbers-mode)
(add-hook 'conf-space-mode-hook 'display-line-numbers-mode) ;; it breaks tramp with pipes?
(add-hook 'text-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)

  (defun my-mode-line-major-mode ()
    "Returns a clean name of the current major mode."
    (let ((mode (format "%s" major-mode)))
      (replace-regexp-in-string "-mode$" "" mode)))

  (setq-default mode-line-format
                '("%e"
                  mode-line-front-space
                  (:eval (if (buffer-file-name)
                             (abbreviate-file-name (buffer-file-name))  ; Show abbreviated file path
                           "%b"))  ; Show buffer name if not a file buffer
                  " "
                  (:eval (my-mode-line-major-mode))  ; Custom major mode display
                  (:eval (propertize " " 'display '(space :align-to (- right 12))))
                  (vc-mode vc-mode)))  ; Git branch information

#+end_src

*** Tabs

#+begin_src emacs-lisp

  (setq tab-bar-tab-name-format-function #'my-tab-bar-vim-name-format-function)
  (setq tab-bar-format '(tab-bar-format-tabs tab-bar-separator))
  (setq tab-bar-separator "\u200B")  ;; Zero width space to fix color bleeding
  (setq tab-bar-tab-hints nil)  ;; Tab numbers of the left of the label
  (setq tab-bar-new-button-show nil)
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-auto-width nil)

  (defun my-tab-name-format-function (tab i)
    (defface my-active-tab-face
      '((t :background "#2e2c3d" :foreground "#e0def4"))
      "Face for the active tab.")
    (defface my-inactive-tab-face
      '((t :background "#1d1f21" :foreground "#6e6a86"))
      "Face for the inactive tab.")
    (let ((current-p (eq (car tab) 'current-tab))
          (tab-name (format "%d %s" i (alist-get 'name (cdr tab)))))
      ;; Add padding around the tab name
      (setq tab-name (format " %s " tab-name))  ;; Add a space before and after the tab name
      (if current-p
          (propertize tab-name 'face 'my-active-tab-face)
        (propertize tab-name 'face 'my-inactive-tab-face))))

  (setq tab-bar-tab-name-format-function #'my-tab-name-format-function)

  (dotimes (i 9)
    (let ((n (1+ i)))  ; Tab numbers start from 1
      (global-set-key (kbd (format "M-%d" n))
                      `(lambda () (interactive) (tab-bar-select-tab ,n)))))

#+end_src

** System

#+begin_src emacs-lisp

;; (server-start)
(global-set-key (kbd "C-x u") 'windmove-up)
(setq evil-want-keybinding nil)

(setq vc-follow-symlinks t)

(setq dired-recursive-deletes 'always)

(setq desktop-load-locked-desktop t)
(setq backup-inhibited t)

(add-hook 'prog-mode-hook (show-paren-mode t))

;; Auto pairing
(add-hook 'prog-mode-hook (electric-pair-mode t))

;; Don't pair '<'
(setq electric-pair-inhibit-predicate
      `(lambda (c)
        (if (char-equal c ?\<) t (,electric-pair-inhibit-predicate c))))

;; Break lines after a certain length
(auto-fill-mode 1)
(setq-default fill-column 80)
(add-hook 'text-mode-hook 'auto-fill-mode)

(setq python-shell-interpreter "/usr/bin/python3")

(defalias 'yes-or-no-p 'y-or-n-p)

;; Autoinsertion on the search buffer
(setq ivy-initial-inputs-alist nil)
;; (setq ivy-initial-inputs-alist ;; If you want there are situations where you would like to have it enabled, try this code.
;;     '((counsel-M-x . "")
;;       (t . "^")))

;; (add-hook 'before-save-hook 'delete-trailing-whitespace)
(setq-default indent-tabs-mode nil)
(savehist-mode 1)

;; Executable on save if starts with '#!'
(add-hook 'after-save-hook
        'executable-make-buffer-file-executable-if-script-p)

(setq undo-tree-auto-save-history t)
(setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "undo-tree-history"))))
(make-directory (concat user-emacs-directory "auto-saves") t)
(setq auto-save-file-name-transforms
      `((".*" ,(concat user-emacs-directory "auto-saves/") t)))
(make-directory (concat user-emacs-directory "lock-files") t)
(setq lock-file-name-transforms
      `((".*" ,(concat user-emacs-directory "lock-files/") t)))
(setq desktop-dirname (concat user-emacs-directory "desktop/"))
(make-directory (concat user-emacs-directory "backups") t)
(setq backup-directory-alist
      `((".*" . ,(concat user-emacs-directory "backups/"))))

(defun my-disable-auto-save-for-scratch ()
(when (string= (buffer-name) "*scratch*")
  (auto-save-mode -1)))

(add-hook 'lisp-interaction-mode-hook 'my-disable-auto-save-for-scratch)


;; Save sessions
(unless (file-exists-p desktop-dirname)
  (make-directory desktop-dirname))
(desktop-save-mode 1)
(setq desktop-save 't)
(setq desktop-path (list desktop-dirname))
(setq desktop-auto-save-timeout 30)
(setq desktop-auto-save-timeout nil)

(auto-save-mode 1)
(setq auto-save-interval 1)  ; Auto-save every 1 second
(setq auto-save-timeout 10)  ; Auto-save after 10 seconds of idle time
(setq auto-save-no-message t)

(setq save-place-file (concat user-emacs-directory "saveplace/places"))

;; Save cursor position
(unless (file-exists-p (concat user-emacs-directory "saveplace/"))
  (make-directory (concat user-emacs-directory "saveplace/")))
(save-place-mode 1)

(if (version< emacs-version "29.0")
    (pixel-scroll-mode)
  (pixel-scroll-precision-mode 1)
  (setq pixel-scroll-precision-large-scroll-height 35.0))

(scroll-bar-mode -1)
(setq-default display-line-numbers-width 3)
(setq-default scroll-margin 8)
(setq use-dialog-box nil)
;; (set-fringe-mode 1)
(fringe-mode '(1 . 1))
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(setq global-auto-revert-non-file-buffers t)
(global-auto-revert-mode 1)

(setq-default truncate-lines t)

(setenv "PATH" (concat "/home/wurfkreuz/.ghcup/bin:" (getenv "PATH")))
(setenv "PATH" (concat (getenv "PATH") ":/usr/bin"))
(setq exec-path (append exec-path '("/usr/bin")))

(setq scroll-conservatively 101)
(setq scroll-margin 5)
(setq scroll-step 1)

(require 'midnight)
(midnight-delay-set 'midnight-delay "10:00pm")

(setq comint-process-echoes t)
(setq comint-use-prompt-regexp nil)

(setq auto-revert-verbose nil)

#+end_src

** Cursor

#+begin_src emacs-lisp

  (blink-cursor-mode 0)
  (setq show-paren-delay 0)
  (show-paren-mode 1)

#+end_src

** Find-file

#+begin_src emacs-lisp

  (defun find-file-check-dir (filename &optional wildcards)
    "Edit file FILENAME.
     Switch to a buffer visiting file FILENAME,
     creating one if none already exists.
     If the directory path does not exist, create it."
     (interactive
      (find-file-read-args "Find file: " nil))
     (let ((dir (file-name-directory filename)))
       (when (not (file-exists-p dir))
        (make-directory dir t)))
     (find-file filename wildcards))
     #+end_src

** Evil Mode

#+begin_src emacs-lisp

  (use-package undo-tree
    :config
    (global-undo-tree-mode))

  (use-package evil
    :init
    (setq evil-want-C-u-scroll t
          evil-want-C-i-jump nil
          evil-want-integration t
          evil-want-minibuffer t
          evil-undo-system 'undo-tree)
    :config
    (evil-mode 1)
    (evil-set-initial-state 'custom-theme-choose-mode 'normal)
    (define-key evil-normal-state-map (kbd "C-n") 'next-line)
    (define-key evil-normal-state-map (kbd "C-p") 'previous-line)
    (define-key evil-insert-state-map (kbd "C-n") 'next-line)
    (define-key evil-insert-state-map (kbd "C-p") 'previous-line)
    (setq evil-shift-width 2))

  (add-hook 'term-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'eat-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'eshell-mode-hook (lambda () (undo-tree-mode 1)))
  (add-hook 'wdired-mode-hook (lambda () (undo-tree-mode 1)))


  (setq evil-undo-system 'undo-tree)

  (use-package evil-surround
    :config
    (global-evil-surround-mode 1)
    ;; Add custom surround pairs
    (setq-default evil-surround-pairs-alist
                  (append evil-surround-pairs-alist
                          '((?/ . ("/" . "/"))
                            (?~ . ("~" . "~"))
                            (?* . ("*" . "*"))
                            (?= . ("=" . "="))
                            (?+ . ("+" . "+"))))))

;; (use-package evil-commentary
;;   :config
;;   (evil-commentary-mode))

;;  (use-package evil-org
;;    :after org
;;    :config
;;    (require 'evil-org-agenda)
;;    (evil-org-agenda-set-keys)
;;    (add-hook 'org-mode-hook 'evil-org-mode)
;;    (add-hook 'evil-org-mode-hook
;;              (lambda ()
;;                (evil-org-set-key-theme)))
;;    )

  (use-package evil-collection
    :after evil
    :init ;;    (setq evil-want-keybinding nil)
    :config
    (setq evil-collection-mode-list '(dashboard eshell dired wdired ibuffer org term ansi lsp-ui-imenu elpaca minibuffer ivy proced docker))
    (evil-collection-init))

  (defun my-evil-yank-to-end-of-line ()
    "Yank text from the current point to the end of the line."
    (interactive)
    (evil-yank (point) (line-end-position)))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "Y") 'my-evil-yank-to-end-of-line))

  (defun my-evil-insert-state-minibuffer-setup ()
    (define-key evil-insert-state-local-map (kbd "<backspace>") 'ivy-backward-delete-char)
    (define-key evil-insert-state-local-map (kbd "TAB") 'ivy-partial-or-done))

  (add-hook 'minibuffer-setup-hook 'my-evil-insert-state-minibuffer-setup)

  (evil-global-set-key 'insert (kbd "C-l") 'forward-char)
  (evil-global-set-key 'insert (kbd "C-h") 'backward-char)

(with-eval-after-load 'evil
  (define-key evil-ex-completion-map (kbd "<insert-state> C-n") nil))

(with-eval-after-load 'evil
  (define-key evil-ex-completion-map (kbd "<insert-state> C-p") nil))
  
(with-eval-after-load 'evil
  (define-key evil-ex-completion-map (kbd "<insert-state> <up>") 'previous-complete-history-element)
  (define-key evil-ex-completion-map (kbd "<insert-state> <down>") 'next-complete-history-element))

(defun my/setup-daemons-output-keymap ()
  "Set up custom keybindings for daemons-output-mode."
  (evil-local-set-key 'normal (kbd "RET") 'daemons-status-at-point)
  (evil-local-set-key 'motion (kbd "RET") 'daemons-status-at-point))

(add-hook 'daemons-output-mode-hook 'my/setup-daemons-output-keymap)

(defun my/setup-docker-mark-keymap ()
  "Set up custom keybindings for daemons-output-mode."
  (evil-local-set-key 'normal (kbd "m") 'tablist-mark-forward)
  (evil-local-set-key 'normal (kbd "M") 'tablist-mark-backward))

(add-hook 'docker-container-mode-hook 'my/setup-docker-mark-keymap)
(add-hook 'docker-image-mode-hook 'my/setup-docker-mark-keymap)

(defun my-comment-on-region (beg end)
  "Comment or uncomment the region between BEG and END."
  (interactive "r")
  (comment-or-uncomment-region beg end))

(evil-define-operator my-evil-comment (beg end type)
  "Comment or uncomment the text from BEG to END."
  (interactive "<R>")
  (my-comment-on-region beg end))

;; Bind the custom comment operator to "gc"
(define-key evil-normal-state-map (kbd "gc") 'my-evil-comment)
(define-key evil-visual-state-map (kbd "gc") 'my-evil-comment)

(defun my-fill-region (beg end)
  "Fill the region between BEG and END."
  (interactive "r")
  (fill-region beg end))

(evil-define-operator my-evil-fill (beg end type)
  "Fill the text from BEG to END."
  (interactive "<R>")
  (my-fill-region beg end))

;; Bind the custom fill operator to "gw"
(define-key evil-normal-state-map (kbd "gw") 'my-evil-fill)
(define-key evil-visual-state-map (kbd "gw") 'my-evil-fill)

#+end_src

*** Custom keybindings

#+begin_src emacs-lisp

(with-eval-after-load 'evil
  (define-key evil-insert-state-map (kbd "C-S-v") 'yank)
  (define-key evil-visual-state-map (kbd "{") 'evil-backward-paragraph)
  (define-key evil-visual-state-map (kbd "}") 'evil-forward-paragraph)
  (define-key evil-insert-state-map (kbd "M-w") 'evil-forward-word-begin)
  (define-key evil-insert-state-map (kbd "M-b") 'evil-backward-word-begin)
  (define-key evil-insert-state-map (kbd "M-W") 'evil-forward-WORD-begin)
  (define-key evil-insert-state-map (kbd "M-B") 'evil-backward-WORD-begin)

  (define-key evil-normal-state-map (kbd "gq") 'FormatToThreshold)
  (define-key evil-visual-state-map (kbd "gq") 'FormatToThreshold))

(defun my-move-beginning-of-line ()
  "Move point to the first non-whitespace character of the line and enter insert mode."
  (interactive)
  (evil-first-non-blank)
  (evil-insert-state))

(defun my-move-end-of-line ()
  "Move point to the very end of the line and enter insert mode."
  (interactive)
  (evil-end-of-line)
  (evil-insert-state)
  (unless (eolp)
    (evil-append-line 1)))

(with-eval-after-load 'evil
  (define-key evil-insert-state-map (kbd "M-i") 'my-move-beginning-of-line)
  (define-key evil-insert-state-map (kbd "M-a") 'my-move-end-of-line))

#+end_src

** Theme and Font

#+begin_src emacs-lisp

  (add-to-list 'custom-theme-load-path (expand-file-name "themes" user-emacs-directory))(put 'eval 'safe-local-variable #'identity)
  (load-theme 'rose-pine t)

  (when (member "NotoSansM Nerd Font Mono" (font-family-list))
    (set-face-attribute 'default nil :font "NotoSansM Nerd Font Mono-12:weight=medium")

    ;; Set a different font for italics
    (set-face-attribute 'italic nil
                        :family "NotoSans Nerd Font"
                        :slant 'italic
                        :weight 'normal
                        :height 130)

    (add-hook 'org-mode-hook
              (lambda ()
                (set-face-attribute 'org-verbatim nil
                                    ;; :family "NotoSerifNerdFontPropo-CondensedExtraLight"
                                    :family "NotoSerifNerdFont"
                                    :height 130
                                    ;; :foreground "#8bc34a"  ; Adjust the color as desired
                                    :weight 'normal))))

#+end_src

*** Icons

#+begin_src emacs-lisp

(use-package all-the-icons
  :ensure t
  :if (display-graphic-p))

(use-package all-the-icons-dired
  :hook (dired-mode . (lambda ()
                        (when (not (file-remote-p default-directory))
                          (all-the-icons-dired-mode t)))))

#+end_src

* Highlighting

** Treesitter

#+begin_src emacs-lisp

(add-to-list 'auto-mode-alist '("sshd_config\\'" . conf-mode))
(add-to-list 'auto-mode-alist '("ssh_config\\'" . conf-mode))

#+end_src

#+begin_src emacs-lisp

  (use-package treesit-auto
    :config
    ;; (treesit-auto-add-to-auto-mode-alist
    ;; '(("\\.py$" . python-ts-mode)
    ;;   ("\\.rb$" . ruby-ts-mode)
    ;;   ("\\.go$" . go-ts-mode)
    ;;   ("\\.bashrc\\'" . shell-mode)
    ;;   ("\\.zshrc\\'" . shell-mode))) ; Removed the extra parentheses here
    (global-treesit-auto-mode))

  (use-package clojure-ts-mode)

  ;; (setq treesit-language-source-alist
  ;;       '((templ "https://github.com/vrischmann/tree-sitter-templ")
  ;;         (bash "https://github.com/tree-sitter/tree-sitter-bash")
  ;;         (cmake "https://github.com/uyha/tree-sitter-cmake")
  ;;         (css "https://github.com/tree-sitter/tree-sitter-css")
  ;;         ;; (elisp "https://github.com/Wilfred/tree-sitter-elisp")
  ;;         (go "https://github.com/tree-sitter/tree-sitter-go")
  ;;         (gomod "https://github.com/camdencheek/tree-sitter-go-mod")
  ;;         (html "https://github.com/tree-sitter/tree-sitter-html")
  ;;         (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
  ;;         (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
  ;;         (json "https://github.com/tree-sitter/tree-sitter-json")
  ;;         (make "https://github.com/alemuller/tree-sitter-make")
  ;;         (markdown "https://github.com/ikatyang/tree-sitter-markdown")
  ;;         (python "https://github.com/tree-sitter/tree-sitter-python")
  ;;         (toml "https://github.com/tree-sitter/tree-sitter-toml")
  ;;         (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
  ;;         (typescript "https://github.com/tree-sitter/tree-sitter-typescript"
  ;;                     "master" "typescript/src")
  ;;         (yaml "https://github.com/ikatyang/tree-sitter-yaml")
  ;;         (clojure "https://github.com/sogaiu/tree-sitter-clojure")
  ;;         (haskell "https://github.com/tree-sitter/tree-sitter-haskell")
  ;;         (typst "https://github.com/uben0/tree-sitter-typst")
  ;;         (java "https://github.com/tree-sitter/tree-sitter-java")
  ;;         (ruby "https://github.com/tree-sitter/tree-sitter-ruby")
  ;;         (rust "https://github.com/tree-sitter/tree-sitter-rust")))

  ;;   (add-to-list 'auto-mode-alist '("\\.go\\'" . go-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.clj\\'" . clojure-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.sh\\'" . bash-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.toml\\'" . toml-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.py\\'" . python-ts-mode))
  ;; ;; (with-eval-after-load 'yaml-ts-mode
  ;;   (add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-ts-mode))
  ;;   (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-ts-mode))

#+end_src

* Packages
** General

#+begin_src emacs-lisp

(use-package general
  :config
  (general-evil-setup)
  (general-create-definer w/leader-keys
    :states '(normal insert visual emacs)
    :keymaps 'override
    :prefix "SPC" ;; set leader
    :global-prefix "M-SPC") ;; access leader in insert mode

  (w/leader-keys

    ;; Fuzzy finder
    ;; "fb" '(ido-switch-buffer-without-popper :wk "Choose and switch to an active buffer")
    "fb" '(ido-switch-buffer :wk "Choose and switch to an active buffer")
    "fe" '(OpenDiredBufferInCurrentWindow :wk "Open a full screen dired buffer in a current window")
    "ff" '(ivy-fzf-project :wk "Find file fuzzy finder with a git directory as an anchor")
    ;; "fd" '(projectile-find-divy-fzf-currentir :wk "Find file modified")
    "fh" '(ivy-fzf-home :wk "counsel-fzf from home")
    "fc" '(ivy-fzf-current-directory :wk "counsel-fzf from home")
    "fr" '(ivy-fzf-root :wk "counsel-fzf from root")
    ;; "fc" '(ivy-fzf-current :wk "counsel-fzf from root")

    ;; Session management
    "ss" '(save-current-desktop-session :wk "Save the current desktop session into its corresponding directory")
    "sd" '(delete-desktop-session :wk "Delete selected session")
    "sl" '(load-desktop-with-name :wk "Load a desktop session by name, chosen from available sessions")
    "sr" '(rename-desktop-session :wk "Rename a desktop session")

    ;; Org
    "ot" '(todo :wk "Opens the org todo file")

    ;; Paredit
    "pfs" '(paredit-forward-slurp-sexp)

    ;; Hyperbole
    "he" '(hkey-either :wk "Opens the org todo file")

    ;; Tab management
    "tn" '(tab-bar-new-tab :wk "Create a new tab")
    "tx" '(tab-bar-close-tab :wk "Close a tab")
    "tr" '(tab-bar-rename-tab :wk "Rename a tab")

    ;; Org capture
    "n" '(org-capture :wk "Create a quick note")

    ;; Docker
    "D" '(docker-template :wk "Spawn docker template")

    ;; Daemons
    "do" '(daemons-stop :wk "Stop daemon")
    "ds" '(daemons-start :wk "Start daemon")
    "de" '(daemons-enable :wk "Enable daemon")
    "dd" '(daemons-disable :wk "Disable daemon")

    ;; Windows
    "w"  'hydra-window-size/body

    ;; Buffers
    "bc" '(ido-kill-buffer :wk "Close selecetd buffer")
    "bx" '(kill-current-buffer :wk "Close selecetd buffer")

    "rr" '(revert-buffer :wk "Refresh a current buffer")

    ;; Popper
    "pt" '(popper-toggle-type :wk "Expand/contract a buffer")
    "pe" '(popper-toggle-type-original :wk "Expand/contract a buffer")
    "pr" '(my-remove-popper-status-from-frame-buffers :wk "Expand/contract a buffer")

    "xx" '(add-execute-permissions-to-current-file :wk "Close buffer with its window")

    "ch" '(my-hoogle-search :wk "Hoogle search prompt in the shell cmd")

    "zz" '(z :wk "Call zoxide prompt")

    ;; "dd" '(OpenDiredBufferInSplit :wk "Open Dired buffer in split")
    ;; "dt" '(dired-create-empty-file :wk "Create an empty file")

    "ld" '(lsp-find-definition :wk "Open diagnostic list in a separate split")
    "lk" '(lsp-ui-doc-show :wk "Show hover documentation")

    ;; Tramp
    "uu" '(tramp-revert-buffer-with-sudo :wk "Edit file with sudo privileges")
    "ur" '(tramp-revert :wk "Edit file with sudo privileges")

    ;; Evaluation
    "e" '(:ignore t :wk "Evaluate/Eshell")
    ;; "eb" '(eval-buffer :wk "Evaluate elisp in buffer")
    ;; "ed" '(eval-defun :wk "Evaluate defun containing or after point")
    ;; "ex" '(eval-expression :wk "Evaluate and elisp expression")
    ;; "el" '(eval-last-sexp :wk "Evaluate elisp expression before point")
    "er" '(eval-region :wk "Evaluate elisp in region")

    ;; Eshell
    "E" '(eshell :wk "Eshell")
    "en" '(eshell-new :wk "Spawn a new eshell buffer")
    ;; "ee" '(eshell-new-pop :wk "Spawn a new eshell buffer in a popper window")
    "ee" '(eshell-pop :wk "'eshell' command in popper mode")

    )

    (w/leader-keys
      :keymaps 'help-mode-map
      "sl" '(load-desktop-with-name :wk "Load a desktop session by name, chosen from available sessions"))
  )

#+end_src

** Daemons

#+begin_src emacs-lisp

(use-package daemons)
(setq daemons-always-sudo t)

(defun daemons--completing-read (&optional action)
  "Call `completing-read' with the current daemons list.
ACTION is the specific action being performed (e.g., 'stop', 'start')."
  (let ((prompt (if action
                    (format "Daemon name (%s): " action)
                  "Daemon name: ")))
    (completing-read prompt (daemons--list (daemons-init-system-submodule)))))

(defun daemons-stop (name)
  "Stop the daemon with NAME."
  (interactive
   (list
    (daemons--completing-read "stop")))
  (daemons--run-action 'stop name))

(defun daemons-start (name)
  "Start the daemon with NAME."
  (interactive
   (list
    (daemons--completing-read "start")))
  (daemons--run-action 'start name))

(defun daemons-restart (name)
  "Restart the daemon with NAME."
  (interactive
   (list
    (daemons--completing-read "restart")))
  (daemons--run-action 'restart name))

(defun daemons-reload (name)
  "Reload the daemon with NAME."
  (interactive
   (list
    (daemons--completing-read "reload")))
  (daemons--run-action 'reload name))

(defun daemons-enable (name)
  "Enable the daemon with NAME."
  (interactive
   (list
    (daemons--completing-read "enable")))
  (daemons--run-action 'enable name))

(defun daemons-disable (name)
  "Disable the daemon with NAME."
  (interactive
   (list
    (daemons--completing-read "disable")))
  (daemons--run-action 'disable name))

#+end_src

** Proced

#+begin_src emacs-lisp

(use-package proced
  :ensure nil
  :commands proced
  ;; :bind (("C-M-p" . proced))
  :custom
  ;; (proced-tree-flag t)
  (proced-goal-attribute nil)
  (proced-show-remote-processes t)
  (proced-enable-color-flag t)
  (proced-format 'custom)
  :config
  (add-to-list
   'proced-format-alist
   '(custom user pid ppid sess tree pcpu pmem rss start time state (args comm))))

#+end_src

** Avy

#+begin_src emacs-lisp

(use-package avy
  :ensure t
  :config
  ;; Custom command to invoke avy-goto-char-2 across all windows except in Dired buffers
  (defun avy-goto-char-2-all-windows ()
    "Invoke `avy-goto-char-2` across all windows in the current frame, except in Dired buffers."
    (interactive)
    (let ((avy-all-windows t))
      (unless (derived-mode-p 'dired-mode)
        (call-interactively 'evil-avy-goto-char-2))))

  ;; Custom command to switch behavior based on whether the buffer is Dired
  (defun my/conditional-search-or-avy ()
    "Use `evil-search-forward` in Dired buffers, otherwise use `avy-goto-char-2-all-windows`."
    (interactive)
    (if (derived-mode-p 'dired-mode)
        (evil-search-forward)
      (avy-goto-char-2-all-windows)))

  ;; Override `/` keybinding globally in Evil normal state map
  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "/") 'my/conditional-search-or-avy)))

#+end_src

** Async

#+begin_src emacs-lisp

  (use-package async
    :config
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1))

#+end_src

#** Which-key
#
##+begin_src emacs-lisp
#
#(use-package which-key
#  :init
#  (which-key-mode)
#  :config
#  (setq which-key-max-description-length 40))
#
##+end_src

** Transient

#+begin_src emacs-lisp

(use-package transient
  :config
  ;; Define a simple transient for the cp command
  (transient-define-prefix my-eshell-cp-transient ()
    "Transient for the cp command."
    ["cp options"
     ("r" "Recursive" "-r")
     ("v" "Verbose" "-v")
     ("e" "Execute" my-eshell-execute-cp :transient nil)]))

(defun my-eshell-execute-cp ()
  "Function to construct cp command with selected options and insert it into eshell."
  (interactive)
  (let ((args (transient-args 'my-eshell-cp-transient)))
    ;; Construct the cp command with selected options
    (let ((command (concat "cp " (string-join args " "))))
      ;; Insert the command into the eshell buffer
      (insert command)
      ;; Optionally, you can also execute the command immediately
      ;; (eshell-send-input)
      )))

#+end_src

** Search

#+begin_src emacs-lisp

  (use-package rg
    :config
    (rg-enable-default-bindings))

#+end_src

** Xterm-color

#+begin_src emacs-lisp

  (use-package xterm-color)

  (setq comint-output-filter-functions
        (remove 'ansi-color-process-output comint-output-filter-functions))

  (add-hook 'shell-mode-hook
            (lambda ()
              ;; Disable font-locking in this buffer to improve performance
              (font-lock-mode -1)
              ;; Prevent font-locking from being re-enabled in this buffer
              (make-local-variable 'font-lock-function)
              (setq font-lock-function (lambda (_) nil))
              (add-hook 'comint-preoutput-filter-functions 'xterm-color-filter nil t)))

  ;; Compilation buffers
  (setq compilation-environment '("TERM=xterm-256color"))

  (defun my/advice-compilation-filter (f proc string)
    (funcall f proc (xterm-color-filter string)))

  (advice-add 'compilation-filter :around #'my/advice-compilation-filter)

#+end_src

** Circe

#+begin_src emacs-lisp

  (use-package circe)

#+end_src

** Docker

#+begin_src emacs-lisp

(use-package docker)

(defun container-map-id (container-name)
  "Display the UID and GID maps of a Docker container.
Ask for the name of a Docker container, retrieve its PID, and display the UID and GID maps."
  (interactive "sContainer name: ")
  (let* ((pid (string-trim (shell-command-to-string (format "docker inspect --format '{{.State.Pid}}' %s" container-name))))
         (uid-map-file (format "/proc/%s/uid_map" pid))
         (gid-map-file (format "/proc/%s/gid_map" pid)))
    (if (and (not (string-empty-p pid))
             (file-exists-p uid-map-file)
             (file-exists-p gid-map-file))
        (with-output-to-temp-buffer "*Docker ID Maps*"
          (princ (format "UID and GID maps for container '%s' (PID: %s):\n\n" container-name pid))
          (princ "UID map:\n")
          (princ (with-temp-buffer
                   (insert-file-contents uid-map-file)
                   (buffer-string)))
          (princ "\nGID map:\n")
          (princ (with-temp-buffer
                   (insert-file-contents gid-map-file)
                   (buffer-string))))
      (message "Failed to retrieve UID and/or GID maps for container '%s'" container-name))))

(defun docker-template ()
  "Create docker.el windows with a specific layout"
  (interactive)
  (delete-other-windows)
  (docker-images)
  (docker-containers)
  (transpose-frame))

(defun my-docker-shell ()
  (interactive)
  (let ((container-id (read-string "Enter container ID: ")))
    (comint-run (format "docker exec -it %s /bin/sh" container-id))))

#+end_src

** Folds

#+begin_src emacs-lisp

  (use-package vimish-fold
    :config
    (vimish-fold-global-mode 1))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "zf") 'vimish-fold)
    (define-key evil-visual-state-map (kbd "zf") 'vimish-fold)
    (define-key evil-normal-state-map (kbd "zt") 'vimish-fold-toggle)
    (define-key evil-normal-state-map (kbd "zd") 'vimish-fold-delete))

#+end_src

** Ispell

#+begin_src emacs-lisp

  ;; (setq ispell-program-name "hunspell")
  ;; (setq ispell-really-huspell t)

  ;; ;; For hunspell, you might need to specify the dictionary file
  ;; (setq ispell-local-dictionary "en_US")
  ;; (setq ispell-local-dictionary-alist
  ;;       '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))

  (setq ispell-alternate-dictionary "/usr/share/hunspell/en_US.dic")

#+end_src

** Jinx

#+begin_src emacs-lisp

  ;; (use-package jinx
  ;;   ;; :hook
  ;;   ;; (dolist (hook '(text-mode-hook prog-mode-hook conf-mode-hook))
  ;;   ;; (add-hook hook #'jinx-mode))
  ;;   :bind (("M-$" . jinx-correct)
  ;;          ("C-M-$" . jinx-languages)))

#+end_src

** Completion

*** Snippets

#+begin_src emacs-lisp

  (use-package yasnippet
    :config
    (yas-global-mode 1)
    ;; Add your snippets directory to `yas-snippet-dirs`
    ;; (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets/org-mode/")
    ;; (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets/org-mode/")
    ;; Load the snippets
    (yas-reload-all))

#+end_src

*** Orderless

#+begin_src emacs-lisp

  (use-package orderless
    :init
    ;; ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))

#+end_src

*** Corfu/Cape

#+begin_src emacs-lisp

  (defun my-eshell-directory-completions ()
    "Generate a list of all directories in the current working directory, including hidden ones."
    (let ((current-dir (eshell/pwd)))
      (cl-remove-if-not
      #'file-directory-p
      (directory-files current-dir t nil t))))

  (defun my-eshell-completion-at-point ()
    "Provide completion for Eshell using custom directory completions."
    (let ((bounds (bounds-of-thing-at-point 'filename)))
      (when bounds
        (let* ((start (car bounds))
              (end (cdr bounds))
              (input (buffer-substring-no-properties start end))
              (completions (my-eshell-directory-completions))
              (matches (cl-remove-if-not
                        (lambda (dir)
                          (string-prefix-p input (file-name-nondirectory dir)))
                        completions)))
          (when matches
            (list start end (mapcar #'file-name-nondirectory matches) :exclusive 'no))))))

  (defun my-eshell-setup ()
    "Set up custom completions and key bindings for Eshell."
    (add-to-list 'completion-at-point-functions 'my-eshell-completion-at-point))

  (add-hook 'eshell-mode-hook 'my-eshell-setup)

  ;; (with-eval-after-load 'esh-mode
  ;;   (define-key eshell-mode-map (kbd "TAB") 'completion-at-point))

    ;; Corfu setup
  (use-package corfu
    :init
    (global-corfu-mode)
    ;; :custom
    ;; (corfu-auto nil)
    ;; (corfu-min-length 2)
    :config
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)
    (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
    (corfu-echo-mode)
    (corfu-history-mode)
    (corfu-popupinfo-mode))

  ;; (defun my-enable-corfu-in-eshell ()
  ;;   "Enable Corfu auto-completion in Eshell and set up completion functions."
  ;;   (setq-local corfu-auto t))

  ;; (add-hook 'eshell-mode-hook #'my-enable-corfu-in-eshell)

  (with-eval-after-load 'evil
    (evil-define-key 'insert global-map (kbd "TAB") #'completion-at-point))

  (with-eval-after-load 'corfu
    (define-key corfu-map (kbd "RET") nil))

  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer."
    (when (local-variable-p 'completion-at-point-functions)
      ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion
      (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup
                  corfu-popupinfo-delay nil)
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)

  ;; Cape setup
  (use-package cape
    :ensure t
    :after corfu
    :init
    (setq completion-at-point-functions
          (list #'cape-file
                #'cape-dabbrev
                #'cape-elisp-block)))


  (straight-use-package
   '(fish-completion :host github :repo "LemonBreezes/emacs-fish-completion"))

  (when (and (executable-find "fish")
           (require 'fish-completion nil t))
  (global-fish-completion-mode))

#+end_src

*** Company

#+begin_src emacs-lisp

    ;; (use-package company
    ;;   :init
    ;;   (add-hook 'after-init-hook 'global-company-mode)
    ;;   :config
    ;;   (add-to-list 'company-backends 'company-files)
    ;;   (setq company-require-match nil)
    ;;   (setq company-minimum-prefix-length 1)
    ;;   (setq company-idle-delay nil))

  ;; (use-package company
  ;;   :init
  ;;   (add-hook 'after-init-hook 'global-company-mode)
  ;;   :config
  ;;   (setq company-require-match nil)
  ;;   ;; Set default company-mode settings
  ;;   (setq company-minimum-prefix-length 3
  ;;         company-idle-delay nil) ;; Disable automatic suggestions globally

  ;;   ;; Add company-files to the list of backends
  ;;   (add-to-list 'company-backends 'company-files)

  ;;   ;; Function to enable automatic suggestions in eshell
  ;;   (defun my-company-mode-setup-eshell ()
  ;;     (setq-local company-idle-delay 0.1)) ;; Enable automatic suggestions in eshell

  ;;   ;; Add the setup function to eshell-mode-hook
  ;;   (add-hook 'eshell-mode-hook 'my-company-mode-setup-eshell))

  ;; (defun my/company-manual-complete ()
  ;;   "Enable company-mode and call company-complete."
  ;;   (interactive)
  ;;   (unless company-mode
  ;;     (company-mode 1))
  ;;   (company-complete))

  ;; (with-eval-after-load 'evil
  ;;   (defun my-evil-insert-state-setup ()
  ;;     (unless (minibufferp)
  ;;       (define-key evil-insert-state-local-map (kbd "TAB") 'my/company-manual-complete)))

  ;;   (add-hook 'evil-insert-state-entry-hook 'my-evil-insert-state-setup))

#+end_src

** Acess to ENV variables

#+begin_src emacs-lisp

    (use-package exec-path-from-shell
      :config
      (exec-path-from-shell-initialize)
      (exec-path-from-shell-copy-env "FZF_DEFAULT_COMMAND")
      (exec-path-from-shell-copy-env "SSH_AUTH_SOCK")
      (exec-path-from-shell-copy-env "NOTIFY_TOKEN")
      (exec-path-from-shell-copy-env "SHELF_TOKEN")
      (exec-path-from-shell-copy-env "SHELF_DB_USER")
      (exec-path-from-shell-copy-env "SHELF_DB_NAME")
      (exec-path-from-shell-copy-env "SHELF_DB_PASS")
      (exec-path-from-shell-copy-env "SHELF_DB_PORT")
      )

#+end_src

** Sudo Edit

#+begin_src emacs-lisp

  (use-package sudo-edit
    :config
      (w/leader-keys
        "sf" '(sudo-edit-find-file :wk "Sudo find file")))
        ;; "se" '(sudo-edit :wk "Sudo edit file")))

#+end_src

** Symex

#+begin_src emacs-lisp

  ;; Initializing symex causing troubles with pressing parenthesis in the insert mode
  ;; (use-package symex
  ;;   :config
  ;;   (symex-initialize)
  ;;   (global-set-key (kbd "C-;") 'symex-mode-interface))  ; or whatever keybinding you like

#+end_src

** Paredit

#+begin_src emacs-lisp

  (use-package paredit)

#+end_src

** Hyperbole

#+begin_src emacs-lisp

  ;; (defun my/hyperbole-disable-key-bindings-after-init-hook ()
  ;;   ;; Undefine conflicting keys in the hyperbole mode map.
  ;;   (define-key hyperbole-mode-map (kbd "M-RET") nil)
  ;;   ;; Add more key unbindings as needed.
  ;; )

  ;; (use-package hyperbole
  ;;   :ensure t
  ;;   :config
  ;;   ;; Add a custom after-init-hook to adjust Hyperbole's keybindings
  ;;   ;; after its own initialization process has completed.
  ;;   (add-hook 'after-init-hook #'my/hyperbole-disable-key-bindings-after-init-hook t))

  ;;   (with-eval-after-load 'hyperbole
  ;;     (define-key hyperbole-mode-map (kbd "M-o") nil))

  ;; (defal notes "/home/wurfkreuz/.secret_dotfiles/org/%s")
  ;; (defal clj_scr_Comments "/home/wurfkreuz/.secret_dotfiles/org/clojure/scripts/%s")

#+end_src

** Zoxide

#+begin_src emacs-lisp

  (straight-use-package
   '(zoxide :host gitlab :repo "Vonfry/zoxide.el"))

#+end_src

** Cider

#+begin_src emacs-lisp

  (use-package cider
    :config
    (setq cider-eldoc-display-for-symbol-at-point nil)
    (setq cider-show-error-buffer nil)
    (add-hook 'cider-mode-hook (lambda () (eldoc-mode -1))))

  (setq eldoc-documentation-function (lambda () nil))

  ;; (with-eval-after-load 'evil
  ;;   (with-eval-after-load 'cider
  ;;     ;; Define C-M-x for normal state to evaluate the top-level form around point (function)
  ;;     (evil-define-key 'normal cider-mode-map (kbd "C-M-x") 'cider-eval-defun-at-point)
  ;;     (evil-define-key 'normal cider-repl-mode-map (kbd "C-M-x") 'cider-eval-defun-at-point)

  ;;     ;; Define C-M-x for visual state to evaluate the selected region
  ;;     (evil-define-key 'visual cider-mode-map (kbd "C-M-x") 'cider-eval-region)
  ;;     (evil-define-key 'visual cider-repl-mode-map (kbd "C-M-x") 'cider-eval-region)))

  (with-eval-after-load 'evil
  ;; CIDER
  (with-eval-after-load 'cider
    ;; Define C-M-x for normal state to evaluate the top-level form around point (function)
    (evil-define-key 'normal cider-mode-map (kbd "C-M-x") 'cider-eval-defun-at-point)
    (evil-define-key 'normal cider-repl-mode-map (kbd "C-M-x") 'cider-eval-defun-at-point)
    ;; Define C-M-x for visual state to evaluate the selected region
    (evil-define-key 'visual cider-mode-map (kbd "C-M-x") 'cider-eval-region)
    (evil-define-key 'visual cider-repl-mode-map (kbd "C-M-x") 'cider-eval-region))

  ;; Emacs Lisp
  (with-eval-after-load 'elisp-mode
    (evil-define-key 'normal emacs-lisp-mode-map (kbd "C-M-x") 'eval-defun)
    (evil-define-key 'visual emacs-lisp-mode-map (kbd "C-M-x") 'eval-region))

  ;; Org Mode
  (with-eval-after-load 'org
    (evil-define-key 'normal org-mode-map (kbd "C-M-x") 'org-babel-execute-src-block)
    ;; For visual state in org-mode, you might want to keep the default behavior
    ;; or define a custom function to evaluate a region if needed.
    ))

#+end_src

#+RESULTS:

#** Projectile
#
##+begin_src emacs-lisp
#
#  (defun my/projectile-project-root-advice (original-projectile-root &rest args)
#    "Advice to make Projectile recognize custom project roots."
#    (or
#     ;; First, check if the specific directory should be treated as a project root.
#     (when (string-prefix-p "/home/wurfkreuz/.secret_dotfiles/org" (expand-file-name default-directory))
#       "/home/wurfkreuz/.secret_dotfiles/org/")
#     ;; Next, look for 'bb.edn' up the directory tree to identify a project root.
#     (let ((current-dir (expand-file-name default-directory))
#           (project-root nil))
#       (while (and (not project-root) (not (string= current-dir "/")))
#         (when (file-exists-p (concat current-dir "bb.edn"))
#           (setq project-root current-dir))
#         (setq current-dir (file-name-directory (directory-file-name current-dir))))
#       project-root)
#     ;; Fallback to the original projectile root detection if none of the above conditions are met.
#     (apply original-projectile-root args)))
#
#  (use-package projectile
#    :config
#    (projectile-mode 1)
#    (advice-add 'projectile-project-root :around #'my/projectile-project-root-advice))
#
##+end_src

** Mentor

#+begin_src emacs-lisp

  (use-package mentor)

#+end_src

** Wgrep

#+begin_src emacs-lisp

  (use-package wgrep)

#+end_src

** Embark

#+begin_src emacs-lisp

  (use-package embark
    :bind
    ("C-M-;" . embark-act))

#+end_src

** Ivy/Counsel

#+begin_src emacs-lisp

(use-package counsel
  :after ivy
  :config
  (define-key shell-mode-map (kbd "M-r") 'counsel-shell-history)
  (counsel-mode))
(global-set-key (kbd "C-c C-y") 'cousel-yank-pop)

(use-package ivy
  :bind
  ;; ivy-resume resumes the last Ivy-based completion.
  (("C-c C-r" . ivy-resume)
   ("C-x B" . ivy-switch-buffer-other-window))
  :custom
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
  (setq enable-recursive-minibuffers t)
  :config
  (defun my/ivy-evil-delete-line ()
    "Delete the current line in Ivy minibuffer without affecting the newline."
    (interactive)
    (let ((inhibit-read-only t))
      (evil-delete-line (line-beginning-position) (line-end-position))))
  (evil-define-key 'normal ivy-minibuffer-map (kbd "dd") 'my/ivy-evil-delete-line)
  (ivy-mode))

(defun my-ivy-shell-command-history ()
  "Use `ivy-read` to search through shell command history."
  (interactive)
  (let ((history (if (eq this-command 'async-shell-command)
                     async-shell-command-history
                   shell-command-history)))
    (ivy-read "Shell command history: " history)))

(defun my-shell-command (command &optional output-buffer error-buffer)
  "Run shell command with custom history."
  (interactive (list (my-ivy-shell-command-history)
                     current-prefix-arg
                     shell-command-default-error-buffer))
  (shell-command command output-buffer error-buffer))

(defun my-async-shell-command (command &optional output-buffer error-buffer)
  "Run async shell command with custom history."
  (interactive (list (my-ivy-shell-command-history)
                     current-prefix-arg
                     shell-command-default-error-buffer))
  (async-shell-command command output-buffer error-buffer))

(global-set-key (kbd "M-!") 'my-shell-command)
(global-set-key (kbd "M-&") 'my-async-shell-command)

;; (use-package ivy-posframe
;;   :ensure t
;;   :after ivy
;;   :config
;;   (ivy-posframe-mode 1))
;; (setq ivy-posframe-width 50)
;; (setq ivy-posframe-display-functions-alist
;;       '((counsel-esh-history . ivy-posframe-display-at-window-center)))

;; To display icons correctly, you should run M-x all-the-icons-install-fonts to install the necessary fonts.
(use-package all-the-icons-ivy-rich
  :init
  (all-the-icons-ivy-rich-mode 1))

(use-package ivy-rich
  :after ivy
  :ensure t
  :init (ivy-rich-mode 1) ;; this gets us descriptions in M-x.
  :custom
  (ivy-virtual-abbreviate 'full
                          ivy-rich-switch-buffer-align-virtual-buffer t
                          ivy-rich-path-style 'abbrev))

(defun counsel-find-file-check-dir ()
  "Like `counsel-find-file', but use `find-file-check-dir' instead of `find-file'."
  (interactive)
  (let* ((current-dir (if (eq major-mode 'dired-mode)
                          "."
                        (buffer-file-name))))
    (ivy-read "Find file: " #'read-file-name-internal
              :matcher #'counsel--find-file-matcher
              :action #'find-file-check-dir
              :preselect current-dir
              :require-match 'confirm-after-completion
              :history 'file-name-history
              :keymap counsel-find-file-map
              :caller 'counsel-find-file)))

(global-set-key (kbd "C-x f") 'counsel-find-file-check-dir)

(defun ivy-fzf-project ()
  "Run a customized `ivy-fzf`-like file selection using `fd` from the current project directory."
  (interactive)
  (let ((default-directory (projectile-project-root))
        (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --hidden"))
    (ivy-read "Find file in project: " (split-string (shell-command-to-string fzf-command) "\n")
              :action (lambda (f)
                        (find-file (expand-file-name f default-directory))))))

(defun ivy-fzf-home ()
  "Run a customized `ivy-fzf`-like file selection using `fd` from START-DIRECTORY."
  (interactive)
  (let ((default-directory "~/")
        (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --hidden"))
    (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
              :action (lambda (f)
                        (find-file (expand-file-name f default-directory))))))

(defun ivy-fzf-current-directory ()
  "Run a customized `ivy-fzf`-like file selection using `fd` from the current directory."
  (interactive)
  (let ((fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --hidden"))
    (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
              :action (lambda (f)
                        (find-file (expand-file-name f default-directory))))))

(defun ivy-fzf-root ()
  "Run a customized `ivy-fzf`-like file selection using `fd` from START-DIRECTORY."
  (interactive)
  (let ((default-directory "/")
        (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --hidden"))
    (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
              :action (lambda (f)
                        (find-file (expand-file-name f default-directory))))))

(defun insert-path-from-ivy-fzf-home ()
  "Insert the path of a file selected by `ivy-fzf` from the home directory into the current buffer."
  (interactive)
  (let ((default-directory "~/")
        (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --type f --hidden"))
    (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
              :action (lambda (f)
                        (insert (expand-file-name f default-directory))))))

(defun insert-path-from-ivy-fzf-project ()
  "Insert the path of a file selected by `ivy-fzf` from a project directory into the current buffer."
  (interactive)
  (let ((default-directory (projectile-project-root))
        (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --type f --hidden"))
    (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
              :action (lambda (f)
                        (insert (expand-file-name f default-directory))))))

(defun insert-path-from-ivy-fzf-root ()
  "Insert the path of a file selected by `ivy-fzf` from the root directory into the current buffer."
  (interactive)
  (let ((default-directory "/")
        (fzf-command "fd --hidden --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp --exclude '.config/vivaldi' --exclude snap --type f --hidden"))
    (ivy-read "Find file: " (split-string (shell-command-to-string fzf-command) "\n")
              :action (lambda (f)
                        (insert (expand-file-name f default-directory))))))

;; (defun counsel-projectile-find-file-or-dir ()
;;   "Use `counsel-find-file` to find a file or directory in the current projectile project."
;;   (interactive)
;;   (let ((project-root (projectile-project-root)))
;;     (if project-root
;;         (counsel-find-file project-root)
;;       (message "Not in a projectile project!"))))

#+end_src

** With-editor

#+begin_src emacs-lisp

  (use-package with-editor
    :init
    (add-hook 'shell-mode-hook  'with-editor-export-editor)
    (add-hook 'eshell-mode-hook 'with-editor-export-editor)
    (add-hook 'term-exec-hook   'with-editor-export-editor))

  (defun suppress-with-editor-export-message (orig-fun &rest args)
    (let ((inhibit-message t))
      (apply orig-fun args)))

  (with-eval-after-load 'with-editor
    (advice-add 'with-editor-export-editor :around #'suppress-with-editor-export-message))

#+end_src

** Cron

#+begin_src emacs-lisp

  ;; (use-package crontab-mode)

  (straight-use-package
   '(emacs-crontab-mode :host gitlab :repo "Bacaliu/emacs-crontab-mode"))
;;
;;  (require emacs-crontab-mode)

#+end_src

** Systemd

#+begin_src emacs-lisp

;; (use-package systemd) 

#+end_src

** Prescient

#+begin_src emacs-lisp

  ;; (use-package ivy-prescient
  ;;   :after counsel
  ;;   :config
  ;;   (ivy-prescient-mode 1))

#+end_src

** Fzf

#+begin_src emacs-lisp

  (use-package fzf)

  (defun fzf-from-home-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
        and exclude certain directories but with an ability to interactively change
        the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    (let ((default-directory "~/"))
      (fzf-directory)))

  (defun fzf-from-root-with-fd ()
    "Starts fzf from the user's home directory using fd to include hidden files
        and exclude certain directories but with an ability to interactively change
        the searching directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")
    (let ((default-directory "/"))
      (fzf-directory)))

  (defun fzf-notes ()
    "Start fzf in the notes directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    (let ((default-directory "~/.secret_dotfiles/org"))
      (fzf-directory)))

  ;; (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")

  (defun fzf-from-root-no-prompt ()
    "Starts fzf from the user's root directory using fd to include hidden files
    and exclude certain directories without prompting for a directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git --exclude .snapshots --exclude opt --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run --exclude sbin --exclude srv --exclude sys --exclude tmp . /")
    (fzf))

  (defun fzf-from-home-no-prompt ()
    "Starts fzf from the user's home directory using fd to include hidden files
      and exclude certain directories without prompting for a directory."
    (interactive)
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git . /home/wurfkreuz")
    (fzf))

  (defun fzf-from-current-with-fd ()
    "Starts fzf from the current directory using fd to include hidden files
     and exclude certain directories. Works both locally and on remote servers."
    (interactive)
    ;; Set the FZF_DEFAULT_COMMAND environment variable
    (setenv "FZF_DEFAULT_COMMAND" "fd --hidden --follow --exclude .git .")
    ;; Check if the current directory is a TRAMP directory
    (let ((tramp-address (file-remote-p default-directory)))
      (if tramp-address
          ;; If we're in a TRAMP directory, use the extracted address
          (fzf-directory tramp-address)
        ;; If not in a TRAMP directory, use the local home directory
        (fzf-directory "~/"))))

  (setq fzf/args "-x --color bw --print-query --margin=1,0 --no-hscroll --inline-info --bind ctrl-n:down,ctrl-p:up")

#+end_src

** Helpful

#+begin_src emacs-lisp

  (use-package helpful
    :config
    (global-set-key (kbd "C-h f") #'helpful-callable)
    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)
    (global-set-key (kbd "C-h x") #'helpful-command)
    (setq counsel-describe-function-function #'helpful-callable)
    (setq counsel-describe-variable-function #'helpful-variable))

#+end_src

** Hydra

#+begin_src emacs-lisp

  (defun my-enlarge-window-horizontally ()
    "Enlarge the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (shrink-window-horizontally 5)
      (enlarge-window-horizontally 5)))

  (defun my-shrink-window-horizontally ()
    "Shrink the current window horizontally in a more intuitive way."
    (interactive)
    (if (window-at-side-p (selected-window) 'right)
        (enlarge-window-horizontally 5)
      (shrink-window-horizontally 5)))

  (use-package hydra
    :config
    (defhydra hydra-window-size (:color red)
      "window size"
      ("h" my-shrink-window-horizontally "shrink horizontally")
      ("l" my-enlarge-window-horizontally "enlarge horizontally")
      ("k" (lambda () (interactive) (shrink-window 3)) "shrink vertically")
      ("j" (lambda () (interactive) (enlarge-window 3)) "enlarge vertically")
      ("t" transpose-frame "transpose windows")
      ("q" nil "quit")))

#+end_src

* Dired

#+begin_src emacs-lisp

      ;; (add-hook 'dired-mode-hook
      ;;         (lambda ()
      ;;           (wdired-change-to-wdired-mode)))

      (add-to-list 'auto-revert-remote-files "/sudo:root@localhost:/etc/")
      (add-to-list 'auto-revert-remote-files "/sudo:root@localhost:/")

  ;;    ;; For some reason enbling trashing not only breaks deletion, but also
  ;;    ;; copying and probably moving both in eshell and dired.
    (setq delete-by-moving-to-trash t
          trash-directory "~/.local/share/trash/")

      (setq wdired-allow-to-create-files t)
      (setq wdired-allow-to-change-permissions t)

      (setq evil-move-cursor-back nil)
      (add-hook 'wdired-mode-hook #'evil-normal-state)

      (defun my-dired-do-symlink-with-sudo ()
        "Create a symlink, using sudo if necessary."
        (interactive)
        (let* ((files (dired-get-marked-files))
              (default-directory (if (file-remote-p default-directory)
                                      (tramp-file-name-localname (tramp-dissect-file-name default-directory))
                                    default-directory))
              (target (read-file-name "Symlink to: " default-directory))
              (sudo-target (if (file-writable-p (file-name-directory target))
                                target
                              (concat "/sudo::" target))))
          (dolist (file files)
            (let ((link-name (read-string (format "Link name for %s: " (file-name-nondirectory file)) (file-name-nondirectory file))))
              (make-symbolic-link file (expand-file-name link-name (file-name-directory sudo-target)) t)))))

      (defun my-dired-setup ()
        (evil-define-key 'normal dired-mode-map (kbd "S") 'my-dired-do-symlink-with-sudo))

      (add-hook 'dired-mode-hook 'my-dired-setup)

      ;; (defun my-dired-do-delete-with-sudo ()
      ;;   "Attempt to move the marked files to trash, using sudo if necessary."
      ;;   (interactive)
      ;;   (let ((files (dired-get-marked-files)))
      ;;     (dolist (file files)
      ;;       (if (yes-or-no-p (format "Move %s to trash? " (file-name-nondirectory file)))
      ;;           (if (file-writable-p (file-name-directory file))
      ;;               (dired-delete-file file 'trash)
      ;;             (let ((sudo-file (concat "/sudo::" file)))
      ;;               (when (yes-or-no-p (format "Insufficient permissions to move %s to trash. Retry with sudo? " (file-name-nondirectory file)))
      ;;                 (with-temp-buffer
      ;;                   (cd (file-name-directory sudo-file))
      ;;                   (dired-delete-file sudo-file 'trash))))))))
      ;;   (revert-buffer))

      ;; (evil-define-key 'normal dired-mode-map (kbd "D") 'my-dired-do-delete-with-sudo)

;; (defun dired-run-bak-on-marked-files (beg end)
;; "Run the 'bak' script on marked files or visually selected files in Dired."
;; (interactive
;;  (if (use-region-p)
;;      (list (region-beginning) (region-end)) ; If there's an active region, use it
;;    (list nil nil))) ; Otherwise, process marked files
;; (if (and beg end)
;;     ;; If beg and end are provided, process files in the region
;;     (save-excursion
;;       (goto-char beg)
;;       (let ((end-marker (copy-marker end)))
;;         (while (< (point) end-marker)
;;           (when (dired-move-to-filename)
;;             (let ((file (dired-get-filename nil t)))
;;               (start-process "bak-process" nil "bak" file)))
;;           (dired-next-line 1))))
;;   ;; If no region is active, process marked files
;;   (let ((files (dired-get-marked-files)))
;;     (dolist (file files)
;;       (start-process "bak-process" nil "bak" file))))
;; ;; Exit visual mode if in Evil mode
;; (when (bound-and-true-p evil-local-mode)
;;   (evil-normal-state)))

(defun dired-run-bak-on-marked-files (beg end)
  "Run the 'bak' script on marked files or visually selected files in Dired, with an option to copy."
  (interactive
  (if (use-region-p)
      (list (region-beginning) (region-end)) ; If there's an active region, use it
    (list nil nil))) ; Otherwise, process marked files
  ;; Prompt the user to ask if they want to copy the files.
  (let ((copy-flag (if (yes-or-no-p "Copy files? ") "-c" nil)))
    (if (and beg end)
        ;; If beg and end are provided, process files in the region
        (save-excursion
          (goto-char beg)
          (let ((end-marker (copy-marker end)))
            (while (< (point) end-marker)
              (when (dired-move-to-filename)
                (let ((file (dired-get-filename nil t)))
                  ;; Conditionally include the -c flag based on user input
                  (if copy-flag
                      (start-process "bak-process" nil "bak" copy-flag file)
                    (start-process "bak-process" nil "bak" file))))
              (dired-next-line 1))))
      ;; If no region is active, process marked files
      (let ((files (dired-get-marked-files)))
        (dolist (file files)
          ;; Conditionally include the -c flag based on user input
          (if copy-flag
              (start-process "bak-process" nil "bak" copy-flag file)
            (start-process "bak-process" nil "bak" file))))))
  ;; Exit visual mode if in Evil mode
  (when (bound-and-true-p evil-local-mode)
    (evil-normal-state)))

    (defun my-dired-setup ()
      (evil-define-key 'normal dired-mode-map (kbd "B") 'dired-run-bak-on-marked-files)
      (evil-define-key 'visual dired-mode-map (kbd "B") 'dired-run-bak-on-marked-files))

    (add-hook 'dired-mode-hook 'my-dired-setup)

      ;; (defun my-dired-setup ()
      ;;   (evil-define-key 'normal dired-mode-map (kbd "B") 'dired-toggle-bak-extension)
      ;;   (evil-define-key 'visual dired-mode-map (kbd "B") 'dired-toggle-bak-extension))

(defun dired-next-line-preserve-column (arg)
  "Move to the next line in Dired, preserving the current column position."
  (interactive "p")
  (let ((col (current-column)))
    (dired-next-line arg)
    (move-to-column col)))

(defun dired-previous-line-preserve-column (arg)
  "Move to the previous line in Dired, preserving the current column position."
  (interactive "p")
  (let ((col (current-column)))
    (dired-previous-line arg)
    (move-to-column col)))

(with-eval-after-load 'dired
  (evil-define-key 'normal dired-mode-map
    "j" 'dired-next-line-preserve-column
    "k" 'dired-previous-line-preserve-column))


;; (defun my-create-path-and-view-dir ()
;;   "Prompt for a file path, create directories and file as needed, then view the parent directory."
;;   (interactive)
;;   (let* ((path (read-file-name "Enter path: "))
;;         (dir (file-name-directory path))
;;         (file (file-name-nondirectory path)))
;;     ;; Create directories as needed
;;     (when dir
;;       (make-directory dir t))
;;     ;; Create the file if it doesn't already exist
;;     (unless (file-exists-p path)
;;       (with-temp-buffer
;;         (write-file path)))
;;     ;; Switch to viewing the parent directory in Dired mode
;;     (dired dir)))

;; (global-set-key (kbd "C-x C-f") 'my-create-path-and-view-dir)

#+end_src


** Dired keybindings

#+begin_src emacs-lisp

  ;; (evil-define-key 'normal dired-mode-map
  ;;   (kbd "+") 'dired-create-directory))

#+end_src

* Tramp

#+begin_src emacs-lisp

  (require 'tramp)

  ;; (setq tramp-ssh-controlmaster-options (format "-i %s" "~/.ssh/git"))
  ;; (add-to-list 'tramp-connection-properties
  ;;              (list (regexp-quote "/ssh:")
  ;;                    "direct-async-process" t))

  ;; ;; cache file-name forever
  ;; (setq remote-file-name-inhibit-cache nil)

  ;; ;; make sure vc stuff is not making tramp slower
  ;; (setq vc-ignore-dir-regexp
  ;;       (format "%s\\|%s"
  ;;               vc-ignore-dir-regexp
  ;;               tramp-file-name-regexp))

  ;; ;; not sure why we have this? just cargo-culting from an answer I saw
  ;; ;; online.
  ;; (setq tramp-verbose 1)

  ;; ;; projectile has the fun side-effect of wanting to calculate the
  ;; ;; project name, which makes tramp oh-so-much-slower.
  ;; (setq projectile-mode-line "Projectile")

  ;; I get errors with files opened through tramp with elevated privilages. This
  ;; code tries to fix that but i think it might lead to some unexpected
  ;; behavior.

  (defun my/disable-lockfiles-for-tramp ()
    "Disable lockfiles for tramp."
    (when (and buffer-file-name
              (file-remote-p buffer-file-name))
      (setq-local create-lockfiles nil)))

  (add-hook 'find-file-hook #'my/disable-lockfiles-for-tramp)
  (add-hook 'before-save-hook #'my/disable-lockfiles-for-tramp)

  ;; (defun kill-tramp-buffers ()
  ;;   "Kill all TRAMP buffers."
  ;;   (interactive)
  ;;   (let ((killed-buffers 0))
  ;;     (dolist (buffer (buffer-list))
  ;;       (let ((buffer-name (buffer-name buffer))
  ;;             (file-name (buffer-file-name buffer)))
  ;;         (when (or (and buffer-name
  ;;                       (or (string-match-p "\\`\\*tramp/" buffer-name)
  ;;                           (string-match-p "\\`\\*eshell:/" buffer-name)
  ;;                           (string-match-p "\\`/sudo:" buffer-name)))
  ;;                   (and file-name
  ;;                       (file-remote-p file-name)))
  ;;           (message "Identified TRAMP buffer: %s, File: %s" buffer-name (or file-name "No file"))
  ;;           (kill-buffer buffer)
  ;;           (setq killed-buffers (1+ killed-buffers)))))
  ;;     (message "Killed %d TRAMP-related buffer(s)" killed-buffers)))

  ;; (add-hook 'kill-emacs-hook #'kill-tramp-buffers)

  (defun extract-local-path-from-tramp-buffer-and-display ()
    (interactive)
    "Extract the local part of the path from a TRAMP buffer and display it."
    (let* ((tramp-path (buffer-file-name)) ; Get the current buffer's file name
          (path-components (tramp-dissect-file-name tramp-path)) ; Dissect the TRAMP path
          (local-part (tramp-file-name-localname path-components))) ; Extract the local part
      (message "%s" local-part))) ; Display the local part as a message

  (defun tramp-revert ()
    "Extract the local part of the path from a TRAMP buffer and attempt to reopen the file."
    (interactive)
    (let* ((tramp-path (buffer-file-name)) ; Get the current buffer's file name
          (path-components (tramp-dissect-file-name tramp-path)) ; Dissect the TRAMP path
          (local-part (tramp-file-name-localname path-components))) ; Extract the local part
      ;; Kill the current buffer before attempting to reopen the file
      (kill-current-buffer)
      ;; Attempt to reopen the file with the extracted local path
      (find-file local-part)))

  ;; (defun revert-all-tramp-buffers-to-local-permissions ()
  ;;   "Attempt to revert all TRAMP buffers to local permissions."
  ;;   (interactive)
  ;;   (let ((reverted-buffers 0))
  ;;     (dolist (buffer (buffer-list))
  ;;       (with-current-buffer buffer
  ;;         (let ((buffer-name (buffer-name buffer))
  ;;               (file-name (buffer-file-name buffer)))
  ;;           (when (or (and buffer-name
  ;;                         (or (string-match-p "\\`\\*tramp/" buffer-name)
  ;;                             (string-match-p "\\`\\*eshell:/" buffer-name)
  ;;                             (string-match-p "\\`/sudo:" buffer-name)))
  ;;                       (and file-name
  ;;                           (file-remote-p file-name)))
  ;;             (message "Attempting to revert TRAMP buffer: %s, File: %s" buffer-name (or file-name "No file"))
  ;;             (tramp-revert-to-local-permissions)
  ;;             (setq reverted-buffers (1+ reverted-buffers))))))
  ;;     (message "Attempted to revert %d TRAMP-related buffer(s) to local permissions" reverted-buffers)))

  ;; (add-hook 'kill-emacs-hook #'revert-all-tramp-buffers-to-local-permissions)

#+end_src

* Shells and Terminals
** Eshell

#+begin_src emacs-lisp

(setq eshell-destroy-buffer-when-process-dies t)

(use-package eshell-syntax-highlighting
  :after esh-mode  ;; don't change to 'eshell-mode'
  :config
  (eshell-syntax-highlighting-global-mode +1))

(add-hook 'eshell-mode-hook 'eshell-hist-mode)  ; Enable Eshell history mode
;;(add-hook 'eshell-mode-hook 'eshell-toggle-direct-send) ;; !!! very careful !!!

(setq eshell-rc-script (concat user-emacs-directory "eshell/eshelrc")
      eshell-history-size 100000
      eshell-buffer-maximum-lines 5000
      ;; eshell-save-history-on-exit t
      eshell-history-file-name "~/.emacs.d/eshell_history"
      eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t
      eshell-banner-message ""
      eshell-visual-commands'("bash" "htop" "ssh" "top" "gpg" "paru" "ngrok"))

(add-hook 'eshell-mode-hook
          (lambda ()
            (setq-local scroll-margin 0)))

(with-eval-after-load 'eshell
  ;; Set eshell-save-history-on-exit to nil
  (setq eshell-save-history-on-exit nil)

  ;; Define eshell-append-history function
  (defun eshell-append-history ()
    "Call `eshell-write-history' with the `append' parameter set to `t'."
    (when eshell-history-ring
      (let ((newest-cmd-ring (make-ring 1)))
        (ring-insert newest-cmd-ring (car (ring-elements eshell-history-ring)))
        (let ((eshell-history-ring newest-cmd-ring))
          (eshell-write-history eshell-history-file-name t)))))

  ;; Add eshell-append-history to eshell-pre-command-hook
  (add-hook 'eshell-pre-command-hook #'eshell-append-history))

(defun eshell-insert-last-argument ()
  "Insert the last argument of the previous command."
  (interactive)
  (let* ((last-command (eshell-previous-input-string 0))
         (args (split-string-and-unquote last-command))
         (last-arg (car (last args))))
    (when last-arg
      (insert last-arg))))

(defun setup-eshell-keys ()
  (define-key eshell-mode-map (kbd "M-.") 'eshell-insert-last-argument))
;; (define-key eshell-mode-map (kbd "M-r") 'counsel-esh-history))

(add-hook 'eshell-mode-hook 'setup-eshell-keys)

(with-eval-after-load 'evil
  (evil-define-key 'insert eshell-mode-map (kbd "M-r") 'counsel-esh-history)
  (evil-define-key 'normal eshell-mode-map (kbd "M-r") 'counsel-esh-history))

(defun eshell/edit (filename)
  "Open FILENAME in the current buffer, using the current TRAMP address."
  (interactive "sEnter the filename to edit: ")
  ;; Extract the current TRAMP address from the Eshell buffer's default directory
  (let ((tramp-address (file-remote-p default-directory)))
    (if tramp-address
        ;; If we're in a TRAMP directory, use the extracted address
        (find-file (concat tramp-address filename))
      ;; If not in a TRAMP directory, fall back to a default address or prompt the user
      (message "Not in a TRAMP directory. Please specify the TRAMP address manually.")
      ;; Optionally, you can add a fallback mechanism here, e.g., prompting the user for a TRAMP address
      )))

(defalias 'e 'eshell/edit)

(require 'em-tramp) ; to load eshell’s sudo
;; (setq eshell-prefer-lisp-functions t)
;; (setq eshell-prefer-lisp-variables t)
;; (setq password-cache t) ; enable password caching
;; (setq password-cache-expiry 10)
;; (add-hook 'eshell-load-hook (lambda () (add-to-list 'eshell-modules-list 'eshell-tramp)))

(defun eshell-clear-buffer ()
  "Clear the current Eshell buffer."
  (interactive)
  (let ((inhibit-read-only t))
    (erase-buffer)
    ;; Move to the beginning of the buffer
    (goto-char (point-min))
    ;; Reinsert the prompt at the correct position
    (eshell-reset)))

(with-eval-after-load 'eshell
  (with-eval-after-load 'evil
    (evil-define-key 'insert eshell-mode-map (kbd "C-l") 'eshell-clear-buffer)
    (evil-define-key 'normal eshell-mode-map (kbd "C-l") 'eshell-clear-buffer)))

(defun eshell-new ()
  "Create a new Eshell buffer with a unique name and open it in the current window."
  (interactive)
  (let ((eshell-buffer-name (generate-new-buffer-name "*another eshell buffer*")))
    (eshell)
    (switch-to-buffer eshell-buffer-name)))

(defun eshell-new-pop ()
  "Create a new Eshell buffer with a unique name, open it in the current window, and toggle popper type if popper-mode is active."
  (interactive)
  (let ((eshell-buffer-name (generate-new-buffer-name "*another eshell buffer*")))
    (eshell)
    (switch-to-buffer eshell-buffer-name)
    ;; Check if popper-mode is enabled and popper-toggle-type is available
    (when (and (featurep 'popper) (bound-and-true-p popper-mode))
      (popper-toggle-type eshell-buffer-name))))

(defun eshell-pop ()
  "Execute the eshell command and launch eshell as a popper buffer"
  (interactive)
  (eshell)
  (popper-toggle-type))

(defun eshell-expand-filename-at-point ()
  "Expand the filename at point to its absolute path in eshell."
  (interactive)
  (let* ((filename (thing-at-point 'filename t))
         (expanded (and filename (expand-file-name filename))))
    (if expanded
        (let ((bounds (bounds-of-thing-at-point 'filename)))
          (delete-region (car bounds) (cdr bounds))
          (insert expanded))
      (message "No valid filename at point!"))))

(connection-local-set-profile-variables
 'remote-trash-directory
 '((trash-directory . "/sudo::~/.local/share/Trash")))

(connection-local-set-profiles
 `(:application tramp :protocol "sudo" :machine ,system-name)
 'remote-trash-directory)

(with-eval-after-load 'eshell
  (evil-define-key 'normal eshell-mode-map
    "j" 'next-line
    "k" 'previous-line)
  (evil-define-key 'visual eshell-mode-map
    "j" 'next-line
    "k" 'previous-line))

(defun my-eshell-evil-setup ()
  (evil-define-key 'normal eshell-mode-map (kbd "0") 'beginning-of-line))

(add-hook 'eshell-mode-hook 'my-eshell-evil-setup)

(defun my/select-man-window (&rest _)
  "Select the window displaying the man page."
  (let ((man-window (cl-find-if (lambda (window)
                                  (string-match-p "^\\*Man " (buffer-name (window-buffer window))))
                                (window-list))))
    (when man-window
      (select-window man-window))))

(advice-add 'Man-getpage-in-background :after #'my/select-man-window)

#+end_src

*** Custom commands

#+begin_src emacs-lisp

  (defun FD ()
    "Display open files for the current Emacs process.
  If called from eshell, display in eshell. Otherwise, use a separate buffer."
    (interactive)
    (let* ((pid (number-to-string (emacs-pid)))
          (command (concat "ls -l /proc/" pid "/fd"))
          (output (shell-command-to-string command)))
      (if (eq major-mode 'eshell-mode)
          ;; In eshell, print directly to the eshell buffer
          (eshell-printn output)
        ;; Outside eshell, use the original behavior
        (with-output-to-temp-buffer "*FD Output*"
          (princ output))
        (switch-to-buffer-other-window "*FD Output*"))))

#+end_src

** Async shell

#+begin_src emacs-lisp

  ;; Execute async shell command on a current file
  (defun async-shell-command-on-file (command)
    "Execute COMMAND asynchronously on the current file."
    (interactive (list (read-shell-command
                        (concat "Async shell command on " (buffer-name) ": "))))
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (async-shell-command (concat command " " filename))))


  (defun async-shell-command-filter-hook ()
  "Filter async shell command output via `comint-output-filter'."
  (when (equal (buffer-name (current-buffer)) "*Async Shell Command*")
    ;; When `comint-output-filter' is non-nil, the carriage return characters ^M
    ;; are displayed
    (setq-local comint-inhibit-carriage-motion nil)
    (when-let ((proc (get-buffer-process (current-buffer))))
      (set-process-filter proc 'comint-output-filter))))

  (with-eval-after-load 'shell
    (add-hook 'shell-mode-hook 'async-shell-command-filter-hook))

#+end_src

** Cmd

#+begin_src emacs-lisp

  (defun my-hoogle-search (query)
    "Search Hoogle for QUERY."
    (interactive "sHoogle search: ") ; Prompt for the search term
    (shell-command (concat "hoogle search " (shell-quote-argument query))))

#+end_src

** Cursor changer

#+begin_src emacs-lisp

  (use-package evil-terminal-cursor-changer
    :config
    (unless (display-graphic-p)
      (require 'evil-terminal-cursor-changer)
      (evil-terminal-cursor-changer-activate) ; or (etcc-on)
      )
    )

#+end_src

* Database

#+begin_src emacs-lisp

      ;; Define the connection details for PostgreSQL, including two databases
      (setq sql-connection-alist
            '((postgres-wurfkreuz
              (sql-product 'postgres)
              (sql-user "wurfkreuz")
              (sql-server "localhost")
              (sql-port 5432)
              (sql-database "wurfkreuz"))
              (postgres-shelf
              (sql-product 'postgres)
              (sql-user "wurfkreuz") ; Assuming the same user for simplicity
              (sql-server "localhost")
              (sql-port 5432)
              (sql-database "shelf"))))

  (defun my-sql-connect-with-buffer (connection)
  "Connect to a SQL database using `sql-connect' and open a new SQL mode buffer."
  (interactive (list (completing-read "Select database: "
                                      (mapcar #'car sql-connection-alist)
                                      nil t)))
  (let ((sql-buffer (sql-connect connection)))
    (when (and (boundp 'sql-buffer) sql-buffer)
      (delete-other-windows)
      (switch-to-buffer (get-buffer-create "*SQL Buffer*"))
      (sql-mode)
      (split-window-below)
      (other-window 1)
      (switch-to-buffer sql-buffer)
      (balance-windows))))

  (defun show-table (table-name)
    "Describe the specified table by selecting a few rows."
    (interactive "sTable name: ")
    (let ((query (format "SELECT * FROM %s LIMIT 5;" table-name)))
      (with-current-buffer sql-buffer
        (goto-char (point-max))
        (insert query)
        (sql-send-paragraph))))

#+end_src

* Sessions

#+begin_src emacs-lisp

  ;; (setq desktop-restore-eager 10)

  (defvar current-desktop-session-name nil
    "The name of the currently loaded desktop session.")

  (defvar desktop-autosave-timer nil
    "Timer object for desktop autosave, to avoid multiple timers running.")

  (defun save-eshell-buffer (desktop-dirname)
    ;; Save the current working directory.
    default-directory)

  (defun restore-eshell-buffer (_file-name buffer-name misc)
    "MISC is the value returned by `save-eshell-buffer'.
                  _FILE-NAME is nil."
    (let ((default-directory misc))
      ;; Create an eshell buffer named BUFFER-NAME in directory MISC.
      (eshell buffer-name)))

  ;; Save all eshell-mode buffers.
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local desktop-save-buffer #'save-eshell-buffer)))

  ;; Restore all eshell-mode buffers.
  (add-to-list 'desktop-buffer-mode-handlers '(eshell-mode . restore-eshell-buffer))

  (defun save-current-desktop-session (&optional show-message)
    "Save the current desktop session using the current session name.
  If no session is loaded, prompt to create a new one. SHOW-MESSAGE controls whether a save message is displayed."
    (interactive "p") ; "p" passes a prefix argument, which is non-nil when called interactively
    (if (and current-desktop-session-name (not (string-empty-p current-desktop-session-name)))
        (let ((desktop-dir (concat user-emacs-directory "desktop/" current-desktop-session-name "/")))
          (unless (file-exists-p desktop-dir)
            (make-directory desktop-dir t))
          (desktop-save desktop-dir)
          (when (and show-message (or (called-interactively-p 'any) (eq show-message 1)))
            (message "Session '%s' saved." current-desktop-session-name)))
      ;; No session is loaded or the session name is empty, prompt to create a new one (only when called interactively)
      (when (called-interactively-p 'any)
        (let ((new-session-name (read-string "Enter new session name: ")))
          (if (string-empty-p new-session-name)
              (message "Session name cannot be empty.")
            (progn
              (setq current-desktop-session-name new-session-name)
              (let ((new-desktop-dir (concat user-emacs-directory "desktop/" new-session-name "/")))
                (make-directory new-desktop-dir t)
                (desktop-save new-desktop-dir)
                (message "Session '%s' created and saved." new-session-name))))))))

  (defun setup-desktop-autosave-timer ()
    "Set up or reset the desktop autosave timer."
    (when desktop-autosave-timer
      (cancel-timer desktop-autosave-timer))
    ;; Pass nil to save-current-desktop-session to avoid showing the message during autosaves.
    (setq desktop-autosave-timer (run-with-timer 30 30 (lambda () (save-current-desktop-session nil)))))

  (defun load-desktop-session (session-name)
    "Load a desktop session by name."
    (let ((desktop-dir (concat user-emacs-directory "desktop/")))
      (setq current-desktop-session-name session-name)
      (desktop-change-dir (concat desktop-dir session-name "/"))
      (setup-desktop-autosave-timer)))

  (defun load-desktop-with-name ()
    "Load a desktop session by name, chosen from available sessions."
    (interactive)
    (when current-desktop-session-name
      ;; Save the current session before loading a new one, but only if a session is already loaded.
      (save-current-desktop-session))
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
           (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
           (session-name (completing-read "Choose desktop session: " session-dirs nil t)))
      (setq current-desktop-session-name session-name)  ; Save the session name globally
      (desktop-change-dir (concat desktop-dir session-name "/"))
      (setup-desktop-autosave-timer)))

  ;; Disable the default desktop save mode
  (desktop-save-mode 0)

  (setq desktop-files-not-to-save
      (concat "\\(^/[^/:]*:\\|(ftp)$\\)\\|" desktop-files-not-to-save))

  (defun delete-desktop-session ()
    "Delete a desktop session by name, chosen from available sessions."
    (interactive)
    (let* ((desktop-dir (concat user-emacs-directory "desktop/"))
           (session-dirs (directory-files desktop-dir nil "^[^.]"))  ; List directories excluding hidden ones
           (session-name (completing-read "Choose desktop session to delete: " session-dirs nil t)))
      (when (yes-or-no-p (format "Are you sure you want to delete the '%s' session? " session-name))
        (let ((session-path (concat desktop-dir session-name)))
          (if (file-directory-p session-path)
              (progn
                (delete-directory session-path t)  ; 't' for recursive delete
                (message "Deleted desktop session '%s'." session-name))
            (message "No such desktop session '%s'." session-name))))))

  (defun rename-desktop-session ()
    "Renames the currently loaded desktop session."
    (interactive)
    ;; Check if there's a session loaded.
    (if (not current-desktop-session-name)
        (message "No desktop session is currently loaded.")
      (let* ((new-name (read-string "New session name: "))
             (old-dir (concat user-emacs-directory "desktop/" current-desktop-session-name))
             (new-dir (concat user-emacs-directory "desktop/" new-name)))
        ;; Check if the new session name is empty or the session already exists.
        (if (or (string-empty-p new-name)
                (file-exists-p new-dir))
            (message "Invalid new session name or session already exists.")
          ;; Rename the directory and update the session name.
          (rename-file old-dir new-dir)
          (setq current-desktop-session-name new-name)
          (message "Session renamed to '%s'." new-name)))))

  (add-hook 'kill-emacs-hook 'clean-buffer-list)
  (add-hook 'kill-emacs-hook 'save-current-desktop-session)

  #+end_src

* Buffers

** Shell buffer

#+begin_src emacs-lisp

(defun my-shell-mode-hook ()
  (setq-local scroll-margin 0))

(add-hook 'shell-mode-hook 'my-shell-mode-hook)

(setq explicit-shell-file-name "/usr/bin/zsh")  ; your shell path here
(setq explicit-bash-args '("--login" "-i"))

(defun my-shell-mode-hook ()
  "Custom shell-mode hook to remove the first line of output."
  (let ((inhibit-read-only t))
    (save-excursion
      (goto-char (point-min))
      (delete-line))))

(add-hook 'shell-mode-hook
          (lambda ()
            (run-with-timer 0.1 nil 'my-shell-mode-hook)))

#+end_src

** Eshell buffer

#+begin_src emacs-lisp

  (defvar
    eshell-toggle-window-configuration nil
    "Variable to store the window configuration before opening eshell.")

  (defvar eshell-toggle-selected-window nil
    "Variable to store the selected window before opening eshell.")

  (defun SpawnEshellSplitBelow ()
    "Open a shell in a small split below or toggle it if already open."
    (interactive)
    (if (eq major-mode 'eshell-mode)
        (progn
          (when eshell-toggle-window-configuration
            (set-window-configuration eshell-toggle-window-configuration)
            (setq eshell-toggle-window-configuration nil))
          (when eshell-toggle-selected-window
            (select-window eshell-toggle-selected-window)
            (setq eshell-toggle-selected-window nil)))
      (setq eshell-toggle-window-configuration (current-window-configuration))
      (setq eshell-toggle-selected-window (selected-window))
      ;; Calculate one third of the total window height
      (let ((one-third-height (/ (window-total-height) 3)))
        ;; Ensure the height is at least 1 to avoid errors
        (setq one-third-height (max one-third-height 1))
        (split-window-below (- one-third-height))
        (other-window 1)
        (open-eshell-in-current-directory))))

  (defun open-eshell-in-current-directory ()
    "Open eshell in the directory of the current buffer.
      If an eshell buffer for the directory already exists, switch to it."
    (interactive)
    (let* ((buffer-dir (if (buffer-file-name)
                           (file-name-directory (buffer-file-name))
                         default-directory))
           (eshell-buffer-name (concat "*eshell:" buffer-dir "*"))
           (existing-eshell-buffer (get-buffer eshell-buffer-name)))
      (if existing-eshell-buffer
          (switch-to-buffer existing-eshell-buffer)
        (let ((eshell-buffer (eshell 'N)))
          (with-current-buffer eshell-buffer
            (rename-buffer eshell-buffer-name)
            (eshell/cd buffer-dir))))))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "M-e") 'SpawnEshellSplitBelow))
  ;; (define-key evil-normal-state-map (kbd "M-e") 'open-eshell-in-current-directory))

  (defun SpawnEshellInProjectRoot ()
    "Open eshell in the project's root directory or toggle it if already open."
    (interactive)
    (if (eq major-mode 'eshell-mode)
        (progn
          (when eshell-toggle-window-configuration
            (set-window-configuration eshell-toggle-window-configuration)
            (setq eshell-toggle-window-configuration nil))
          (when eshell-toggle-selected-window
            (select-window eshell-toggle-selected-window)
            (setq eshell-toggle-selected-window nil)))
      (setq eshell-toggle-window-configuration (current-window-configuration))
      (setq eshell-toggle-selected-window (selected-window))
      ;; Calculate one third of the total window height
      (let ((one-third-height (/ (window-total-height) 3)))
        ;; Ensure the height is at least 1 to avoid errors
        (setq one-third-height (max one-third-height 1))
        (split-window-below (- one-third-height))
        (other-window 1)
        (let ((project-root (projectile-project-root)))
          (open-eshell-in-directory project-root)))))

  (defun open-eshell-in-directory (dir)
    "Open eshell in the specified directory DIR.
  If an eshell buffer for the directory already exists, switch to it."
    (interactive "DDirectory: ")
    (let* ((eshell-buffer-name (concat "*eshell:" dir "*"))
           (existing-eshell-buffer (get-buffer eshell-buffer-name)))
      (if existing-eshell-buffer
          (switch-to-buffer existing-eshell-buffer)
        (let ((eshell-buffer (eshell 'N)))
          (with-current-buffer eshell-buffer
            (rename-buffer eshell-buffer-name)
            (eshell/cd dir))))))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "M-p") 'SpawnEshellInProjectRoot))

  (defun kill-all-eshell-buffers ()
    "Kill all Eshell buffers."
    (interactive)
    (dolist (buffer (buffer-list))
      (when (string-match-p "^\\*eshell\\*" (buffer-name buffer))
        (kill-buffer buffer))))

#+end_src

** Transpose frame

#+begin_src emacs-lisp

  (use-package transpose-frame)

#+end_src

** Popper

#+begin_src emacs-lisp

(defun my/show-popper-echo-line ()
  "Briefly toggle popper to show the echo line."
  (interactive)
  ;; Ensure popper-mode and popper-echo-mode are active
  (when (and popper-mode popper-echo-mode)
    ;; Toggle a popper window and immediately toggle it back
    (popper-toggle-latest)
    (popper-toggle-latest)))

(use-package popper
  :bind (("M-`" . my/show-popper-echo-line))
         ;; ("M-f"   . popper-toggle))
         ;; ("M-~"   . popper-cycle))
  :init
  (setq popper-window-height 0.33)
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          "*Flymake diagnostics.*"
          "*Flycheck errors.*"
          "\\* docker container logs .*\\*"
          "\\* docker inspect .*\\*"
          "\\*daemons-output for .*\\*"
          "\\*compilation\\*"
          ;; "\\*eshell\\*.*"
          "\\*persistent-shell\\*.*"
          "\\*cider-repl.*"
          "\\*cider-doc.*"
          "\\*cider-error.*"
          "\\*helpful.*"
          ;; "\\*man.*"
          "\\*grep.*"
          ;; "\\*eshell:.*"
          "\\*Warnings\\*"
          ;; "\\*xref\\*"
          ;; "\\*Backtrace\\*"
          "\\*eldoc\\*"
          ;; "\\*Ement Notifications\\*"
          ;; "Output\\*$"
          ;; "\\*Dtache Shell Command\\*"
          ;; "\\*mu4e-update\\*"
          help-mode
          compilation-mode))
  (popper-mode +1)
  (popper-echo-mode +1))

(use-package shackle
  :ensure t
  :config
  (shackle-mode 1))

(defun my-buffer-is-popper-popup-p ()
  "Check if the current buffer is considered a Popper popup."
  (and (boundp 'popper-popup-status)
      (buffer-local-value 'popper-popup-status (current-buffer))))

(defun my-check-current-buffer-popper-status ()
  "Print whether the current buffer is a Popper popup."
  (interactive)
  (if (my-buffer-is-popper-popup-p)
      (message "Current buffer IS a Popper popup.")
    (message "Current buffer is NOT a Popper popup.")))

;; (define-advice popper-raise-popup (:override (&optional buffer) switch-and-stay)
;;   (when-let ((buf (get-buffer (or buffer (current-buffer)))))
;;     (with-current-buffer buf
;;       (if (popper-popup-p buf)
;;           (setq popper-popup-status 'raised)
;;         (setq popper-popup-status nil))
;;       (setq mode-line-format (default-value 'mode-line-format)))))

(defadvice popper-raise-popup (around switch-and-stay (&optional buffer) activate)
  "Advice to modify popper-raise-popup behavior."
  (when-let ((buf (get-buffer (or buffer (current-buffer)))))
    (with-current-buffer buf
      (if (popper-popup-p buf)
          (setq popper-popup-status 'raised)
        (setq popper-popup-status nil))
      (setq mode-line-format (default-value 'mode-line-format)))))

(defun popper-toggle-type-original ()
  "Run popper-toggle-type with the original behavior by temporarily disabling the advice."
  (interactive)
  (ad-disable-advice 'popper-raise-popup 'around 'switch-and-stay)
  (ad-activate 'popper-raise-popup)
  (unwind-protect
      (call-interactively 'popper-toggle-type)
    (ad-enable-advice 'popper-raise-popup 'around 'switch-and-stay)
    (ad-activate 'popper-raise-popup)))

;; (global-set-key (kbd "M-f") 'm-f-toggle-or-forward-word)
(global-set-key (kbd "M-f") 'popper-toggle)

(defun popper-flymake-diagnostics ()
  "Popper window specifically for Flymake diagnostics buffer."
  (interactive)
  (if (string-match-p "\\*.*Flymake diagnostics.*\\*" (buffer-name))
      (popper-toggle)
    (flymake-show-buffer-diagnostics)))

(defun popper-flycheck-diagnostics ()
  "Popper window specifically for Flycheck errors buffer."
  (interactive)
  (if (string-match-p "\\*Flycheck errors\\*" (buffer-name))
      (popper-toggle)
    (flycheck-list-errors)))

;; (defun fix-cycle ()
;;   (interactive)
;;   (popper-cycle 1))

;; (defun fix-cycle-backwards ()
;;   (interactive)
;;   (popper-cycle-backwards -1))

(with-eval-after-load 'evil
  ;;   (define-key evil-normal-state-map (kbd "M-k") 'fix-cycle-backwards)
  ;;   (define-key evil-normal-state-map (kbd "M-j") 'fix-cycle)
  ;; (define-key evil-normal-state-map (kbd "M-t M-m") 'popper-flymake-diagnostics)
  ;; (define-key evil-normal-state-map (kbd "M-t M-c") 'popper-flycheck-diagnostics))
  (define-key evil-normal-state-map (kbd "M-y") 'popper-flymake-diagnostics)
  (define-key evil-normal-state-map (kbd "M-t M-c") 'popper-flycheck-diagnostics))

#+end_src

* Language Support

** Python

#+begin_src emacs-lisp

  (use-package pyvenv
    :config
    (pyvenv-mode 1))  

#+end_src

** Flymake

#+begin_src emacs-lisp

  ;; (use-package flymake
  ;;   :ensure t
  ;;   :config
  ;;   ;; Define a function to enable flymake-mode in dockerfile-mode
  ;;   (defun enable-flymake-mode ()
  ;;     "Enable flymake-mode in dockerfile-mode."
  ;;     (if (string-equal major-mode "dockerfile-mode")
  ;;         (flymake-mode 1)))

  (defun enable-flymake-mode ()
    "Enable flymake-mode in dockerfile-mode."
    (if (string-equal major-mode "dockerfile-mode")
        (flymake-mode 1)))

  ;;   ;; Add the hook to enable flymake-mode when entering dockerfile-mode
  (add-hook 'dockerfile-mode-hook 'enable-flymake-mode)

  (use-package flymake-hadolint)
  (add-hook 'dockerfile-mode-hook #'flymake-hadolint-setup)

  (use-package flymake-shellcheck
    :commands flymake-shellcheck-load
    :init
    (add-hook 'sh-mode-hook 'flymake-shellcheck-load))

#+end_src

** Modes

#+begin_src emacs-lisp

  (use-package raku-mode)
  (use-package go-mode)
  (use-package lua-mode)
  (use-package terraform-mode)
  (use-package dockerfile-mode)
  (use-package haskell-mode)

  (when (require 'dockerfile-mode nil 'noerror)
    ;; Add a hook to automatically use dockerfile-mode for Dockerfiles
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-mode)))

  (use-package ansible
    :config
    (add-hook 'yaml-ts-mode-hook '(lambda () (ansible 1))))

  (require 'compile)
  (add-to-list 'compilation-error-regexp-alist
               'yaml)
  (add-to-list 'compilation-error-regexp-alist-alist
               '(yaml "^\\(.*?\\):\\([0-9]+\\)" 1 2)
               )

                                          ; Replace make -k with ansible-lint, with an UTF-8 locale to avoid crashes
  (defun ansible-lint-errors ()
    (make-local-variable 'compile-command)
    (let ((ansiblelint_command "ansible-lint ") (loc "LANG=C.UTF-8 "))
      (setq compile-command (concat loc ansiblelint_command buffer-file-name)))
    )
  (add-hook 'yaml-ts-mode-hook 'ansible-lint-errors)

  ;; (use-package markdown-mode
  ;;   :ensure t
  ;;   :mode ("README\\.md\\'" . gfm-mode)
  ;;   :init (setq markdown-command "multimarkdown")
  ;;   :bind (:map markdown-mode-map
  ;;         ("C-c C-e" . markdown-do)))

  (add-to-list 'auto-mode-alist '("\\.hs\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.hls\\'" . haskell-mode))
  (add-to-list 'auto-mode-alist '("\\.cabal\\'" . haskell-cabal-mode))

#+end_src

** Flycheck

#+begin_src emacs-lisp

  (defun my/set-flycheck-faces ()
    (with-eval-after-load 'flycheck
      ;; Customize Flycheck error face
      (set-face-attribute 'flycheck-error nil
                          :underline `(:style line :color "#e0def4")) ; rose-pine-gold
      ;; Customize Flycheck warning face
      (set-face-attribute 'flycheck-warning nil
                          :underline `(:style line :color "#f6c177")) ; rose-pine-gold
      ;; Customize Flycheck info (note) face
      (set-face-attribute 'flycheck-info nil
                          :underline `(:style line :color "#c4a7e7")))) ; rose-pine-iris

  (add-hook 'after-init-hook 'my/set-flycheck-faces)

  ;; (use-package flycheck
  ;;   :init
  ;;   (add-hook 'after-init-hook #'global-flycheck-mode)
  ;;   :config
  ;;   (my/set-flycheck-faces))

  ;; (defun my/disable-flycheck-in-emacs-lisp-mode ()
  ;;   "Disable flycheck in emacs-lisp-mode."
  ;;   (setq-local flycheck-disabled-checkers '(emacs-lisp emacs-lisp-checkdoc)))

  ;; (add-hook 'emacs-lisp-mode-hook #'my/disable-flycheck-in-emacs-lisp-mode)

  ;; (defun my/disable-flycheck-for-specific-languages ()
  ;;   "Disable specific Flycheck checkers based on the major mode."
  ;;   (cond
  ;;   ((derived-mode-p 'emacs-lisp-mode)
  ;;     (setq-local flycheck-disabled-checkers '(emacs-lisp emacs-lisp-checkdoc)))
  ;;   ((derived-mode-p 'python-mode)
  ;;     (setq-local flycheck-disabled-checkers '(python-pylint python-pycompile)))
  ;;   ((derived-mode-p 'go-mode)
  ;;     (setq-local flycheck-disabled-checkers '(go-gofmt go-golint go-vet go-build go-test go-errcheck)))))

  ;; (use-package flycheck-clj-kondo)

  ;; (with-eval-after-load 'flycheck
  ;;   (flycheck-add-mode 'clj-kondo-clj 'clojure-ts-mode)
  ;;   (flycheck-add-mode 'clj-kondo-cljs 'clojure-ts-mode)
  ;;   (flycheck-add-mode 'clj-kondo-cljc 'clojure-ts-mode)
  ;;   (flycheck-add-mode 'clj-kondo-edn 'clojure-ts-mode))

  ;; (use-package flycheck-raku)

  ;; (use-package flymake-flycheck
  ;;   :after flymake
  ;;   ;; :init
  ;;   ;; (setopt flycheck-disabled-checkers '(python-mypy flymake-flycheck:python-mypy))
  ;;   :config
  ;;   (add-hook 'flymake-mode-hook 'flymake-flycheck-auto))

#+end_src

** Lsp Mode

#+begin_src emacs-lisp

  (use-package lsp-mode
    :commands lsp
    :hook ((go-ts-mode . lsp)
           (clojure-ts-mode . lsp)
           (haskell-mode . lsp)
           (python-ts-mode . lsp))
    ;; (raku-mode . lsp))
    :init
    (setq lsp-session-file "~/.emacs.d/.lsp-session-v1")
    (setq lsp-lens-enable nil)
    :config
    ;; Register Go LSP client
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- gopls")
                      :major-modes '(go-ts-mode) ; Corrected to go-mode
                      :server-id 'gopls)) ; Correct server-id for Go

    ;; Register Haskell LSP client
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- hls")
                      :major-modes '(haskell-mode)
                      :server-id 'hls))

    ;; Register Python LSP client
    ;; (setq lsp-pylsp-plugins-flake8-enabled t)
    ;; (lsp-register-client
    ;;  (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- pylsp")
    ;;                   :major-modes '(python-ts-mode)
    ;;                   :server-id 'pylsp))

    ;; Register Clojure LSP client
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-stdio-connection "emacs-lsp-booster -- clojure-lsp")
                      :major-modes '(clojure-ts-mode) ; Corrected to clojure-mode
                      :server-id 'clojure-lsp)) ; Correct and unique server-id for Clojure

    ;; ;; Register Raku Navigator LSP client
    ;; (lsp-register-client
    ;;  (make-lsp-client :new-connection (lsp-stdio-connection
    ;;                                    (list "node" "/home/wurfkreuz/.source/RakuNavigator/server/out/server.js" "--stdio"))
    ;;                   :major-modes '(raku-mode) ; Ensure this is the correct major mode for Raku
    ;;                   :server-id 'raku-navigator)) ; Unique server-id for Raku Navigator

    ;; General LSP settings
    (lsp-signature-mode nil)
    (setq lsp-idle-delay 0.1
          lsp-diagnostics-provider :flymake
          lsp-headerline-breadcrumb-enable nil
          gc-cons-threshold (* 100 1024 1024)
          read-process-output-max (* 1024 1024)
          lsp-log-max 0
          lsp-log-io nil
          lsp-enable-symbol-highlighting nil
          lsp-signature-render-documentation nil
          lsp--last-signature nil
          lsp--last-signature-index nil
          lsp--last-signature-buffer nil
          lsp-signature-auto-activate nil
          lsp-signature-cycle nil
          lsp-signature-doc-lines nil
          lsp-signature-face nil
          lsp-signature-function nil
          lsp-signature-posframe nil
          lsp-eldoc-enable-hover nil
          lsp-eldoc-render-all nil
          lsp-signature-render-documentation nil))

  (setq lsp-pyright-multi-root nil)

  (use-package lsp-pyright
    :ensure t
    :hook (python-ts-mode . (lambda ()
                              (require 'lsp-pyright)
                              (lsp-deferred)))  ; Use lsp-deferred to start the server after the buffer is loaded
    :init
    ;; Modify the command to start the server
    (setq lsp-pyright-server-command '("emacs-lsp-booster -- pyright")))

  (defun set-lsp-pyright-venv-path ()
    "Interactively set the `lsp-pyright-venv-path` to a selected directory."
    (interactive)
    (let ((selected-dir (read-directory-name "Select Python virtual environment directory: ")))
      (if (file-directory-p selected-dir)
          (progn
            (setq lsp-pyright-venv-path selected-dir)
            (message "Set `lsp-pyright-venv-path` to %s" lsp-pyright-venv-path))
            ;; (message "Set `lsp-pyright-venv-path` to %s" lsp-pyright-venv-directory))
        (message "Invalid directory or operation cancelled."))))

  (defun my/disable-python-flymake ()
    "Disable default Python Flymake checker."
    (setq-local flymake-diagnostic-functions
                (remove 'python-flymake flymake-diagnostic-functions)))

  (add-hook 'python-ts-mode-hook #'my/disable-python-flymake) ;

  (use-package lsp-ui
    :after lsp-mode
    :init
    (setq lsp-ui-doc-allow-mouse t)
    :hook (lsp-mode . lsp-ui-mode))

  ;; (define-key evil-normal-state-map (kbd "K") 'lsp-describe-thing-at-point)
  (defun my/lsp-describe-thing-at-point ()
    "Call `lsp-describe-thing-at-point` and switch to the documentation window."
    (interactive)
    (let ((orig-window (selected-window)))
      (lsp-describe-thing-at-point)
      (select-window (get-buffer-window "*lsp-help*"))))

  ;; Bind the custom function to 'K' in Evil's normal mode
  (define-key evil-normal-state-map (kbd "K") 'my/lsp-describe-thing-at-point)

  ;; (use-package lsp-haskell
  ;;   :ensure t
  ;;   :init
  ;;   (setq lsp-haskell-server-path "haskell-language-server-wrapper")
  ;;   :after lsp
  ;;   :config
  ;;   ;; (setq lsp-haskell-check-parents 'AlwaysCheck)
  ;;   )

  (defun remove-from-lsp-file-watch-ignored ()
    "Interactively remove a pattern from `lsp-file-watch-ignored`."
    (interactive)
    (let ((pattern (completing-read "Remove pattern: " lsp-file-watch-ignored)))
      (setq lsp-file-watch-ignored (remove pattern lsp-file-watch-ignored))
      (message "Removed pattern: %s" pattern)))

  (defun add-lsp-workspace-folder ()
    "Add the current directory to LSP workspace folders."
    (interactive)
    (lsp-workspace-folders-add (expand-file-name default-directory)))

#+end_src

* Org Mode

** General

#+begin_src emacs-lisp

(use-package org
  :config
  (setq org-edit-src-content-indentation 0))
  ;;   (setq org-src-preserve-indentation t)
  ;;   (setq org-src-tab-acts-natively t)
  ;;   ;; Other org-mode configurations...
  ;;   )

    ;; (org-link-minor-mode 1)

  (defun org-insert-top-level-heading ()
      "Insert a new top-level heading with two empty lines before it."
      (interactive)
      (end-of-line)
      (insert "\n\n\n* ")
      (end-of-line))

    (define-key org-mode-map (kbd "M-o M-h") 'org-insert-top-level-heading)

  (defun create-list-in-region ()
  "Convert the highlighted text into a single org-mode list item, properly formatting multiline text."
  (interactive)
  (if (use-region-p)
      (let* ((beg (region-beginning))
             (end (region-end))
             ;; Adjust `end` to exclude the newline at the end of the selection if present.
             (end (if (and (> end beg)
                           (save-excursion
                             (goto-char end)
                             (beginning-of-line)
                             (<= (point) end)))
                      (progn
                        (goto-char end)
                        (backward-char)
                        (point))
                    end))
             (region-text (buffer-substring beg end))
             (lines (split-string region-text "\n")))
        (delete-region beg end)
        (when lines
          (insert (concat "- " (car lines)))
          (dolist (line (cdr lines))
            (insert (concat "\n  " line)))))
    (message "No region active")))

#+end_src

** Org capture

#+begin_src emacs-lisp

  ;; Set the path to your Org notes file
  (setq org-default-notes-file "/home/wurfkreuz/.secret_dotfiles/org/notes/quick_notes.org")

  (setq org-capture-templates
        '(("n" "Note" plain (file org-default-notes-file)
          "%?\nEntered on %U\n" :append t :empty-lines-before 1)))

#+end_src

** Org download

#+begin_src emacs-lisp

;;  (use-package org-download
;;    :init
;;    (setq org-download-image-dir "~/.secret_dotfiles/org/images")
;;    :config
;;    (add-hook 'org-mode-hook 'org-download-enable)
;;    (add-hook 'org-mode-hook
;;              (lambda ()
;;                (org-display-inline-images))))

#+end_src

** Drill

#+begin_src emacs-lisp

(use-package org-drill
  :config
  (setq org-drill-maximum-items-per-session 100))

#+end_src

** Agenda

#+begin_src emacs-lisp

  (setq org-agenda-files
        '("~/.secret_dotfiles/org/todo_list.org"))

#+end_src

** Org-roam

#+begin_src emacs-lisp
#+end_src

** Templates

#+begin_src emacs-lisp

  (require 'org-tempo)
  (add-to-list 'org-structure-template-alist '("sb" . "src bash-ts"))
  (add-to-list 'org-structure-template-alist '("se" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sr" . "src raku"))
  (add-to-list 'org-structure-template-alist '("sf" . "src fundamental"))
  (add-to-list 'org-structure-template-alist '("st" . "src text"))
  (add-to-list 'org-structure-template-alist '("ss" . "src sql"))
  (add-to-list 'org-structure-template-alist '("sg" . "src go-ts"))
  (add-to-list 'org-structure-template-alist '("sc" . "src clojure-ts"))

  (add-to-list 'org-structure-template-alist
             '("t" . "src TODO\n\n* TODO \n\n?"))

#+end_src

** Visuals

#+begin_src emacs-lisp

  (setq org-hide-emphasis-markers t)

  (defun toggle-org-emphasis-markers ()
    "Toggle the visibility of Org emphasis markers."
    (interactive)
    (setq org-hide-emphasis-markers (not org-hide-emphasis-markers))
    (org-mode-restart))

  (define-key org-mode-map (kbd "M-o t m") 'toggle-org-emphasis-markers)
  (define-key org-mode-map (kbd "M-o t l") 'org-toggle-link-display)

  (add-hook 'org-mode-hook 'prettify-symbols-mode)
    (defun my-org-prettify-symbols ()
    (push '("#+begin_src" . ">") prettify-symbols-alist)
      (push '("#+end_src" . ">") prettify-symbols-alist))

  (eval-after-load 'org
    '(add-hook 'org-mode-hook 'my-org-prettify-symbols))

#+end_src

*** Bullets

#+begin_src emacs-lisp

  (add-hook 'org-mode-hook 'org-indent-mode)
  (use-package org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))

#+end_src

** Source block tag expansion cheat sheet

   | Name | Description |
   |------+-------------|
   | se   | lisp        |
   |------+-------------|
   |      |             |


** Enabling Table of Contents

#+begin_src emacs-lisp

  (use-package toc-org
      :commands toc-org-enable
      :init (add-hook 'org-mode-hook 'toc-org-enable))

#+end_src

** Custom key bindings

#+begin_src emacs-lisp

  (defun org-insert-row-with-floor ()
    "Insert a new row with a 'floor' above in an Org mode table."
    (interactive)
    (org-table-next-field)
    (beginning-of-line)
    (insert "|-")
    (org-table-align)
    (org-return))

  (define-key org-mode-map (kbd "C-c f") 'org-insert-row-with-floor)

  (defun FormatToThreshold (char-threshold)
    "Formats the selected text to not exceed CHAR-THRESHOLD characters per line."
    (interactive "nCharacter Threshold: ")
    (let ((start (region-beginning))
          (end (region-end))
          all-text words formatted-text)
      (save-excursion
        (setq all-text (buffer-substring start end))
        (setq words (split-string all-text))
        (let ((current-line "")
              (current-length 0))
          (dolist (word words)
            (if (> (+ current-length (length word) 1) char-threshold)
                (progn
                  (setq formatted-text (concat formatted-text current-line "\n"))
                  (setq current-line word)
                  (setq current-length (length word)))
              (progn
                (setq current-line (if (string= "" current-line)
                                      word
                                    (concat current-line " " word)))
                (setq current-length (+ current-length (length word) 1)))))
          (setq formatted-text (concat formatted-text current-line)))
        (delete-region start end)
        (goto-char start)
        (insert formatted-text))))

  (defun my/evil-org-open-below (count)
    "Open a new line below the current one and insert a new Org list item if on a list item, otherwise just open a new line."
    (interactive "p")
    (if (org-in-item-p)
        (progn
          (end-of-line)
          (org-insert-item))
      (evil-open-below count)))

  (with-eval-after-load 'evil
    (evil-define-key 'normal org-mode-map
      "o" 'my/evil-org-open-below))

#+end_src

* Keybindings

#+begin_src emacs-lisp

  ;; (global-unset-key (kbd "M-;"))

  (defun my-noop ()
  "A no-op function that does nothing."
  (interactive))

  (global-set-key (kbd "M-;") 'my-noop)

  (global-unset-key (kbd "C-s"))
  (global-unset-key (kbd "M-TAB"))
  (global-set-key (kbd "C-s C-l") 'load-desktop-with-name)
  (global-set-key (kbd "C-s C-s") 'swiper-isearch)
  (global-set-key (kbd "C-s C-q") 'my-sql-connect-with-buffer)
  (global-set-key (kbd "C-s C-b") 'sql-send-buffer)
  ;; (global-set-key (kbd "C-S C-k") 'kill-whole-line)
  (define-key minibuffer-local-map (kbd "C-S C-k") 'backward-kill-sentence)  ; Example function
  ;; (define-key minibuffer-local-map (kbd "C-S C-k") 'kill-whole-line)
  (global-set-key (kbd "C-h M-f") 'describe-face)

  (global-unset-key (kbd "C-t"))
  (global-unset-key (kbd "C-y"))

  (with-eval-after-load 'evil
    (define-key evil-normal-state-map (kbd "C-t") nil)
    (evil-define-key 'normal 'global (kbd "M-^") 'projectile-run-async-shell-command-in-root)
    (define-key evil-normal-state-map (kbd "gz") 'zoxide-travel)
    (define-key evil-insert-state-map (kbd "C-f C-n") 'eshell-expand-filename-at-point)
    (define-key evil-insert-state-map (kbd "C-f i h") 'insert-path-from-ivy-fzf-home)
    (define-key evil-insert-state-map (kbd "C-f i c") 'insert-path-from-ivy-fzf-project)
    (define-key evil-insert-state-map (kbd "C-f i r") 'insert-path-from-ivy-fzf-root))

  (defun my-org-cycle-or-yasnippet-expand ()
    "Expand Yasnippet or perform org-cycle based on the context."
    (interactive)
    ;; First, try to expand a Yasnippet if possible.
    (unless (and (bound-and-true-p yas-minor-mode) ; Check if YASnippet mode is active
                (fboundp 'yas-expand)            ; Check if yas-expand is callable
                (yas-expand))                     ; Try to expand a snippet
      ;; If no snippet was expanded and we're in an Org buffer, call org-cycle.
      (when (eq major-mode 'org-mode)
        (org-cycle))))

  (with-eval-after-load 'evil
    (evil-define-key 'insert global-map (kbd "C-a") 'my-org-cycle-or-yasnippet-expand))

  (with-eval-after-load 'org
    ;; Override the keybinding in org-mode specifically
    (define-key org-mode-map (kbd "M-^") 'projectile-run-async-shell-command-in-root)
    (define-key evil-normal-state-map (kbd "C-t C-s") 'flyspell-mode))

  (global-unset-key (kbd "C-<tab>"))
  (global-set-key (kbd "<C-tab>") 'previous-buffer)

#+end_src

* Custom functions

#+begin_src emacs-lisp

(defun copy-buffer-to-new-buffer ()
  "Create a copy of the current buffer, placing the contents in a new named buffer."
  (interactive)
  (let ((content (buffer-string))  ; Get the content of the current buffer
        (name (generate-new-buffer-name "BufferCopy")))  ; Generate a new buffer name
    (switch-to-buffer name)  ; Create and switch to the new buffer
    (insert content)  ; Insert the original content into the new buffer
    (set-buffer-major-mode (other-buffer))  ; Set the major mode based on the original buffer
    (message "Buffer copied to %s" name)))

(defun print-commands-starting-with (input)
  "Print all Emacs commands starting with INPUT to a scratch buffer."
  (interactive "sInput: ")
  (let ((command-list (apropos-internal input 'commandp))
        (output-buffer (get-buffer-create "*Commands*")))
    (with-current-buffer output-buffer
      (erase-buffer)
      (insert (format "Commands starting with '%s':\n\n" input))
      (dolist (command command-list)
        (insert (format "%s\n" command)))
      (goto-char (point-min)))
    (display-buffer output-buffer)))

;; Increment
(defun my/increment-number-at-point (&optional increment)
  "Increment number at point like vim's C-a"
  (interactive "p")
  (my/change-number-at-point '+ (or increment 2)))

;; Decrement
(defun my/decrement-number-at-point (&optional increment)
  "Decrement number at point like vim's C-x"
  (interactive "p")
  (my/change-number-at-point '- (or increment 1)))

(defun Cp ()
  "Copy the full path of the current buffer's file to the clipboard (or appropriate path)."
  (interactive)
  (let ((path-to-copy nil))
    (cond
     ((eq major-mode 'dired-mode)    ; Dired buffer
      (setq path-to-copy (if (dired-get-file-for-visit)
                             (expand-file-name (dired-get-file-for-visit))
                           (expand-file-name default-directory))))
     ((eq major-mode 'eshell-mode)   ; Eshell buffer
      (setq path-to-copy (eshell/pwd)))
     (t                              ; Default: Regular File buffer
      (setq path-to-copy (buffer-file-name))))
    (if path-to-copy
        (progn
          (kill-new path-to-copy)
          (message "Copied path '%s' to the clipboard." path-to-copy))
      (message "Current buffer has no associated path to copy."))))

(defun sway ()
  "Open sway config file."
  (interactive)
  (find-file (expand-file-name "~/.dotfiles/sway/config")))

(defun date ()
  "Display the current date and time in the minibuffer using the shell's 'date' command."
  (interactive)
  (let ((date-output (shell-command-to-string "date")))
    (message (string-trim date-output))))

(defun off ()
  "Shutdown the system."
  (interactive)
  (call-process "poweroff"))

(defun reboot ()
  "Reboot the system."
  (interactive)
  (call-process "reboot"))

(defun notes ()
  "Open org notes directory."
  (interactive)
  (find-file (expand-file-name "~/.secret_dotfiles/org")))

(defun drill ()
  "Open org notes directory."
  (interactive)
  (find-file (expand-file-name "~/.secret_dotfiles/org/drill")))

(defun cards ()
  "Open org notes directory."
  (interactive)
  (find-file (expand-file-name "~/.secret_dotfiles/org/drill/general.org")))

(defun nvm ()
  "Open org notes directory."
  (interactive)
  (find-file (expand-file-name "~/.dotfiles/nvim/lua/user/")))

(defun emc ()
  "Open a specific file."
  (interactive)
  (find-file "~/.emacs.d/config.org"))

(defun alc ()
  "Open a specific file."
  (interactive)
  (find-file "~/.dotfiles/zellij/config.kdl"))

(defun zsh ()
  "Open a specific file."
  (interactive)
  (find-file "~/.dotfiles/zsh/.zshrc"))

(defun bsh ()
  "Open a specific file."
  (interactive)
  (find-file "~/.dotfiles/bash/.bashrc"))

(defun scr ()
  "Open a specific file."
  (interactive)
  (find-file "~/.secret_dotfiles"))

(defun szsh ()
  "Open a specific file."
  (interactive)
  (find-file "~/.secret_dotfiles/zsh/.zshrc"))

(defun scripts ()
  "Open a specific file."
  (interactive)
  (find-file "~/.dotfiles/scripts/"))

(defun so ()
  "Reload the Emacs configuration."
  (interactive)
  (load-file "~/.emacs.d/init.el")
  (load-file "~/.emacs.d/init.el"))

(with-eval-after-load 'evil
  (evil-ex-define-cmd "so" 'so))

(defun z (q)
  "Query zoxide and launch dired or change directory in Eshell."
  (interactive "sZoxide: ")
  (if-let
      ((zoxide (executable-find "zoxide"))
       (target
        (with-temp-buffer
          (if (= 0 (call-process zoxide nil t nil "query" q))
              (string-trim (buffer-string))))))
      (if (derived-mode-p 'eshell-mode)
          (eshell/cd target)
        (funcall-interactively #'dired target))
    (unless zoxide (error "Install zoxide"))
    (unless target (error "No Match"))))

(defun push ()
  "Execute git add, commit, and push in sequence asynchronously."
  (interactive)
  ;; Execute 'push' asynchronously and display output in a separate buffer.
  (async-shell-command "push"))

(defun push-all ()
  "Execute git add, commit, and push in sequence asynchronously."
  (interactive)
  ;; Execute 'push' asynchronously and display output in a separate buffer.
  (async-shell-command "push -a"))

(defun s ()
  "Reload the ~/.zshrc file in the current shell."
  (interactive)
  (call-process-shell-command "source ~/.zshrc" nil 0))

(defun home ()
  "Open a specific file."
  (interactive)
  (find-file "~/"))

(defun alias ()
  "Open a specific file."
  (interactive)
  (find-file "~/.emacs.d/eshell/aliases"))

(defun root ()
  "Open a specific file."
  (interactive)
  (find-file "/"))

(defun theme ()
  "Open a specific file."
  (interactive)
  (find-file "~/.emacs.d/themes/rose-pine-theme.el"))

(defun trash ()
  "Open a specific file."
  (interactive)
  (find-file "~/.local/share/trash"))

(defun ngrok ()
  "Open a terminal and execute 'ngrok http http://localhost:8080'."
  (interactive)
  (let ((term-buffer-name "*ngrok-http-8080*"))
    ;; Check if the buffer already exists
    (if (get-buffer term-buffer-name)
        ;; If it does, switch to it
        (switch-to-buffer term-buffer-name)
      ;; Otherwise, create a new terminal and execute the command
      (progn
        (ansi-term "/bin/bash" "ngrok-http-8080")
        (rename-buffer term-buffer-name)
        (comint-send-string nil "ngrok http http://localhost:8080\n")
        (popper-toggle-type)))))

(defun bin ()
  "Open a specific file."
  (interactive)
  (find-file "/usr/local/bin"))

(defun books ()
  "Open a specific file."
  (interactive)
  (find-file "~/Downloads/books"))

(defun dot ()
  "Open a specific file."
  (interactive)
  (find-file "~/.dotfiles"))

(defun etc ()
  "Open a specific file."
  (interactive)
  (find-file "/etc"))

(defun snip ()
  "Open a specific file."
  (interactive)
  (find-file "~/.emacs.d/snippets/"))

;; When i had this function as 'log', i had an unexplained org mode bug.
(defun logs ()
  "Open a specific file."
  (interactive)
  (find-file "/var/log"))

(defun source ()
  "Open a specific file."
  (interactive)
  (find-file "~/.source"))

(defun tmp ()
  "Open a specific file."
  (interactive)
  (find-file "/tmp"))

(defun service ()
  "Open a specific file."
  (interactive)
  (find-file "/etc/systemd/system"))

(defun add-execute-permissions-to-current-file ()
  "Add execute permissions to the file associated with the current buffer."
  (interactive)
  (when buffer-file-name
    (let ((filename (file-truename buffer-file-name)))
      (shell-command (concat "chmod +x " (shell-quote-argument filename)))
      (message "Execute permissions added to %s" filename))))

(defun crontab-edit ()
  "Run `crontab -e' in a emacs buffer."
  (interactive)
  (with-editor-async-shell-command "crontab -e"))

#+end_src
