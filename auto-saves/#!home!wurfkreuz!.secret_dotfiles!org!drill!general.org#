* Sudo  :drill:
SCHEDULED: <2024-04-03 Wed>
:PROPERTIES:
:ID:       63ef2f14-b6ea-46a3-88ae-912f2bdbe8a0
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [Y-03-30 Sat 21:%]
:END:

Explain how sudo works.

** Answer
Sudo executable has a special permission bit that spawns a proccess with a UID
of a user who owns it (which is usually /0/ aka /root/). At an attempt to execute
the binary sudo looks at a sudoers file to check permissions for using sudo for
a current user who is currently executing the binary.  After the sudo usage a
special timestamp file is created with a life duration identical to a time to
which is the user allowed to use sudo without a password. Sudo checks this file
for its existence when decides you to prompt for a password or not.

You can fine tune permissions. For instance, to set permission that allows a
user to use sudo only on specific binary:

~username ALL=/path/to/command~

** Notes

/ALL/ means the user can run the specified command on any host. (+but i don't know
situations where i can use 'sudo' not from a localhost+)

* Postgres                                                            :drill:
SCHEDULED: <2024-04-03 Wed>
:PROPERTIES:
:ID:       f45f55e9-b363-405b-b5ce-b6e854a43fef
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 2
:DRILL_FAILURE_COUNT: 1
:DRILL_AVERAGE_QUALITY: 2.5
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [Y-03-30 Sat 21:%]
:END:

How to check permissions of a user in postger?

** Answer

\du

** Notes

It's probably doesn't matter from which user to run this command.
This is how the output looks:

#+begin_src text
  
                                 List of roles
   Role name |                         Attributes
  -----------+------------------------------------------------------------
   postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS
   wurfkreuz | Create DB

#+end_src

* Postgers                                                            :drill:
:PROPERTIES:
:ID:       e4993dcc-a1f2-4b7c-9318-b84c5ec6dbce
:DRILL_LAST_INTERVAL: 0.0
:DRILL_REPEATS_SINCE_FAIL: 1
:DRILL_TOTAL_REPEATS: 6
:DRILL_FAILURE_COUNT: 6
:DRILL_AVERAGE_QUALITY: 1.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 1
:DRILL_LAST_REVIEWED: [Y-03-31 Sun 10:%]
:END:

How to give a user permissions to create databases?

** Answer

#+begin_src sql

  ALTER USER user_name CREATEDB;
        
#+end_src

* Postgres                                                            :drill:
:PROPERTIES:
:ID:       c6bfa2cd-64e3-4e93-b288-5f57307ccca3
:END:

How to create a new user?

** Answer

#+begin_src sql

  CREATE USER new_user WITH PASSWORD 'your_password';
         
#+end_src

* Postgres                                                            :drill:
:PROPERTIES:
:ID:       11a0ae30-01dc-4bae-946a-e54912a54e6b
:DRILL_LAST_INTERVAL: 0.0
:DRILL_REPEATS_SINCE_FAIL: 1
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 3
:DRILL_AVERAGE_QUALITY: 1.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 1
:DRILL_LAST_REVIEWED: [Y-03-31 Sun 09:%]
:END:

How to add a new column to a database?

** Answer

#+begin_src sql

  ALTER TABLE books ADD COLUMN new_field TEXT;
         
#+end_src

* Cloud                                                               :drill:
SCHEDULED: <2024-04-04 Thu>
:PROPERTIES:
:ID:       110c3070-62cb-4118-8e8a-c7ed3b5a7b48
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [Y-03-31 Sun 09:%]
:END:

What does provisioning mean?

** Answer

Предоставление необходимых ресурсов и инфраструктуры для роботоспособности софта.
This includes:

- Servers: Virtual or physical machines to run your code.  Databases: Systems to
  store and manage your application's data.
- Networking: Configuring how different components of your system communicate
  with each other and the outside world.
- Software Dependencies: Installing required libraries, frameworks, or runtime
  environments.
  
* Cloud                                                               :drill:
:PROPERTIES:
:ID:       91b41a48-287d-4058-82a4-fced5a3ce560
:END:

What is a cold start?

** Answer

Cold starts refer to the phenomenon where a serverless function experiences a
slight delay when it is invoked after a period of inactivity. When a function is
invoked for the first time or after a certain period of inactivity, the
serverless platform needs to allocate resources, set up the runtime environment,
and initialize the function before it can start executing. This process
introduces a small latency known as a cold start.

* Cloud                                                               :drill:
:PROPERTIES:
:ID:       58122daa-8b3b-4189-8a2d-54697db69f23
:END:

What does /servesless/ manage?

** Answer

Without using a serverless solution like AWS Lambda, you would need to set up
and manage the following infrastructure components:

1. Virtual Machines (EC2 instances):
   - You would need to provision and manage virtual machines (EC2 instances) to
     run your code.
   - You would be responsible for selecting the appropriate instance type,
     configuring the operating system, and installing necessary dependencies.
   - You would need to ensure that the instances are properly scaled to handle
     the incoming requests and have sufficient capacity to process the alerts.

2. Scaling and Auto Scaling:
   - To handle varying workloads and ensure high availability, you would need to
     implement scaling mechanisms.
   - This could involve setting up Auto Scaling groups to automatically adjust
     the number of instances based on the incoming traffic.
   - You would need to define scaling policies, configure load balancers, and
     monitor the performance of your instances.

3. Operating System and Software Updates:
   - You would be responsible for keeping the operating system and installed
     software up to date on your instances.
   - This includes applying security patches, updating dependencies, and
     ensuring compatibility with the latest versions.

4. Networking and Security:
   - You would need to configure networking for your instances, including
     setting up virtual private clouds (VPCs), subnets, and security groups.
   - You would be responsible for implementing appropriate security measures,
     such as firewalls, access controls, and encryption.
     
5. Monitoring and Logging:
   - To ensure the health and performance of your infrastructure, you would
     need to set up monitoring and logging solutions.
   - This could involve configuring monitoring agents, collecting logs,
     setting up alerts, and using tools like Amazon CloudWatch or third-party
     monitoring services.

6. Deployment and Code Management:
   - You would need to establish a deployment pipeline to push your code changes
     to the instances.
   - This could involve setting up continuous integration and continuous
     deployment (CI/CD) processes, managing version control, and handling
     rollbacks if necessary.
     
** Notes

It's worth noting that while Lambda abstracts away the infrastructure
management, you still need to consider factors such as function packaging,
dependencies, resource allocation (e.g., memory and timeout settings), and
integration with other AWS services (e.g., CloudWatch Events for triggering the
function).

* Git                                                                 :drill:
:PROPERTIES:
:ID:       3beae089-24f6-4c8b-b40b-2fe9e483e447
:END:

Command for checking a last commit log.

** Answer

#+begin_src shell

  git log -1
  
#+end_src

* Git                                                                 :drill:
SCHEDULED: <2024-04-03 Wed>
:PROPERTIES:
:ID:       6853285f-479f-4a7b-9af5-00584a671422
:DRILL_LAST_INTERVAL: 4.14
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 5.0
:DRILL_EASE: 2.6
:DRILL_LAST_QUALITY: 5
:DRILL_LAST_REVIEWED: [Y-03-30 Sat 21:%]
:END:

Command for showing uncommited changes

** Answer

#+begin_src shell

  git status
  
#+end_src

* Security                                                            :drill:
SCHEDULED: <2024-04-04 Thu>
:PROPERTIES:
:ID:       a0afc54f-4488-427b-ab03-d508921d32fc
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 3
:DRILL_FAILURE_COUNT: 2
:DRILL_AVERAGE_QUALITY: 2.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [Y-03-31 Sun 09:%]
:END:

What are symmetric and asymmetric mean in encryption?

** Answer

In symmetric encryption, both the client and the server use the same key for
both encrypting and decrypting data. This is in contrast to asymmetric
encryption (like your SSH key pair), where there's a public key for encryption
and a different private key for decryption.

* Security                                                            :drill:
:PROPERTIES:
:ID:       6941b2b0-ffc7-444d-a2ed-52f676c16e5b
:END:

How ssh works?

** Answer

You, the client, reach out to the server, essentially saying "I want to start an
SSH connection."

Along with this, you send a list of supported key exchange algorithms,
encryption ciphers, etc.  The server responds with its own list of supported
methods from the ones you offered.  Both aiming to select the most secure option
available on both sides.

After that each side generates an identical shared secret. That's important
because at this stage the connection isn't encrypted.

The shared secret acts as the foundation for generating symmetric encryption
keys that, again, are identical for client and server. These keys will encrypt
and decrypt the data within the session.

Once the encrypted tunnel is established, SSH authenticates the user. This
typically involves a password or public/private key authentication.

The server has a file called 'authorized_keys' with a list of public keys. For
each pubilc key it creates a encrypted message and sends it to a client for it
to encrypt.

Your client, possessing the corresponding private key, is the only one able to
decrypt the server's challenge.  The client decrypts the data and sends it back
to the server.

The server verifies if the response it received matches the original data it had
sent.  If it matches, this proves you possess the private key associated with
the public key on the server.

** Notes

The reason why i need to additionally preconfigure ssh for github and gitlab is
probably because in order to connect, i need to specify a secret key, which i
don't do when i execute git commands.

* Cloud                                                               :drill:
:PROPERTIES:
:ID:       68e680aa-49f5-4eab-9278-9b2b01b8235e
:END:

How to check the current user on aws cli?

** Answer

#+begin_src shell

  aws sts get-caller-identity
  
#+end_src

* Postgres                                                            :drill:
:PROPERTIES:
:ID:       47e5f3a7-08f1-4234-bbcb-b9e50abdc21f
:DRILL_LAST_INTERVAL: 0.0
:DRILL_REPEATS_SINCE_FAIL: 1
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 1.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 1
:DRILL_LAST_REVIEWED: [Y-03-31 Sun 09:%]
:END:

How to create a database without going into psql? 

** Answer

#+begin_src shell

  createdb -U postgres my_new_database
  
#+end_src

* Postgres                                                            :drill:
:PROPERTIES:
:ID:       35ccb935-b473-4101-aa7f-3f62239ff1da
:END:

Breakdown this sql table:

#+begin_src sql

  CREATE TABLE books (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    author TEXT,
    file_path TEXT,
    uploaded_at TIMESTAMP NOT NULL
  );
          
#+end_src

** Answer

/BIGSERIAL/: A large auto-incrementing integer data type. PostgreSQL automatically
generates a unique, sequential number for each new row added to the table.

/PRIMARY KEY/: This constraint enforces that the id column must have unique values
and cannot be NULL (empty).

/NOT NULL/: This constraint means a table field cannot be empty when inserting a
new book record.

* Postgres                                                            :drill:
:PROPERTIES:
:ID:       f892d60e-571f-4887-9660-b5e29b0d7a67
:END:

Write an example of an url for sql database

[postgres]://[wurfkreuz]:[1337@localhost]:[5432/shelf]

* Shell                                                               :drill:
:PROPERTIES:
:ID:       18efa9f0-d7dc-415b-85e1-06da50337b4f
:END:

Find all directories with git repos, but exclude those
that usually have many git directories like
'.cache', '.share' and so on.

** Answer

#+begin_src shell

  find <directory> -type d -name '.git' \
    -not -path '*/.local/*' \
    -not -path '*/.share/*' \
    -printf '%p\n'
  
#+end_src

or

#+begin_src shell

  find <directory> -type d -name '.git' \
    -not -path '*/.local/*' \
    -not -path '*/.share/*' \
    -exec echo {} \;
  
#+end_src

** Notes

In the context of the find command you've provided, the backslashes (*\*) are used
for line continuation in shell scripts. They allow a single command to be split
across multiple lines, making the command easier to read and understand,
especially when it contains many options or filters.

/%p/ is a format sequence that stands for "print the file's name." It represents
the pathname of the current file. This is similar to how /%f/ would print just the
file name without the directory path.

/\n/ is a newline character. It ensures that each file name is printed on a new
line, making the output easier to read, especially when there are many matches.

* Postgres                                                            :drill:
:PROPERTIES:
:ID:       a473d6fc-a637-44d7-ae6f-aa76cfd0cbf1
:DRILL_LAST_INTERVAL: 0.0
:DRILL_REPEATS_SINCE_FAIL: 1
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 1.25
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 1
:DRILL_LAST_REVIEWED: [Y-03-31 Sun 10:%]
:END:

How to change password for a user in postgres?

** Answer

#+begin_src sql

  ALTER USER username PASSWORD 'password'
        
#+end_src

* Shell                                                               :drill:
:PROPERTIES:
:ID:       b5a6098a-9a7f-419e-b669-bdf7aa07b85f
:END:

How to define default value in bash?

** Answer

Example:

#+begin_src shell

  TARGET="${2:-/user/local/bin}"
  
#+end_src

** Notes

when you use parameter expansions like ~${2:-/user/local/bin}~, the $ sign is
placed outside the curly brackets. The reason for this is that the curly
brackets {} are used to delimit the parameter and any associated operations or
modifiers.
If you were to place the $ sign inside the curly brackets, like
~${$2:-/user/local/bin}~, it would be interpreted differently and would not
achieve the desired result. In this case, Bash would try to expand the value of
$2 first and then use that value as the parameter name inside the curly
brackets, which is not what you intend to do.

* Shell                                                               :drill:
:PROPERTIES:
:ID:       ea77e958-1a05-442b-990d-95e847b6b506
:END:

Symbol for representing a number of arguments that are passed to a function.

** Answer

#+begin_src shell

  if [[ "$#" -lt 1 ]]; then
      
#+end_src

** Notes

"$#": This special parameter expands to the number of positional parameters in
decimal. In simpler terms, it tells you how many arguments were passed to the
script. For example, if a script is run as ./myscript arg1 arg2 arg3, then $#
would expand to 3.

* Title :drill:
:PROPERTIES:
:ID:       cc32cb2a-7561-4643-afd5-577baaf573b3
:END:

Bash script for moving all playbooks into the playbooks directory
.
├── playbookname1.yml
├── playbookname2.yaml
├── playbookname3.yml
├── playbookname4.yaml
├── directory1/
│   └── ...
├── directory2/
│   └── ...
├── .session
└── playbooks/

** Answer

  find . -type f [ -name -regex '.*\.(yaml|yml)' ] -exec mv {} playbooks/ \;

** Notes

Because the execution part serves as a loop, without semicolon it would add newly founded files to the rest of the command like this:

#+begin_src shell

  -exec mv filename playbooks/ filename
  
#+end_src

The backslash before the semicolon is necessary to escape it. Shells treat
semicolons as special characters used to separate multiple commands.

* Ansible                                                             :drill:
:PROPERTIES:
:ID:       b822b6bb-5dfa-43fe-8625-397dac6f2a2e
:END:

Differences between the command, raw, and shell modules in ansible

** Answer

|                      | command | shell | raw |
|----------------------+---------+-------+-----|
| run commands with    | -       | +     | +   |
| pipes or redirection |         |       |     |
|----------------------+---------+-------+-----|
| run commands without |         |       |     |
| python               | -       | -     | +   |
|----------------------+---------+-------+-----|

* Shell                                                               :drill:
:PROPERTIES:
:ID:       27605f4e-7bcb-4456-b314-367da0da156c
:END:

How to use the /ls/ command recursively

** Answer

#+begin_src shell

  ls **/*
  
#+end_src

** Notes

/**/: Matches any number of directories, including zero or more. It allows the
pattern to search recursively through nested directories.

* Shell                                                               :drill:
:PROPERTIES:
:ID:       600b9074-bda3-4153-aeec-b245259429e9
:END:

Code for deleting every .session file from the .dotfiles repo.

** Answer

#+begin_src shell

  find ~/.dotfiles -type f -name '.session' | while read -r file; do
      git rm --cached "$file"
  done
  
#+end_src

** Notes

~while read -r file; do:~ - /file/ is a placeholder.
The /-r/ option tells read not to treat backslashes as escape characters.

* Shell                                                               :drill:
:PROPERTIES:
:ID:       78973720-8111-483c-8859-9e771bc4ce9b
:END:

Bash patterns for subtracting strings.

** Answer

~local new_filename=${filename%.bak}~ - this would only subtract on the end.

~local new_filename=${filename//.bak/}~ - this would do it on all instances of
/.bak/.

* Shell                                                               :drill:
:PROPERTIES:
:ID:       9e7c6d0f-9c2f-429f-b9ad-fc4e0d9173ab
:END:

What does double quotes do when it comes to using variables in bash?

** Answer

Когда вы заключаете переменную в двойные кавычки /"$variable"/, это указывает
оболочке обрабатывать значение переменной как один аргумент, даже если оно
содержит пробелы или подстановочные знаки.  Также блокирует глоббинг.

For example:

Without quotes: rm $filename might unintentionally remove multiple files if
/$filename/ contains wildcard characters or splits into multiple words.

* Shell                                                               :drill:
SCHEDULED: <2024-04-03 Wed>
:PROPERTIES:
:ID:       47e17d37-3e40-4ebd-a3f3-398409aab4af
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [Y-03-30 Sat 21:%]
:END:

How to add user to a group?

** Answer

#+begin_src shell

  usermod -aG groupname username
  
#+end_src

* Shell                                                               :drill:
:PROPERTIES:
:ID:       4ff72ec7-987d-4412-a5f8-4646cf97ee44
:DRILL_LAST_INTERVAL: 0.0
:DRILL_REPEATS_SINCE_FAIL: 1
:DRILL_TOTAL_REPEATS: 4
:DRILL_FAILURE_COUNT: 4
:DRILL_AVERAGE_QUALITY: 1.25
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 1
:DRILL_LAST_REVIEWED: [Y-03-31 Sun 10:%]
:END:

How to check users created by you in a basic scenario using awk?

  awk /flag/ '*condition* {*action*}' /directory/

** Answer

#+begin_src awk

  awk -F: '$3>=1000 {print $1}' /etc/passwd
  
#+end_src

* Shell                                                               :drill:
:PROPERTIES:
:ID:       590f7d5a-b8ad-47b0-8705-6ee8da9dbcbd
:END:

Std redirection shortcuts.

** Answer

/&>/ - stdout and stderr

command > ~/dev/null 2>&1~ - redirects file descriptor 2 (stderr) to the same place
as file descriptor 1 (stdout). _(it should be noted that in this case the
redirection described after the path, not before, as usual)_

* Shell                                                               :drill:
SCHEDULED: <2024-04-03 Wed>
:PROPERTIES:
:ID:       5403910f-599a-43b6-be1c-3acda8a49d7d
:DRILL_LAST_INTERVAL: 4.0
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 4.0
:DRILL_EASE: 2.5
:DRILL_LAST_QUALITY: 4
:DRILL_LAST_REVIEWED: [Y-03-30 Sat 21:%]
:END:

Meaning of 0, 1, 2 std abbreviations in shell scripting

** Answer

0 - Standard Input 

1 - Standard Output 

2 - Standard Error

* Shell                                                               :drill:
:PROPERTIES:
:ID:       c45ed1c8-5b2a-42ca-87a9-bf1514a2c98d
:END:

How to use tar?

** Answer

~tar -xvf file.tar -C /path/to/directory~ - example of extraction

~tar -cvzf name-of-archive.tar destination/~ - example of complession

** Notes

Tar has a separation - lowercase flags that operate on input (archive/files) and
uppercase flags that operate on output within tar.

So, in the original example (-x file.tar) produces output that is captured then
by the '-C' flag. The '-C' flag changes the output location after extraction,
not changing how tar extracts the archive.

- The -x option tells tar to extract the files.

- The -C option allows you to specify the directory to which the files will be
  extracted. Replace /path/to/directory with your desired directory.

The '-C' flag changes a state of tar. It should go to a directory and create
file there. That's probably the reason it's an uppercase letter.

- The -v option makes tar talk a lot (verbose mode), it will report the name of every file it processes.

- /-z/ compresses the archive with gzip

- -f option tells tar that you are going to give it the name of the archive
  file. But when it comes extraction, the logic is mostly for consistency.

  Future-proofing: While it may seem redundant when dealing with a single file,
  the -f flag becomes essential when you start working with multiple files or
  when you're writing scripts that handle tar operations. It ensures that your
  command will work even when you start dealing with multiple files.

* Postgres                                                            :drill:
:PROPERTIES:
:ID:       529984c0-491e-4d84-a0ec-b33b6bea226d
:END:

How to remove a table?

** Answer

#+begin_src sql

  DROP TABLE table_name;
          
#+end_src

* Postgre                                                             :drill:
:PROPERTIES:
:ID:       ba669922-30eb-44c4-9349-0e441e39468b
:END:

How to rename a table?

** Answer

#+begin_src sql

  ALTER TABLE old_table_name RENAME TO new_table_name; 
        
#+end_src

* Title :drill:
:PROPERTIES:
:ID:       6dab3a7c-a14c-4124-9bf8-461263ec85c0
:END:

\du - [list all users]
\dt - [list all tables]
\l - [list all databases and meta information about it]

* Shell                                                               :drill:
SCHEDULED: <2024-04-03 Wed>
:PROPERTIES:
:ID:       fdafe47b-8b40-488b-8f81-ba7bb95d0334
:DRILL_LAST_INTERVAL: 3.86
:DRILL_REPEATS_SINCE_FAIL: 2
:DRILL_TOTAL_REPEATS: 1
:DRILL_FAILURE_COUNT: 0
:DRILL_AVERAGE_QUALITY: 3.0
:DRILL_EASE: 2.36
:DRILL_LAST_QUALITY: 3
:DRILL_LAST_REVIEWED: [Y-03-30 Sat 21:%]
:END:

How to create exception for /find/?

** Answer

You can negate any type by adding '-not':

find . -type f -maxdepth 1 -not -name "file_to_keep.txt" -exec rm {} \;

* Postgres

Explain constraints for this table:

#+begin_src sql

  CREATE TABLE books (
      id BIGSERIAL PRIMARY KEY,
      title VARCHAR(255) NOT NULL,
      author VARCHAR(255),
      file_path TEXT NULL,
      uploaded_at TIMESTAMP NOT NULL 
  );
          
#+end_src

** Answer

- /SERIAL/ automatically generates a unique, ever-increasing integer for each new
  row inserted into the table. /BIGSERIAL/ is a shorthand for a SERIAL data type
  with a larger range (8 bytes) compared to the standard SERIAL (4 bytes).
- /VARCHAR/ is a data type for storing short text. Where /TEXT/ is used for storing
  long text. In your example, /VARCHAR(255)/ can hold text data up to 255
  characters. 
- /PRIMARY KEY/ constraint enforces uniqueness and data integrity within a
 table. 

- /NOT NULL/ condition that says the column value can't be not provided, but it
  doesn't prevent from empty values to be inserted (like in a case of empty
  strings), at least in postgres.
- /NULL/ null is a propertly that allows to insert a value and to not have
  anything inserted at all.
- If you don't include either /NULL/ or /NOT NULL/ when defining a column in
  your database table, the default behavior depends on the specific database
  system you're using. So _columns properties should be explicit_.

* Postgres                                                            :drill:
:PROPERTIES:
:END:

How to delete an item by its id column?

** Answer

#+begin_src sql

  DELETE FROM table_name
  WHERE id = id_value;

#+end_src

* Title :drill:
:PROPERTIES:
:END:



** Answer